var bf = Object.defineProperty;
var Af = (e, t, n) => t in e ? bf(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n;
var Tt = (e, t, n) => (Af(e, typeof t != "symbol" ? t + "" : t, n), n);
import { getAddress as Vt, getContract as eo, encodeFunctionData as De, pad as Ya, getContractAddress as Za, encodeAbiParameters as Ja, concat as Xa, bytesToHex as xf, numberToBytes as Ef, parseAbi as vf, createPublicClient as Bf, custom as If, http as Mf, isAddressEqual as Tf, numberToHex as Cf, hexToNumber as ss, parseUnits as $o } from "viem";
const Sf = [
  {
    inputs: [],
    name: "InitializationFailed",
    type: "error"
  },
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !1,
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "address",
        name: "tokenContract",
        type: "address"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "uint256",
        name: "salt",
        type: "uint256"
      }
    ],
    name: "AccountCreated",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "tokenContract",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "salt",
        type: "uint256"
      }
    ],
    name: "account",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "implementation",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "tokenContract",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "salt",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "initData",
        type: "bytes"
      }
    ],
    name: "createAccount",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
], Uf = [
  {
    anonymous: !1,
    inputs: [
      {
        indexed: !0,
        internalType: "address",
        name: "target",
        type: "address"
      },
      {
        indexed: !0,
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        indexed: !1,
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "TransactionExecuted",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "value",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "executeCall",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "nonce",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "token",
    outputs: [
      {
        internalType: "uint256",
        name: "chainId",
        type: "uint256"
      },
      {
        internalType: "address",
        name: "tokenContract",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "tokenId",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    stateMutability: "payable",
    type: "receive"
  }
], Ff = [
  {
    inputs: [
      {
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        internalType: "address",
        name: "to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "id",
        type: "uint256"
      },
      {
        internalType: "uint256",
        name: "amount",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "data",
        type: "bytes"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], kf = [
  {
    inputs: [
      {
        internalType: "address",
        name: "_from",
        type: "address"
      },
      {
        internalType: "address",
        name: "_to",
        type: "address"
      },
      {
        internalType: "uint256",
        name: "_tokenId",
        type: "uint256"
      }
    ],
    name: "safeTransferFrom",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
], Nf = [
  {
    type: "event",
    inputs: [
      { name: "owner", type: "address", indexed: !0 },
      { name: "spender", type: "address", indexed: !0 },
      { name: "value", type: "uint256", indexed: !1 }
    ],
    name: "Approval"
  },
  {
    type: "event",
    inputs: [
      { name: "from", type: "address", indexed: !0 },
      { name: "to", type: "address", indexed: !0 },
      { name: "value", type: "uint256", indexed: !1 }
    ],
    name: "Transfer"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "owner", type: "address" },
      { name: "spender", type: "address" }
    ],
    name: "allowance",
    outputs: [{ name: "", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "spender", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    name: "approve",
    outputs: [{ name: "", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "account", type: "address" }],
    name: "balanceOf",
    outputs: [{ name: "", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "decimals",
    outputs: [{ name: "", type: "uint8" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "name",
    outputs: [{ name: "", type: "string" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "symbol",
    outputs: [{ name: "", type: "string" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "totalSupply",
    outputs: [{ name: "", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "recipient", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    name: "transfer",
    outputs: [{ name: "", type: "bool" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "sender", type: "address" },
      { name: "recipient", type: "address" },
      { name: "amount", type: "uint256" }
    ],
    name: "transferFrom",
    outputs: [{ name: "", type: "bool" }]
  }
], Rf = [
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate",
    outputs: [
      { internalType: "uint256", name: "blockNumber", type: "uint256" },
      { internalType: "bytes[]", name: "returnData", type: "bytes[]" }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bool", name: "allowFailure", type: "bool" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call3[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3",
    outputs: [
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bool", name: "allowFailure", type: "bool" },
          { internalType: "uint256", name: "value", type: "uint256" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call3Value[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "aggregate3Value",
    outputs: [
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "blockAndAggregate",
    outputs: [
      { internalType: "uint256", name: "blockNumber", type: "uint256" },
      { internalType: "bytes32", name: "blockHash", type: "bytes32" },
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [],
    name: "getBasefee",
    outputs: [{ internalType: "uint256", name: "basefee", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "uint256", name: "blockNumber", type: "uint256" }],
    name: "getBlockHash",
    outputs: [{ internalType: "bytes32", name: "blockHash", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getBlockNumber",
    outputs: [
      { internalType: "uint256", name: "blockNumber", type: "uint256" }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getChainId",
    outputs: [{ internalType: "uint256", name: "chainid", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockCoinbase",
    outputs: [{ internalType: "address", name: "coinbase", type: "address" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockDifficulty",
    outputs: [{ internalType: "uint256", name: "difficulty", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockGasLimit",
    outputs: [{ internalType: "uint256", name: "gaslimit", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getCurrentBlockTimestamp",
    outputs: [{ internalType: "uint256", name: "timestamp", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [{ internalType: "address", name: "addr", type: "address" }],
    name: "getEthBalance",
    outputs: [{ internalType: "uint256", name: "balance", type: "uint256" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getLastBlockHash",
    outputs: [{ internalType: "bytes32", name: "blockHash", type: "bytes32" }],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bool", name: "requireSuccess", type: "bool" },
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "tryAggregate",
    outputs: [
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  },
  {
    inputs: [
      { internalType: "bool", name: "requireSuccess", type: "bool" },
      {
        components: [
          { internalType: "address", name: "target", type: "address" },
          { internalType: "bytes", name: "callData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Call[]",
        name: "calls",
        type: "tuple[]"
      }
    ],
    name: "tryBlockAndAggregate",
    outputs: [
      { internalType: "uint256", name: "blockNumber", type: "uint256" },
      { internalType: "bytes32", name: "blockHash", type: "bytes32" },
      {
        components: [
          { internalType: "bool", name: "success", type: "bool" },
          { internalType: "bytes", name: "returnData", type: "bytes" }
        ],
        internalType: "struct Multicall3.Result[]",
        name: "returnData",
        type: "tuple[]"
      }
    ],
    stateMutability: "payable",
    type: "function"
  }
], Pf = [
  {
    stateMutability: "nonpayable",
    type: "constructor",
    inputs: [
      { name: "_guardian", internalType: "address", type: "address" },
      {
        name: "_initialImplementation",
        internalType: "address",
        type: "address"
      }
    ]
  },
  { type: "error", inputs: [], name: "AlreadyInitialized" },
  { type: "error", inputs: [], name: "InvalidImplementation" },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "previousAdmin",
        internalType: "address",
        type: "address",
        indexed: !1
      },
      {
        name: "newAdmin",
        internalType: "address",
        type: "address",
        indexed: !1
      }
    ],
    name: "AdminChanged"
  },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "beacon",
        internalType: "address",
        type: "address",
        indexed: !0
      }
    ],
    name: "BeaconUpgraded"
  },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "implementation",
        internalType: "address",
        type: "address",
        indexed: !0
      }
    ],
    name: "Upgraded"
  },
  { stateMutability: "payable", type: "fallback" },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "implementation", internalType: "address", type: "address" }
    ],
    name: "initialize",
    outputs: []
  },
  { stateMutability: "payable", type: "receive" }
], Df = [
  {
    stateMutability: "nonpayable",
    type: "constructor",
    inputs: [
      { name: "entryPoint_", internalType: "address", type: "address" },
      { name: "multicallForwarder", internalType: "address", type: "address" },
      { name: "erc6551Registry", internalType: "address", type: "address" },
      { name: "guardian", internalType: "address", type: "address" }
    ]
  },
  { type: "error", inputs: [], name: "AccountLocked" },
  { type: "error", inputs: [], name: "ContractCreationFailed" },
  { type: "error", inputs: [], name: "ExceedsMaxLockTime" },
  { type: "error", inputs: [], name: "InvalidAccountProof" },
  { type: "error", inputs: [], name: "InvalidERC6551Registry" },
  { type: "error", inputs: [], name: "InvalidEntryPoint" },
  { type: "error", inputs: [], name: "InvalidImplementation" },
  { type: "error", inputs: [], name: "InvalidInput" },
  { type: "error", inputs: [], name: "InvalidMulticallForwarder" },
  { type: "error", inputs: [], name: "InvalidOperation" },
  { type: "error", inputs: [], name: "NotAuthorized" },
  { type: "error", inputs: [], name: "OwnershipCycle" },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "previousAdmin",
        internalType: "address",
        type: "address",
        indexed: !1
      },
      {
        name: "newAdmin",
        internalType: "address",
        type: "address",
        indexed: !1
      }
    ],
    name: "AdminChanged"
  },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "beacon",
        internalType: "address",
        type: "address",
        indexed: !0
      }
    ],
    name: "BeaconUpgraded"
  },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "lockedUntil",
        internalType: "uint256",
        type: "uint256",
        indexed: !1
      }
    ],
    name: "LockUpdated"
  },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "owner",
        internalType: "address",
        type: "address",
        indexed: !1
      },
      {
        name: "selector",
        internalType: "bytes4",
        type: "bytes4",
        indexed: !1
      },
      {
        name: "implementation",
        internalType: "address",
        type: "address",
        indexed: !1
      }
    ],
    name: "OverrideUpdated"
  },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "owner",
        internalType: "address",
        type: "address",
        indexed: !1
      },
      {
        name: "caller",
        internalType: "address",
        type: "address",
        indexed: !1
      },
      {
        name: "hasPermission",
        internalType: "bool",
        type: "bool",
        indexed: !1
      }
    ],
    name: "PermissionUpdated"
  },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "implementation",
        internalType: "address",
        type: "address",
        indexed: !0
      }
    ],
    name: "Upgraded"
  },
  { stateMutability: "payable", type: "fallback" },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "entryPoint",
    outputs: [
      { name: "", internalType: "contract IEntryPoint", type: "address" }
    ]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "erc6551Registry",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      { name: "to", internalType: "address", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" },
      { name: "data", internalType: "bytes", type: "bytes" },
      { name: "operation", internalType: "uint8", type: "uint8" }
    ],
    name: "execute",
    outputs: [{ name: "", internalType: "bytes", type: "bytes" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      {
        name: "operations",
        internalType: "struct BatchExecutor.Operation[]",
        type: "tuple[]",
        components: [
          { name: "to", internalType: "address", type: "address" },
          { name: "value", internalType: "uint256", type: "uint256" },
          { name: "data", internalType: "bytes", type: "bytes" },
          { name: "operation", internalType: "uint8", type: "uint8" }
        ]
      }
    ],
    name: "executeBatch",
    outputs: [{ name: "", internalType: "bytes[]", type: "bytes[]" }]
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      { name: "to", internalType: "address", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" },
      { name: "data", internalType: "bytes", type: "bytes" },
      { name: "operation", internalType: "uint8", type: "uint8" },
      {
        name: "proof",
        internalType: "struct NestedAccountExecutor.ERC6551AccountInfo[]",
        type: "tuple[]",
        components: [
          { name: "salt", internalType: "bytes32", type: "bytes32" },
          { name: "tokenContract", internalType: "address", type: "address" },
          { name: "tokenId", internalType: "uint256", type: "uint256" }
        ]
      }
    ],
    name: "executeNested",
    outputs: [{ name: "", internalType: "bytes", type: "bytes" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "to", internalType: "address", type: "address" },
      { name: "value", internalType: "uint256", type: "uint256" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "extcall",
    outputs: [{ name: "result", internalType: "bytes", type: "bytes" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "value", internalType: "uint256", type: "uint256" },
      { name: "bytecode", internalType: "bytes", type: "bytes" }
    ],
    name: "extcreate",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "value", internalType: "uint256", type: "uint256" },
      { name: "salt", internalType: "bytes32", type: "bytes32" },
      { name: "bytecode", internalType: "bytes", type: "bytes" }
    ],
    name: "extcreate2",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "slot", internalType: "bytes32", type: "bytes32" }],
    name: "extsload",
    outputs: [{ name: "value", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "getNonce",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "isLocked",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "forwarder", internalType: "address", type: "address" }],
    name: "isTrustedForwarder",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "hash", internalType: "bytes32", type: "bytes32" },
      { name: "signature", internalType: "bytes", type: "bytes" }
    ],
    name: "isValidSignature",
    outputs: [{ name: "magicValue", internalType: "bytes4", type: "bytes4" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "signer", internalType: "address", type: "address" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "isValidSigner",
    outputs: [{ name: "magicValue", internalType: "bytes4", type: "bytes4" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "_lockedUntil", internalType: "uint256", type: "uint256" }
    ],
    name: "lock",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "lockedUntil",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "uint256[]", type: "uint256[]" },
      { name: "", internalType: "uint256[]", type: "uint256[]" },
      { name: "", internalType: "bytes", type: "bytes" }
    ],
    name: "onERC1155BatchReceived",
    outputs: [{ name: "", internalType: "bytes4", type: "bytes4" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "bytes", type: "bytes" }
    ],
    name: "onERC1155Received",
    outputs: [{ name: "", internalType: "bytes4", type: "bytes4" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "address", type: "address" },
      { name: "tokenId", internalType: "uint256", type: "uint256" },
      { name: "", internalType: "bytes", type: "bytes" }
    ],
    name: "onERC721Received",
    outputs: [{ name: "", internalType: "bytes4", type: "bytes4" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "bytes4", type: "bytes4" }
    ],
    name: "overrides",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "owner",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "", internalType: "address", type: "address" },
      { name: "", internalType: "address", type: "address" }
    ],
    name: "permissions",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "proxiableUUID",
    outputs: [{ name: "", internalType: "bytes32", type: "bytes32" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "selectors", internalType: "bytes4[]", type: "bytes4[]" },
      { name: "implementations", internalType: "address[]", type: "address[]" }
    ],
    name: "setOverrides",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "callers", internalType: "address[]", type: "address[]" },
      { name: "_permissions", internalType: "bool[]", type: "bool[]" }
    ],
    name: "setPermissions",
    outputs: []
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "state",
    outputs: [{ name: "", internalType: "uint256", type: "uint256" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [{ name: "interfaceId", internalType: "bytes4", type: "bytes4" }],
    name: "supportsInterface",
    outputs: [{ name: "", internalType: "bool", type: "bool" }]
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [],
    name: "token",
    outputs: [
      { name: "chainId", internalType: "uint256", type: "uint256" },
      { name: "tokenContract", internalType: "address", type: "address" },
      { name: "tokenId", internalType: "uint256", type: "uint256" }
    ]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "newImplementation", internalType: "address", type: "address" }
    ],
    name: "upgradeTo",
    outputs: []
  },
  {
    stateMutability: "payable",
    type: "function",
    inputs: [
      { name: "newImplementation", internalType: "address", type: "address" },
      { name: "data", internalType: "bytes", type: "bytes" }
    ],
    name: "upgradeToAndCall",
    outputs: []
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      {
        name: "userOp",
        internalType: "struct UserOperation",
        type: "tuple",
        components: [
          { name: "sender", internalType: "address", type: "address" },
          { name: "nonce", internalType: "uint256", type: "uint256" },
          { name: "initCode", internalType: "bytes", type: "bytes" },
          { name: "callData", internalType: "bytes", type: "bytes" },
          { name: "callGasLimit", internalType: "uint256", type: "uint256" },
          {
            name: "verificationGasLimit",
            internalType: "uint256",
            type: "uint256"
          },
          {
            name: "preVerificationGas",
            internalType: "uint256",
            type: "uint256"
          },
          { name: "maxFeePerGas", internalType: "uint256", type: "uint256" },
          {
            name: "maxPriorityFeePerGas",
            internalType: "uint256",
            type: "uint256"
          },
          { name: "paymasterAndData", internalType: "bytes", type: "bytes" },
          { name: "signature", internalType: "bytes", type: "bytes" }
        ]
      },
      { name: "userOpHash", internalType: "bytes32", type: "bytes32" },
      { name: "missingAccountFunds", internalType: "uint256", type: "uint256" }
    ],
    name: "validateUserOp",
    outputs: [
      { name: "validationData", internalType: "uint256", type: "uint256" }
    ]
  },
  { stateMutability: "payable", type: "receive" }
], Of = [
  { type: "error", inputs: [], name: "AccountCreationFailed" },
  {
    type: "event",
    anonymous: !1,
    inputs: [
      {
        name: "account",
        internalType: "address",
        type: "address",
        indexed: !1
      },
      {
        name: "implementation",
        internalType: "address",
        type: "address",
        indexed: !0
      },
      {
        name: "salt",
        internalType: "bytes32",
        type: "bytes32",
        indexed: !1
      },
      {
        name: "chainId",
        internalType: "uint256",
        type: "uint256",
        indexed: !1
      },
      {
        name: "tokenContract",
        internalType: "address",
        type: "address",
        indexed: !0
      },
      {
        name: "tokenId",
        internalType: "uint256",
        type: "uint256",
        indexed: !0
      }
    ],
    name: "ERC6551AccountCreated"
  },
  {
    stateMutability: "view",
    type: "function",
    inputs: [
      { name: "implementation", internalType: "address", type: "address" },
      { name: "salt", internalType: "bytes32", type: "bytes32" },
      { name: "chainId", internalType: "uint256", type: "uint256" },
      { name: "tokenContract", internalType: "address", type: "address" },
      { name: "tokenId", internalType: "uint256", type: "uint256" }
    ],
    name: "account",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  },
  {
    stateMutability: "nonpayable",
    type: "function",
    inputs: [
      { name: "implementation", internalType: "address", type: "address" },
      { name: "salt", internalType: "bytes32", type: "bytes32" },
      { name: "chainId", internalType: "uint256", type: "uint256" },
      { name: "tokenContract", internalType: "address", type: "address" },
      { name: "tokenId", internalType: "uint256", type: "uint256" }
    ],
    name: "createAccount",
    outputs: [{ name: "", internalType: "address", type: "address" }]
  }
];
function Wa(e) {
  const t = e.slice(2), n = new Uint8Array(t.length / 2);
  for (let r = 0; r < t.length; r += 2)
    n[r / 2] = Number.parseInt(t.substr(r, 2), 16);
  return n;
}
function ve(e) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...e
  };
}
const $a = "2.21.32";
let xr = {
  getDocsUrl: ({ docsBaseUrl: e, docsPath: t = "", docsSlug: n }) => t ? `${e ?? "https://viem.sh"}${t}${n ? `#${n}` : ""}` : void 0,
  version: `viem@${$a}`
};
class it extends Error {
  constructor(t, n = {}) {
    var u;
    const r = (() => {
      var d;
      return n.cause instanceof it ? n.cause.details : (d = n.cause) != null && d.message ? n.cause.message : n.details;
    })(), i = (() => n.cause instanceof it && n.cause.docsPath || n.docsPath)(), s = (u = xr.getDocsUrl) == null ? void 0 : u.call(xr, { ...n, docsPath: i }), o = [
      t || "An error occurred.",
      "",
      ...n.metaMessages ? [...n.metaMessages, ""] : [],
      ...s ? [`Docs: ${s}`] : [],
      ...r ? [`Details: ${r}`] : [],
      ...xr.version ? [`Version: ${xr.version}`] : []
    ].join(`
`);
    super(o, n.cause ? { cause: n.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: "BaseError"
    }), this.details = r, this.docsPath = i, this.metaMessages = n.metaMessages, this.name = n.name ?? this.name, this.shortMessage = t, this.version = $a;
  }
  walk(t) {
    return tu(this, t);
  }
}
function tu(e, t) {
  return t != null && t(e) ? e : e && typeof e == "object" && "cause" in e ? tu(e.cause, t) : t ? null : e;
}
class Lf extends it {
  constructor({ max: t, min: n, signed: r, size: i, value: s }) {
    super(`Number "${s}" is not in safe ${i ? `${i * 8}-bit ${r ? "signed" : "unsigned"} ` : ""}integer range ${t ? `(${n} to ${t})` : `(above ${n})`}`, { name: "IntegerOutOfRangeError" });
  }
}
class _f extends it {
  constructor({ givenSize: t, maxSize: n }) {
    super(`Size cannot exceed ${n} bytes. Given size: ${t} bytes.`, { name: "SizeOverflowError" });
  }
}
function Rn(e, { strict: t = !0 } = {}) {
  return !e || typeof e != "string" ? !1 : t ? /^0x[0-9a-fA-F]*$/.test(e) : e.startsWith("0x");
}
function xn(e) {
  return Rn(e, { strict: !1 }) ? Math.ceil((e.length - 2) / 2) : e.length;
}
function ii(e, { dir: t = "left" } = {}) {
  let n = typeof e == "string" ? e.replace("0x", "") : e, r = 0;
  for (let i = 0; i < n.length - 1 && n[t === "left" ? i : n.length - i - 1].toString() === "0"; i++)
    r++;
  return n = t === "left" ? n.slice(r) : n.slice(0, n.length - r), typeof e == "string" ? (n.length === 1 && t === "right" && (n = `${n}0`), `0x${n.length % 2 === 1 ? `0${n}` : n}`) : n;
}
class eu extends it {
  constructor({ offset: t, position: n, size: r }) {
    super(`Slice ${n === "start" ? "starting" : "ending"} at offset "${t}" is out-of-bounds (size: ${r}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
}
class nu extends it {
  constructor({ size: t, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} size (${t}) exceeds padding size (${n}).`, { name: "SizeExceedsPaddingSizeError" });
  }
}
class ta extends it {
  constructor({ size: t, targetSize: n, type: r }) {
    super(`${r.charAt(0).toUpperCase()}${r.slice(1).toLowerCase()} is expected to be ${n} ${r} long, but is ${t} ${r} long.`, { name: "InvalidBytesLengthError" });
  }
}
function pr(e, { dir: t, size: n = 32 } = {}) {
  return typeof e == "string" ? Gf(e, { dir: t, size: n }) : zf(e, { dir: t, size: n });
}
function Gf(e, { dir: t, size: n = 32 } = {}) {
  if (n === null)
    return e;
  const r = e.replace("0x", "");
  if (r.length > n * 2)
    throw new nu({
      size: Math.ceil(r.length / 2),
      targetSize: n,
      type: "hex"
    });
  return `0x${r[t === "right" ? "padEnd" : "padStart"](n * 2, "0")}`;
}
function zf(e, { dir: t, size: n = 32 } = {}) {
  if (n === null)
    return e;
  if (e.length > n)
    throw new nu({
      size: e.length,
      targetSize: n,
      type: "bytes"
    });
  const r = new Uint8Array(n);
  for (let i = 0; i < n; i++) {
    const s = t === "right";
    r[s ? i : n - i - 1] = e[s ? i : e.length - i - 1];
  }
  return r;
}
const Hf = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function lt(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? Lt(e, t) : typeof e == "string" ? Kf(e, t) : typeof e == "boolean" ? Vf(e, t) : hn(e, t);
}
function Vf(e, t = {}) {
  const n = `0x${Number(e)}`;
  return typeof t.size == "number" ? (yr(n, { size: t.size }), pr(n, { size: t.size })) : n;
}
function hn(e, t = {}) {
  let n = "";
  for (let i = 0; i < e.length; i++)
    n += Hf[e[i]];
  const r = `0x${n}`;
  return typeof t.size == "number" ? (yr(r, { size: t.size }), pr(r, { dir: "right", size: t.size })) : r;
}
function Lt(e, t = {}) {
  const { signed: n, size: r } = t, i = BigInt(e);
  let s;
  r ? n ? s = (1n << BigInt(r) * 8n - 1n) - 1n : s = 2n ** (BigInt(r) * 8n) - 1n : typeof e == "number" && (s = BigInt(Number.MAX_SAFE_INTEGER));
  const o = typeof s == "bigint" && n ? -s - 1n : 0;
  if (s && i > s || i < o) {
    const d = typeof e == "bigint" ? "n" : "";
    throw new Lf({
      max: s ? `${s}${d}` : void 0,
      min: `${o}${d}`,
      signed: n,
      size: r,
      value: `${e}${d}`
    });
  }
  const u = `0x${(n && i < 0 ? (1n << BigInt(r * 8)) + BigInt(i) : i).toString(16)}`;
  return r ? pr(u, { size: r }) : u;
}
const Qf = /* @__PURE__ */ new TextEncoder();
function Kf(e, t = {}) {
  const n = Qf.encode(e);
  return hn(n, t);
}
const qf = /* @__PURE__ */ new TextEncoder();
function ru(e, t = {}) {
  return typeof e == "number" || typeof e == "bigint" ? Yf(e, t) : typeof e == "boolean" ? jf(e, t) : Rn(e) ? En(e, t) : iu(e, t);
}
function jf(e, t = {}) {
  const n = new Uint8Array(1);
  return n[0] = Number(e), typeof t.size == "number" ? (yr(n, { size: t.size }), pr(n, { size: t.size })) : n;
}
const en = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function ea(e) {
  if (e >= en.zero && e <= en.nine)
    return e - en.zero;
  if (e >= en.A && e <= en.F)
    return e - (en.A - 10);
  if (e >= en.a && e <= en.f)
    return e - (en.a - 10);
}
function En(e, t = {}) {
  let n = e;
  t.size && (yr(n, { size: t.size }), n = pr(n, { dir: "right", size: t.size }));
  let r = n.slice(2);
  r.length % 2 && (r = `0${r}`);
  const i = r.length / 2, s = new Uint8Array(i);
  for (let o = 0, u = 0; o < i; o++) {
    const d = ea(r.charCodeAt(u++)), w = ea(r.charCodeAt(u++));
    if (d === void 0 || w === void 0)
      throw new it(`Invalid byte sequence ("${r[u - 2]}${r[u - 1]}" in "${r}").`);
    s[o] = d * 16 + w;
  }
  return s;
}
function Yf(e, t) {
  const n = Lt(e, t);
  return En(n);
}
function iu(e, t = {}) {
  const n = qf.encode(e);
  return typeof t.size == "number" ? (yr(n, { size: t.size }), pr(n, { dir: "right", size: t.size })) : n;
}
function yr(e, { size: t }) {
  if (xn(e) > t)
    throw new _f({
      givenSize: xn(e),
      maxSize: t
    });
}
function on(e, t = {}) {
  const { signed: n } = t;
  t.size && yr(e, { size: t.size });
  const r = BigInt(e);
  if (!n)
    return r;
  const i = (e.length - 2) / 2, s = (1n << BigInt(i) * 8n - 1n) - 1n;
  return r <= s ? r : r - BigInt(`0x${"f".padStart(i * 2, "f")}`) - 1n;
}
function Pn(e, t = {}) {
  return Number(on(e, t));
}
function no(e, t) {
  return ({ exclude: n, format: r }) => ({
    exclude: n,
    format: (i) => {
      const s = t(i);
      if (n)
        for (const o of n)
          delete s[o];
      return {
        ...s,
        ...r(i)
      };
    },
    type: e
  });
}
const su = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function ro(e) {
  const t = {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    chainId: e.chainId ? Pn(e.chainId) : void 0,
    gas: e.gas ? BigInt(e.gas) : void 0,
    gasPrice: e.gasPrice ? BigInt(e.gasPrice) : void 0,
    maxFeePerBlobGas: e.maxFeePerBlobGas ? BigInt(e.maxFeePerBlobGas) : void 0,
    maxFeePerGas: e.maxFeePerGas ? BigInt(e.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: e.maxPriorityFeePerGas ? BigInt(e.maxPriorityFeePerGas) : void 0,
    nonce: e.nonce ? Pn(e.nonce) : void 0,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    type: e.type ? su[e.type] : void 0,
    typeHex: e.type ? e.type : void 0,
    value: e.value ? BigInt(e.value) : void 0,
    v: e.v ? BigInt(e.v) : void 0
  };
  return e.authorizationList && (t.authorizationList = Jf(e.authorizationList)), t.yParity = (() => {
    if (e.yParity)
      return Number(e.yParity);
    if (typeof t.v == "bigint") {
      if (t.v === 0n || t.v === 27n)
        return 0;
      if (t.v === 1n || t.v === 28n)
        return 1;
      if (t.v >= 35n)
        return t.v % 2n === 0n ? 1 : 0;
    }
  })(), t.type === "legacy" && (delete t.accessList, delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas, delete t.yParity), t.type === "eip2930" && (delete t.maxFeePerBlobGas, delete t.maxFeePerGas, delete t.maxPriorityFeePerGas), t.type === "eip1559" && delete t.maxFeePerBlobGas, t;
}
const Zf = /* @__PURE__ */ no("transaction", ro);
function Jf(e) {
  return e.map((t) => ({
    contractAddress: t.address,
    chainId: Number(t.chainId),
    nonce: Number(t.nonce),
    r: t.r,
    s: t.s,
    yParity: Number(t.yParity)
  }));
}
function ou(e) {
  var n;
  const t = (n = e.transactions) == null ? void 0 : n.map((r) => typeof r == "string" ? r : ro(r));
  return {
    ...e,
    baseFeePerGas: e.baseFeePerGas ? BigInt(e.baseFeePerGas) : null,
    blobGasUsed: e.blobGasUsed ? BigInt(e.blobGasUsed) : void 0,
    difficulty: e.difficulty ? BigInt(e.difficulty) : void 0,
    excessBlobGas: e.excessBlobGas ? BigInt(e.excessBlobGas) : void 0,
    gasLimit: e.gasLimit ? BigInt(e.gasLimit) : void 0,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : void 0,
    hash: e.hash ? e.hash : null,
    logsBloom: e.logsBloom ? e.logsBloom : null,
    nonce: e.nonce ? e.nonce : null,
    number: e.number ? BigInt(e.number) : null,
    size: e.size ? BigInt(e.size) : void 0,
    timestamp: e.timestamp ? BigInt(e.timestamp) : void 0,
    transactions: t,
    totalDifficulty: e.totalDifficulty ? BigInt(e.totalDifficulty) : null
  };
}
const Xf = /* @__PURE__ */ no("block", ou);
function Wf(e, { args: t, eventName: n } = {}) {
  return {
    ...e,
    blockHash: e.blockHash ? e.blockHash : null,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    logIndex: e.logIndex ? Number(e.logIndex) : null,
    transactionHash: e.transactionHash ? e.transactionHash : null,
    transactionIndex: e.transactionIndex ? Number(e.transactionIndex) : null,
    ...n ? { args: t, eventName: n } : {}
  };
}
const $f = {
  "0x0": "reverted",
  "0x1": "success"
};
function tl(e) {
  const t = {
    ...e,
    blockNumber: e.blockNumber ? BigInt(e.blockNumber) : null,
    contractAddress: e.contractAddress ? e.contractAddress : null,
    cumulativeGasUsed: e.cumulativeGasUsed ? BigInt(e.cumulativeGasUsed) : null,
    effectiveGasPrice: e.effectiveGasPrice ? BigInt(e.effectiveGasPrice) : null,
    gasUsed: e.gasUsed ? BigInt(e.gasUsed) : null,
    logs: e.logs ? e.logs.map((n) => Wf(n)) : null,
    to: e.to ? e.to : null,
    transactionIndex: e.transactionIndex ? Pn(e.transactionIndex) : null,
    status: e.status ? $f[e.status] : null,
    type: e.type ? su[e.type] || e.type : null
  };
  return e.blobGasPrice && (t.blobGasPrice = BigInt(e.blobGasPrice)), e.blobGasUsed && (t.blobGasUsed = BigInt(e.blobGasUsed)), t;
}
const el = /* @__PURE__ */ no("transactionReceipt", tl), nl = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function au(e) {
  const t = {};
  return typeof e.authorizationList < "u" && (t.authorizationList = rl(e.authorizationList)), typeof e.accessList < "u" && (t.accessList = e.accessList), typeof e.blobVersionedHashes < "u" && (t.blobVersionedHashes = e.blobVersionedHashes), typeof e.blobs < "u" && (typeof e.blobs[0] != "string" ? t.blobs = e.blobs.map((n) => hn(n)) : t.blobs = e.blobs), typeof e.data < "u" && (t.data = e.data), typeof e.from < "u" && (t.from = e.from), typeof e.gas < "u" && (t.gas = Lt(e.gas)), typeof e.gasPrice < "u" && (t.gasPrice = Lt(e.gasPrice)), typeof e.maxFeePerBlobGas < "u" && (t.maxFeePerBlobGas = Lt(e.maxFeePerBlobGas)), typeof e.maxFeePerGas < "u" && (t.maxFeePerGas = Lt(e.maxFeePerGas)), typeof e.maxPriorityFeePerGas < "u" && (t.maxPriorityFeePerGas = Lt(e.maxPriorityFeePerGas)), typeof e.nonce < "u" && (t.nonce = Lt(e.nonce)), typeof e.to < "u" && (t.to = e.to), typeof e.type < "u" && (t.type = nl[e.type]), typeof e.value < "u" && (t.value = Lt(e.value)), t;
}
function rl(e) {
  return e.map((t) => ({
    address: t.contractAddress,
    r: t.r,
    s: t.s,
    chainId: Lt(t.chainId),
    nonce: Lt(t.nonce),
    ...typeof t.yParity < "u" ? { yParity: Lt(t.yParity) } : {},
    ...typeof t.v < "u" && typeof t.yParity > "u" ? { v: Lt(t.v) } : {}
  }));
}
const Ei = 2n ** 256n - 1n;
function mr(e) {
  return `0x${e.reduce((t, n) => t + n.replace("0x", ""), "")}`;
}
class na extends it {
  constructor({ offset: t }) {
    super(`Offset \`${t}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
}
class il extends it {
  constructor({ length: t, position: n }) {
    super(`Position \`${n}\` is out of bounds (\`0 < position < ${t}\`).`, { name: "PositionOutOfBoundsError" });
  }
}
class sl extends it {
  constructor({ count: t, limit: n }) {
    super(`Recursive read limit of \`${n}\` exceeded (recursive read count: \`${t}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
}
const ol = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new sl({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(e) {
    if (e < 0 || e > this.bytes.length - 1)
      throw new il({
        length: this.bytes.length,
        position: e
      });
  },
  decrementPosition(e) {
    if (e < 0)
      throw new na({ offset: e });
    const t = this.position - e;
    this.assertPosition(t), this.position = t;
  },
  getReadCount(e) {
    return this.positionReadCount.get(e || this.position) || 0;
  },
  incrementPosition(e) {
    if (e < 0)
      throw new na({ offset: e });
    const t = this.position + e;
    this.assertPosition(t), this.position = t;
  },
  inspectByte(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectBytes(e, t) {
    const n = t ?? this.position;
    return this.assertPosition(n + e - 1), this.bytes.subarray(n, n + e);
  },
  inspectUint8(e) {
    const t = e ?? this.position;
    return this.assertPosition(t), this.bytes[t];
  },
  inspectUint16(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 1), this.dataView.getUint16(t);
  },
  inspectUint24(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 2), (this.dataView.getUint16(t) << 8) + this.dataView.getUint8(t + 2);
  },
  inspectUint32(e) {
    const t = e ?? this.position;
    return this.assertPosition(t + 3), this.dataView.getUint32(t);
  },
  pushByte(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++;
  },
  pushBytes(e) {
    this.assertPosition(this.position + e.length - 1), this.bytes.set(e, this.position), this.position += e.length;
  },
  pushUint8(e) {
    this.assertPosition(this.position), this.bytes[this.position] = e, this.position++;
  },
  pushUint16(e) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, e), this.position += 2;
  },
  pushUint24(e) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, e >> 8), this.dataView.setUint8(this.position + 2, e & 255), this.position += 3;
  },
  pushUint32(e) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, e), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectByte();
    return this.position++, e;
  },
  readBytes(e, t) {
    this.assertReadLimit(), this._touch();
    const n = this.inspectBytes(e);
    return this.position += t ?? e, n;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint8();
    return this.position += 1, e;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint16();
    return this.position += 2, e;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint24();
    return this.position += 3, e;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const e = this.inspectUint32();
    return this.position += 4, e;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(e) {
    const t = this.position;
    return this.assertPosition(e), this.position = e, () => this.position = t;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const e = this.getReadCount();
    this.positionReadCount.set(this.position, e + 1), e > 0 && this.recursiveReadCount++;
  }
};
function uu(e, { recursiveReadLimit: t = 8192 } = {}) {
  const n = Object.create(ol);
  return n.bytes = e, n.dataView = new DataView(e.buffer, e.byteOffset, e.byteLength), n.positionReadCount = /* @__PURE__ */ new Map(), n.recursiveReadLimit = t, n;
}
function vn(e, t = "hex") {
  const n = cu(e), r = uu(new Uint8Array(n.length));
  return n.encode(r), t === "hex" ? hn(r.bytes) : r.bytes;
}
function cu(e) {
  return Array.isArray(e) ? al(e.map((t) => cu(t))) : ul(e);
}
function al(e) {
  const t = e.reduce((i, s) => i + s.length, 0), n = fu(t);
  return {
    length: (() => t <= 55 ? 1 + t : 1 + n + t)(),
    encode(i) {
      t <= 55 ? i.pushByte(192 + t) : (i.pushByte(192 + 55 + n), n === 1 ? i.pushUint8(t) : n === 2 ? i.pushUint16(t) : n === 3 ? i.pushUint24(t) : i.pushUint32(t));
      for (const { encode: s } of e)
        s(i);
    }
  };
}
function ul(e) {
  const t = typeof e == "string" ? En(e) : e, n = fu(t.length);
  return {
    length: (() => t.length === 1 && t[0] < 128 ? 1 : t.length <= 55 ? 1 + t.length : 1 + n + t.length)(),
    encode(i) {
      t.length === 1 && t[0] < 128 ? i.pushBytes(t) : t.length <= 55 ? (i.pushByte(128 + t.length), i.pushBytes(t)) : (i.pushByte(128 + 55 + n), n === 1 ? i.pushUint8(t.length) : n === 2 ? i.pushUint16(t.length) : n === 3 ? i.pushUint24(t.length) : i.pushUint32(t.length), i.pushBytes(t));
    }
  };
}
function fu(e) {
  if (e < 2 ** 8)
    return 1;
  if (e < 2 ** 16)
    return 2;
  if (e < 2 ** 24)
    return 3;
  if (e < 2 ** 32)
    return 4;
  throw new it("Length is too large.");
}
const cl = {
  gwei: 9,
  wei: 18
}, fl = {
  ether: -9,
  wei: 9
};
function lu(e, t) {
  let n = e.toString();
  const r = n.startsWith("-");
  r && (n = n.slice(1)), n = n.padStart(t, "0");
  let [i, s] = [
    n.slice(0, n.length - t),
    n.slice(n.length - t)
  ];
  return s = s.replace(/(0+)$/, ""), `${r ? "-" : ""}${i || "0"}${s ? `.${s}` : ""}`;
}
function hu(e, t = "wei") {
  return lu(e, cl[t]);
}
function He(e, t = "wei") {
  return lu(e, fl[t]);
}
function io(e) {
  const t = Object.entries(e).map(([r, i]) => i === void 0 || i === !1 ? null : [r, i]).filter(Boolean), n = t.reduce((r, [i]) => Math.max(r, i.length), 0);
  return t.map(([r, i]) => `  ${`${r}:`.padEnd(n + 1)}  ${i}`).join(`
`);
}
class ll extends it {
  constructor() {
    super([
      "Cannot specify both a `gasPrice` and a `maxFeePerGas`/`maxPriorityFeePerGas`.",
      "Use `maxFeePerGas`/`maxPriorityFeePerGas` for EIP-1559 compatible networks, and `gasPrice` for others."
    ].join(`
`), { name: "FeeConflictError" });
  }
}
class hl extends it {
  constructor({ v: t }) {
    super(`Invalid \`v\` value "${t}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
}
class dl extends it {
  constructor({ transaction: t }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        io(t),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
}
class pl extends it {
  constructor({ storageKey: t }) {
    super(`Size for storage key "${t}" is invalid. Expected 32 bytes. Got ${Math.floor((t.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
}
function so(e) {
  const { kzg: t } = e, n = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"), r = typeof e.blobs[0] == "string" ? e.blobs.map((s) => En(s)) : e.blobs, i = [];
  for (const s of r)
    i.push(Uint8Array.from(t.blobToKzgCommitment(s)));
  return n === "bytes" ? i : i.map((s) => hn(s));
}
function oo(e) {
  const { kzg: t } = e, n = e.to ?? (typeof e.blobs[0] == "string" ? "hex" : "bytes"), r = typeof e.blobs[0] == "string" ? e.blobs.map((o) => En(o)) : e.blobs, i = typeof e.commitments[0] == "string" ? e.commitments.map((o) => En(o)) : e.commitments, s = [];
  for (let o = 0; o < r.length; o++) {
    const u = r[o], d = i[o];
    s.push(Uint8Array.from(t.computeBlobKzgProof(u, d)));
  }
  return n === "bytes" ? s : s.map((o) => hn(o));
}
function si(e) {
  if (!Number.isSafeInteger(e) || e < 0)
    throw new Error(`positive integer expected, not ${e}`);
}
function yl(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function _r(e, ...t) {
  if (!yl(e))
    throw new Error("Uint8Array expected");
  if (t.length > 0 && !t.includes(e.length))
    throw new Error(`Uint8Array expected of length ${t}, not of length=${e.length}`);
}
function ml(e) {
  if (typeof e != "function" || typeof e.create != "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  si(e.outputLen), si(e.blockLen);
}
function sr(e, t = !0) {
  if (e.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t && e.finished)
    throw new Error("Hash#digest() has already been called");
}
function du(e, t) {
  _r(e);
  const n = t.outputLen;
  if (e.length < n)
    throw new Error(`digestInto() expects output buffer of length at least ${n}`);
}
const qn = typeof globalThis == "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const wl = (e) => new Uint32Array(e.buffer, e.byteOffset, Math.floor(e.byteLength / 4)), os = (e) => new DataView(e.buffer, e.byteOffset, e.byteLength), qe = (e, t) => e << 32 - t | e >>> t, ra = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68, gl = (e) => e << 24 & 4278190080 | e << 8 & 16711680 | e >>> 8 & 65280 | e >>> 24 & 255;
function ia(e) {
  for (let t = 0; t < e.length; t++)
    e[t] = gl(e[t]);
}
function bl(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
function vi(e) {
  return typeof e == "string" && (e = bl(e)), _r(e), e;
}
function Al(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    _r(i), t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), i += s.length;
  }
  return n;
}
class ao {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
}
function uo(e) {
  const t = (r) => e().update(vi(r)).digest(), n = e();
  return t.outputLen = n.outputLen, t.blockLen = n.blockLen, t.create = () => e(), t;
}
function pu(e = 32) {
  if (qn && typeof qn.getRandomValues == "function")
    return qn.getRandomValues(new Uint8Array(e));
  if (qn && typeof qn.randomBytes == "function")
    return qn.randomBytes(e);
  throw new Error("crypto.getRandomValues must be defined");
}
function xl(e, t, n, r) {
  if (typeof e.setBigUint64 == "function")
    return e.setBigUint64(t, n, r);
  const i = BigInt(32), s = BigInt(4294967295), o = Number(n >> i & s), u = Number(n & s), d = r ? 4 : 0, w = r ? 0 : 4;
  e.setUint32(t + d, o, r), e.setUint32(t + w, u, r);
}
const El = (e, t, n) => e & t ^ ~e & n, vl = (e, t, n) => e & t ^ e & n ^ t & n;
class yu extends ao {
  constructor(t, n, r, i) {
    super(), this.blockLen = t, this.outputLen = n, this.padOffset = r, this.isLE = i, this.finished = !1, this.length = 0, this.pos = 0, this.destroyed = !1, this.buffer = new Uint8Array(t), this.view = os(this.buffer);
  }
  update(t) {
    sr(this);
    const { view: n, buffer: r, blockLen: i } = this;
    t = vi(t);
    const s = t.length;
    for (let o = 0; o < s; ) {
      const u = Math.min(i - this.pos, s - o);
      if (u === i) {
        const d = os(t);
        for (; i <= s - o; o += i)
          this.process(d, o);
        continue;
      }
      r.set(t.subarray(o, o + u), this.pos), this.pos += u, o += u, this.pos === i && (this.process(n, 0), this.pos = 0);
    }
    return this.length += t.length, this.roundClean(), this;
  }
  digestInto(t) {
    sr(this), du(t, this), this.finished = !0;
    const { buffer: n, view: r, blockLen: i, isLE: s } = this;
    let { pos: o } = this;
    n[o++] = 128, this.buffer.subarray(o).fill(0), this.padOffset > i - o && (this.process(r, 0), o = 0);
    for (let v = o; v < i; v++)
      n[v] = 0;
    xl(r, i - 8, BigInt(this.length * 8), s), this.process(r, 0);
    const u = os(t), d = this.outputLen;
    if (d % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const w = d / 4, g = this.get();
    if (w > g.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let v = 0; v < w; v++)
      u.setUint32(4 * v, g[v], s);
  }
  digest() {
    const { buffer: t, outputLen: n } = this;
    this.digestInto(t);
    const r = t.slice(0, n);
    return this.destroy(), r;
  }
  _cloneInto(t) {
    t || (t = new this.constructor()), t.set(...this.get());
    const { blockLen: n, buffer: r, length: i, finished: s, destroyed: o, pos: u } = this;
    return t.length = i, t.pos = u, t.finished = s, t.destroyed = o, i % n && t.buffer.set(r), t;
  }
}
const Bl = /* @__PURE__ */ new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]), dn = /* @__PURE__ */ new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]), pn = /* @__PURE__ */ new Uint32Array(64);
class Il extends yu {
  constructor() {
    super(64, 32, 8, !1), this.A = dn[0] | 0, this.B = dn[1] | 0, this.C = dn[2] | 0, this.D = dn[3] | 0, this.E = dn[4] | 0, this.F = dn[5] | 0, this.G = dn[6] | 0, this.H = dn[7] | 0;
  }
  get() {
    const { A: t, B: n, C: r, D: i, E: s, F: o, G: u, H: d } = this;
    return [t, n, r, i, s, o, u, d];
  }
  // prettier-ignore
  set(t, n, r, i, s, o, u, d) {
    this.A = t | 0, this.B = n | 0, this.C = r | 0, this.D = i | 0, this.E = s | 0, this.F = o | 0, this.G = u | 0, this.H = d | 0;
  }
  process(t, n) {
    for (let v = 0; v < 16; v++, n += 4)
      pn[v] = t.getUint32(n, !1);
    for (let v = 16; v < 64; v++) {
      const I = pn[v - 15], S = pn[v - 2], D = qe(I, 7) ^ qe(I, 18) ^ I >>> 3, N = qe(S, 17) ^ qe(S, 19) ^ S >>> 10;
      pn[v] = N + pn[v - 7] + D + pn[v - 16] | 0;
    }
    let { A: r, B: i, C: s, D: o, E: u, F: d, G: w, H: g } = this;
    for (let v = 0; v < 64; v++) {
      const I = qe(u, 6) ^ qe(u, 11) ^ qe(u, 25), S = g + I + El(u, d, w) + Bl[v] + pn[v] | 0, N = (qe(r, 2) ^ qe(r, 13) ^ qe(r, 22)) + vl(r, i, s) | 0;
      g = w, w = d, d = u, u = o + S | 0, o = s, s = i, i = r, r = S + N | 0;
    }
    r = r + this.A | 0, i = i + this.B | 0, s = s + this.C | 0, o = o + this.D | 0, u = u + this.E | 0, d = d + this.F | 0, w = w + this.G | 0, g = g + this.H | 0, this.set(r, i, s, o, u, d, w, g);
  }
  roundClean() {
    pn.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
}
const oi = /* @__PURE__ */ uo(() => new Il());
function Ml(e, t) {
  const n = t || "hex", r = oi(Rn(e, { strict: !1 }) ? ru(e) : e);
  return n === "bytes" ? r : lt(r);
}
function Tl(e) {
  const { commitment: t, version: n = 1 } = e, r = e.to ?? (typeof t == "string" ? "hex" : "bytes"), i = Ml(t, "bytes");
  return i.set([n], 0), r === "bytes" ? i : hn(i);
}
function mu(e) {
  const { commitments: t, version: n } = e, r = e.to ?? (typeof t[0] == "string" ? "hex" : "bytes"), i = [];
  for (const s of t)
    i.push(Tl({
      commitment: s,
      to: r,
      version: n
    }));
  return i;
}
const sa = 6, wu = 32, co = 4096, gu = wu * co, oa = gu * sa - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * co * sa, bu = 1;
class Cl extends it {
  constructor({ maxSize: t, size: n }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${t} bytes`, `Given: ${n} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
}
class Au extends it {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
}
class Sl extends it {
  constructor({ hash: t, size: n }) {
    super(`Versioned hash "${t}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${n}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
}
class Ul extends it {
  constructor({ hash: t, version: n }) {
    super(`Versioned hash "${t}" version is invalid.`, {
      metaMessages: [
        `Expected: ${bu}`,
        `Received: ${n}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
}
function Fl(e) {
  const t = e.to ?? (typeof e.data == "string" ? "hex" : "bytes"), n = typeof e.data == "string" ? En(e.data) : e.data, r = xn(n);
  if (!r)
    throw new Au();
  if (r > oa)
    throw new Cl({
      maxSize: oa,
      size: r
    });
  const i = [];
  let s = !0, o = 0;
  for (; s; ) {
    const u = uu(new Uint8Array(gu));
    let d = 0;
    for (; d < co; ) {
      const w = n.slice(o, o + (wu - 1));
      if (u.pushByte(0), u.pushBytes(w), w.length < 31) {
        u.pushByte(128), s = !1;
        break;
      }
      d++, o += 31;
    }
    i.push(u);
  }
  return t === "bytes" ? i.map((u) => u.bytes) : i.map((u) => hn(u.bytes));
}
function xu(e) {
  const { data: t, kzg: n, to: r } = e, i = e.blobs ?? Fl({ data: t, to: r }), s = e.commitments ?? so({ blobs: i, kzg: n, to: r }), o = e.proofs ?? oo({ blobs: i, commitments: s, kzg: n, to: r }), u = [];
  for (let d = 0; d < i.length; d++)
    u.push({
      blob: i[d],
      commitment: s[d],
      proof: o[d]
    });
  return u;
}
function kl(e) {
  if (!e || e.length === 0)
    return [];
  const t = [];
  for (const n of e) {
    const { contractAddress: r, chainId: i, nonce: s, ...o } = n;
    t.push([
      i ? lt(i) : "0x",
      r,
      s ? lt(s) : "0x",
      ...Gr({}, o)
    ]);
  }
  return t;
}
class Ze extends it {
  constructor({ address: t }) {
    super(`Address "${t}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
}
class Bi extends it {
  constructor({ chainId: t }) {
    super(typeof t == "number" ? `Chain ID "${t}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
}
class $n extends it {
  constructor({ cause: t, message: n } = {}) {
    var i;
    const r = (i = n == null ? void 0 : n.replace("execution reverted: ", "")) == null ? void 0 : i.replace("execution reverted", "");
    super(`Execution reverted ${r ? `with reason: ${r}` : "for an unknown reason"}.`, {
      cause: t,
      name: "ExecutionRevertedError"
    });
  }
}
Object.defineProperty($n, "code", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: 3
});
Object.defineProperty($n, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /execution reverted/
});
class Dn extends it {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${He(n)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: t,
      name: "FeeCapTooHighError"
    });
  }
}
Object.defineProperty(Dn, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
class Fs extends it {
  constructor({ cause: t, maxFeePerGas: n } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${n ? ` = ${He(n)}` : ""} gwei) cannot be lower than the block base fee.`, {
      cause: t,
      name: "FeeCapTooLowError"
    });
  }
}
Object.defineProperty(Fs, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max fee per gas less than block base fee|fee cap less than block base fee|transaction is outdated/
});
class ks extends it {
  constructor({ cause: t, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}is higher than the next one expected.`, { cause: t, name: "NonceTooHighError" });
  }
}
Object.defineProperty(ks, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too high/
});
class Ns extends it {
  constructor({ cause: t, nonce: n } = {}) {
    super([
      `Nonce provided for the transaction ${n ? `(${n}) ` : ""}is lower than the current nonce of the account.`,
      "Try increasing the nonce or find the latest nonce with `getTransactionCount`."
    ].join(`
`), { cause: t, name: "NonceTooLowError" });
  }
}
Object.defineProperty(Ns, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce too low|transaction already imported|already known/
});
class Rs extends it {
  constructor({ cause: t, nonce: n } = {}) {
    super(`Nonce provided for the transaction ${n ? `(${n}) ` : ""}exceeds the maximum allowed nonce.`, { cause: t, name: "NonceMaxValueError" });
  }
}
Object.defineProperty(Rs, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /nonce has max value/
});
class Ps extends it {
  constructor({ cause: t } = {}) {
    super([
      "The total cost (gas * gas fee + value) of executing this transaction exceeds the balance of the account."
    ].join(`
`), {
      cause: t,
      metaMessages: [
        "This error could arise when the account does not have enough funds to:",
        " - pay for the total gas fee,",
        " - pay for the value to send.",
        " ",
        "The cost of the transaction is calculated as `gas * gas fee + value`, where:",
        " - `gas` is the amount of gas needed for transaction to execute,",
        " - `gas fee` is the gas fee,",
        " - `value` is the amount of ether to send to the recipient."
      ],
      name: "InsufficientFundsError"
    });
  }
}
Object.defineProperty(Ps, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /insufficient funds|exceeds transaction sender account balance/
});
class Ds extends it {
  constructor({ cause: t, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction exceeds the limit allowed for the block.`, {
      cause: t,
      name: "IntrinsicGasTooHighError"
    });
  }
}
Object.defineProperty(Ds, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too high|gas limit reached/
});
class Os extends it {
  constructor({ cause: t, gas: n } = {}) {
    super(`The amount of gas ${n ? `(${n}) ` : ""}provided for the transaction is too low.`, {
      cause: t,
      name: "IntrinsicGasTooLowError"
    });
  }
}
Object.defineProperty(Os, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /intrinsic gas too low/
});
class Ls extends it {
  constructor({ cause: t }) {
    super("The transaction type is not supported for this chain.", {
      cause: t,
      name: "TransactionTypeNotSupportedError"
    });
  }
}
Object.defineProperty(Ls, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /transaction type not valid/
});
class Sr extends it {
  constructor({ cause: t, maxPriorityFeePerGas: n, maxFeePerGas: r } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${n ? ` = ${He(n)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${r ? ` = ${He(r)} gwei` : ""}).`
    ].join(`
`), {
      cause: t,
      name: "TipAboveFeeCapError"
    });
  }
}
Object.defineProperty(Sr, "nodeMessage", {
  enumerable: !0,
  configurable: !0,
  writable: !0,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
class fo extends it {
  constructor({ cause: t }) {
    super(`An error occurred while executing: ${t == null ? void 0 : t.shortMessage}`, {
      cause: t,
      name: "UnknownNodeError"
    });
  }
}
class Eu extends Map {
  constructor(t) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.maxSize = t;
  }
  get(t) {
    const n = super.get(t);
    return super.has(t) && n !== void 0 && (this.delete(t), super.set(t, n)), n;
  }
  set(t, n) {
    if (super.set(t, n), this.maxSize && this.size > this.maxSize) {
      const r = this.keys().next().value;
      r && this.delete(r);
    }
    return this;
  }
}
const jr = /* @__PURE__ */ BigInt(2 ** 32 - 1), _s = /* @__PURE__ */ BigInt(32);
function vu(e, t = !1) {
  return t ? { h: Number(e & jr), l: Number(e >> _s & jr) } : { h: Number(e >> _s & jr) | 0, l: Number(e & jr) | 0 };
}
function Bu(e, t = !1) {
  let n = new Uint32Array(e.length), r = new Uint32Array(e.length);
  for (let i = 0; i < e.length; i++) {
    const { h: s, l: o } = vu(e[i], t);
    [n[i], r[i]] = [s, o];
  }
  return [n, r];
}
const Nl = (e, t) => BigInt(e >>> 0) << _s | BigInt(t >>> 0), Rl = (e, t, n) => e >>> n, Pl = (e, t, n) => e << 32 - n | t >>> n, Dl = (e, t, n) => e >>> n | t << 32 - n, Ol = (e, t, n) => e << 32 - n | t >>> n, Ll = (e, t, n) => e << 64 - n | t >>> n - 32, _l = (e, t, n) => e >>> n - 32 | t << 64 - n, Gl = (e, t) => t, zl = (e, t) => e, Iu = (e, t, n) => e << n | t >>> 32 - n, Mu = (e, t, n) => t << n | e >>> 32 - n, Tu = (e, t, n) => t << n - 32 | e >>> 64 - n, Cu = (e, t, n) => e << n - 32 | t >>> 64 - n;
function Hl(e, t, n, r) {
  const i = (t >>> 0) + (r >>> 0);
  return { h: e + n + (i / 2 ** 32 | 0) | 0, l: i | 0 };
}
const Vl = (e, t, n) => (e >>> 0) + (t >>> 0) + (n >>> 0), Ql = (e, t, n, r) => t + n + r + (e / 2 ** 32 | 0) | 0, Kl = (e, t, n, r) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0), ql = (e, t, n, r, i) => t + n + r + i + (e / 2 ** 32 | 0) | 0, jl = (e, t, n, r, i) => (e >>> 0) + (t >>> 0) + (n >>> 0) + (r >>> 0) + (i >>> 0), Yl = (e, t, n, r, i, s) => t + n + r + i + s + (e / 2 ** 32 | 0) | 0, Zl = {
  fromBig: vu,
  split: Bu,
  toBig: Nl,
  shrSH: Rl,
  shrSL: Pl,
  rotrSH: Dl,
  rotrSL: Ol,
  rotrBH: Ll,
  rotrBL: _l,
  rotr32H: Gl,
  rotr32L: zl,
  rotlSH: Iu,
  rotlSL: Mu,
  rotlBH: Tu,
  rotlBL: Cu,
  add: Hl,
  add3L: Vl,
  add3H: Ql,
  add4L: Kl,
  add4H: ql,
  add5H: Yl,
  add5L: jl
}, dt = Zl, Su = [], Uu = [], Fu = [], Jl = /* @__PURE__ */ BigInt(0), Er = /* @__PURE__ */ BigInt(1), Xl = /* @__PURE__ */ BigInt(2), Wl = /* @__PURE__ */ BigInt(7), $l = /* @__PURE__ */ BigInt(256), th = /* @__PURE__ */ BigInt(113);
for (let e = 0, t = Er, n = 1, r = 0; e < 24; e++) {
  [n, r] = [r, (2 * n + 3 * r) % 5], Su.push(2 * (5 * r + n)), Uu.push((e + 1) * (e + 2) / 2 % 64);
  let i = Jl;
  for (let s = 0; s < 7; s++)
    t = (t << Er ^ (t >> Wl) * th) % $l, t & Xl && (i ^= Er << (Er << /* @__PURE__ */ BigInt(s)) - Er);
  Fu.push(i);
}
const [eh, nh] = /* @__PURE__ */ Bu(Fu, !0), aa = (e, t, n) => n > 32 ? Tu(e, t, n) : Iu(e, t, n), ua = (e, t, n) => n > 32 ? Cu(e, t, n) : Mu(e, t, n);
function rh(e, t = 24) {
  const n = new Uint32Array(10);
  for (let r = 24 - t; r < 24; r++) {
    for (let o = 0; o < 10; o++)
      n[o] = e[o] ^ e[o + 10] ^ e[o + 20] ^ e[o + 30] ^ e[o + 40];
    for (let o = 0; o < 10; o += 2) {
      const u = (o + 8) % 10, d = (o + 2) % 10, w = n[d], g = n[d + 1], v = aa(w, g, 1) ^ n[u], I = ua(w, g, 1) ^ n[u + 1];
      for (let S = 0; S < 50; S += 10)
        e[o + S] ^= v, e[o + S + 1] ^= I;
    }
    let i = e[2], s = e[3];
    for (let o = 0; o < 24; o++) {
      const u = Uu[o], d = aa(i, s, u), w = ua(i, s, u), g = Su[o];
      i = e[g], s = e[g + 1], e[g] = d, e[g + 1] = w;
    }
    for (let o = 0; o < 50; o += 10) {
      for (let u = 0; u < 10; u++)
        n[u] = e[o + u];
      for (let u = 0; u < 10; u++)
        e[o + u] ^= ~n[(u + 2) % 10] & n[(u + 4) % 10];
    }
    e[0] ^= eh[r], e[1] ^= nh[r];
  }
  n.fill(0);
}
class lo extends ao {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t, n, r, i = !1, s = 24) {
    if (super(), this.blockLen = t, this.suffix = n, this.outputLen = r, this.enableXOF = i, this.rounds = s, this.pos = 0, this.posOut = 0, this.finished = !1, this.destroyed = !1, si(r), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = wl(this.state);
  }
  keccak() {
    ra || ia(this.state32), rh(this.state32, this.rounds), ra || ia(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t) {
    sr(this);
    const { blockLen: n, state: r } = this;
    t = vi(t);
    const i = t.length;
    for (let s = 0; s < i; ) {
      const o = Math.min(n - this.pos, i - s);
      for (let u = 0; u < o; u++)
        r[this.pos++] ^= t[s++];
      this.pos === n && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = !0;
    const { state: t, suffix: n, pos: r, blockLen: i } = this;
    t[r] ^= n, n & 128 && r === i - 1 && this.keccak(), t[i - 1] ^= 128, this.keccak();
  }
  writeInto(t) {
    sr(this, !1), _r(t), this.finish();
    const n = this.state, { blockLen: r } = this;
    for (let i = 0, s = t.length; i < s; ) {
      this.posOut >= r && this.keccak();
      const o = Math.min(r - this.posOut, s - i);
      t.set(n.subarray(this.posOut, this.posOut + o), i), this.posOut += o, i += o;
    }
    return t;
  }
  xofInto(t) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t);
  }
  xof(t) {
    return si(t), this.xofInto(new Uint8Array(t));
  }
  digestInto(t) {
    if (du(t, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t), this.destroy(), t;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = !0, this.state.fill(0);
  }
  _cloneInto(t) {
    const { blockLen: n, suffix: r, outputLen: i, rounds: s, enableXOF: o } = this;
    return t || (t = new lo(n, r, i, o, s)), t.state32.set(this.state32), t.pos = this.pos, t.posOut = this.posOut, t.finished = this.finished, t.rounds = s, t.suffix = r, t.outputLen = i, t.enableXOF = o, t.destroyed = this.destroyed, t;
  }
}
const ih = (e, t, n) => uo(() => new lo(t, e, n)), sh = /* @__PURE__ */ ih(1, 136, 256 / 8);
function ho(e, t) {
  const n = t || "hex", r = sh(Rn(e, { strict: !1 }) ? ru(e) : e);
  return n === "bytes" ? r : lt(r);
}
const as = /* @__PURE__ */ new Eu(8192);
function ku(e, t) {
  if (as.has(`${e}.${t}`))
    return as.get(`${e}.${t}`);
  const n = t ? `${t}${e.toLowerCase()}` : e.substring(2).toLowerCase(), r = ho(iu(n), "bytes"), i = (t ? n.substring(`${t}0x`.length) : n).split("");
  for (let o = 0; o < 40; o += 2)
    r[o >> 1] >> 4 >= 8 && i[o] && (i[o] = i[o].toUpperCase()), (r[o >> 1] & 15) >= 8 && i[o + 1] && (i[o + 1] = i[o + 1].toUpperCase());
  const s = `0x${i.join("")}`;
  return as.set(`${e}.${t}`, s), s;
}
const oh = /^0x[a-fA-F0-9]{40}$/, us = /* @__PURE__ */ new Eu(8192);
function Je(e, t) {
  const { strict: n = !0 } = t ?? {}, r = `${e}.${n}`;
  if (us.has(r))
    return us.get(r);
  const i = (() => oh.test(e) ? e.toLowerCase() === e ? !0 : n ? ku(e) === e : !0 : !1)();
  return us.set(r, i), i;
}
function ah(e, t, n, { strict: r } = {}) {
  return Rn(e, { strict: !1 }) ? ch(e, t, n, {
    strict: r
  }) : uh(e, t, n, {
    strict: r
  });
}
function Nu(e, t) {
  if (typeof t == "number" && t > 0 && t > xn(e) - 1)
    throw new eu({
      offset: t,
      position: "start",
      size: xn(e)
    });
}
function Ru(e, t, n) {
  if (typeof t == "number" && typeof n == "number" && xn(e) !== n - t)
    throw new eu({
      offset: n,
      position: "end",
      size: xn(e)
    });
}
function uh(e, t, n, { strict: r } = {}) {
  Nu(e, t);
  const i = e.slice(t, n);
  return r && Ru(i, t, n), i;
}
function ch(e, t, n, { strict: r } = {}) {
  Nu(e, t);
  const i = `0x${e.replace("0x", "").slice((t ?? 0) * 2, (n ?? e.length) * 2)}`;
  return r && Ru(i, t, n), i;
}
function fh(e) {
  const { authorizationList: t } = e;
  if (t)
    for (const n of t) {
      const { contractAddress: r, chainId: i } = n;
      if (!Je(r))
        throw new Ze({ address: r });
      if (i < 0)
        throw new Bi({ chainId: i });
    }
  po(e);
}
function lh(e) {
  const { blobVersionedHashes: t } = e;
  if (t) {
    if (t.length === 0)
      throw new Au();
    for (const n of t) {
      const r = xn(n), i = Pn(ah(n, 0, 1));
      if (r !== 32)
        throw new Sl({ hash: n, size: r });
      if (i !== bu)
        throw new Ul({
          hash: n,
          version: i
        });
    }
  }
  po(e);
}
function po(e) {
  const { chainId: t, maxPriorityFeePerGas: n, maxFeePerGas: r, to: i } = e;
  if (t <= 0)
    throw new Bi({ chainId: t });
  if (i && !Je(i))
    throw new Ze({ address: i });
  if (r && r > Ei)
    throw new Dn({ maxFeePerGas: r });
  if (n && r && n > r)
    throw new Sr({ maxFeePerGas: r, maxPriorityFeePerGas: n });
}
function hh(e) {
  const { chainId: t, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: i, to: s } = e;
  if (t <= 0)
    throw new Bi({ chainId: t });
  if (s && !Je(s))
    throw new Ze({ address: s });
  if (n || i)
    throw new it("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (r && r > Ei)
    throw new Dn({ maxFeePerGas: r });
}
function dh(e) {
  const { chainId: t, maxPriorityFeePerGas: n, gasPrice: r, maxFeePerGas: i, to: s } = e;
  if (s && !Je(s))
    throw new Ze({ address: s });
  if (typeof t < "u" && t <= 0)
    throw new Bi({ chainId: t });
  if (n || i)
    throw new it("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (r && r > Ei)
    throw new Dn({ maxFeePerGas: r });
}
function Pu(e) {
  if (e.type)
    return e.type;
  if (typeof e.authorizationList < "u")
    return "eip7702";
  if (typeof e.blobs < "u" || typeof e.blobVersionedHashes < "u" || typeof e.maxFeePerBlobGas < "u" || typeof e.sidecars < "u")
    return "eip4844";
  if (typeof e.maxFeePerGas < "u" || typeof e.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof e.gasPrice < "u")
    return typeof e.accessList < "u" ? "eip2930" : "legacy";
  throw new dl({ transaction: e });
}
function Ii(e) {
  if (!e || e.length === 0)
    return [];
  const t = [];
  for (let n = 0; n < e.length; n++) {
    const { address: r, storageKeys: i } = e[n];
    for (let s = 0; s < i.length; s++)
      if (i[s].length - 2 !== 64)
        throw new pl({ storageKey: i[s] });
    if (!Je(r, { strict: !1 }))
      throw new Ze({ address: r });
    t.push([r, i]);
  }
  return t;
}
function ph(e, t) {
  const n = Pu(e);
  return n === "eip1559" ? wh(e, t) : n === "eip2930" ? gh(e, t) : n === "eip4844" ? mh(e, t) : n === "eip7702" ? yh(e, t) : bh(e, t);
}
function yh(e, t) {
  const { authorizationList: n, chainId: r, gas: i, nonce: s, to: o, value: u, maxFeePerGas: d, maxPriorityFeePerGas: w, accessList: g, data: v } = e;
  fh(e);
  const I = Ii(g), S = kl(n);
  return mr([
    "0x04",
    vn([
      lt(r),
      s ? lt(s) : "0x",
      w ? lt(w) : "0x",
      d ? lt(d) : "0x",
      i ? lt(i) : "0x",
      o ?? "0x",
      u ? lt(u) : "0x",
      v ?? "0x",
      I,
      S,
      ...Gr(e, t)
    ])
  ]);
}
function mh(e, t) {
  const { chainId: n, gas: r, nonce: i, to: s, value: o, maxFeePerBlobGas: u, maxFeePerGas: d, maxPriorityFeePerGas: w, accessList: g, data: v } = e;
  lh(e);
  let I = e.blobVersionedHashes, S = e.sidecars;
  if (e.blobs && (typeof I > "u" || typeof S > "u")) {
    const k = typeof e.blobs[0] == "string" ? e.blobs : e.blobs.map((z) => hn(z)), V = e.kzg, H = so({
      blobs: k,
      kzg: V
    });
    if (typeof I > "u" && (I = mu({
      commitments: H
    })), typeof S > "u") {
      const z = oo({ blobs: k, commitments: H, kzg: V });
      S = xu({ blobs: k, commitments: H, proofs: z });
    }
  }
  const D = Ii(g), N = [
    lt(n),
    i ? lt(i) : "0x",
    w ? lt(w) : "0x",
    d ? lt(d) : "0x",
    r ? lt(r) : "0x",
    s ?? "0x",
    o ? lt(o) : "0x",
    v ?? "0x",
    D,
    u ? lt(u) : "0x",
    I ?? [],
    ...Gr(e, t)
  ], T = [], O = [], _ = [];
  if (S)
    for (let k = 0; k < S.length; k++) {
      const { blob: V, commitment: H, proof: z } = S[k];
      T.push(V), O.push(H), _.push(z);
    }
  return mr([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    vn(S ? [N, T, O, _] : N)
  ]);
}
function wh(e, t) {
  const { chainId: n, gas: r, nonce: i, to: s, value: o, maxFeePerGas: u, maxPriorityFeePerGas: d, accessList: w, data: g } = e;
  po(e);
  const v = Ii(w), I = [
    lt(n),
    i ? lt(i) : "0x",
    d ? lt(d) : "0x",
    u ? lt(u) : "0x",
    r ? lt(r) : "0x",
    s ?? "0x",
    o ? lt(o) : "0x",
    g ?? "0x",
    v,
    ...Gr(e, t)
  ];
  return mr([
    "0x02",
    vn(I)
  ]);
}
function gh(e, t) {
  const { chainId: n, gas: r, data: i, nonce: s, to: o, value: u, accessList: d, gasPrice: w } = e;
  hh(e);
  const g = Ii(d), v = [
    lt(n),
    s ? lt(s) : "0x",
    w ? lt(w) : "0x",
    r ? lt(r) : "0x",
    o ?? "0x",
    u ? lt(u) : "0x",
    i ?? "0x",
    g,
    ...Gr(e, t)
  ];
  return mr([
    "0x01",
    vn(v)
  ]);
}
function bh(e, t) {
  const { chainId: n = 0, gas: r, data: i, nonce: s, to: o, value: u, gasPrice: d } = e;
  dh(e);
  let w = [
    s ? lt(s) : "0x",
    d ? lt(d) : "0x",
    r ? lt(r) : "0x",
    o ?? "0x",
    u ? lt(u) : "0x",
    i ?? "0x"
  ];
  if (t) {
    const g = (() => {
      if (t.v >= 35n)
        return (t.v - 35n) / 2n > 0 ? t.v : 27n + (t.v === 35n ? 0n : 1n);
      if (n > 0)
        return BigInt(n * 2) + BigInt(35n + t.v - 27n);
      const S = 27n + (t.v === 27n ? 0n : 1n);
      if (t.v !== S)
        throw new hl({ v: t.v });
      return S;
    })(), v = ii(t.r), I = ii(t.s);
    w = [
      ...w,
      lt(g),
      v === "0x00" ? "0x" : v,
      I === "0x00" ? "0x" : I
    ];
  } else
    n > 0 && (w = [
      ...w,
      lt(n),
      "0x",
      "0x"
    ]);
  return vn(w);
}
function Gr(e, t) {
  const n = t ?? e, { v: r, yParity: i } = n;
  if (typeof n.r > "u")
    return [];
  if (typeof n.s > "u")
    return [];
  if (typeof r > "u" && typeof i > "u")
    return [];
  const s = ii(n.r), o = ii(n.s);
  return [(() => typeof i == "number" ? i ? lt(1) : "0x" : r === 0n ? "0x" : r === 1n ? lt(1) : r === 27n ? "0x" : lt(1))(), s === "0x00" ? "0x" : s, o === "0x00" ? "0x" : o];
}
const Ah = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
}, xh = {
  block: /* @__PURE__ */ Xf({
    format(e) {
      var n;
      return {
        transactions: (n = e.transactions) == null ? void 0 : n.map((r) => {
          if (typeof r == "string")
            return r;
          const i = ro(r);
          return i.typeHex === "0x7e" && (i.isSystemTx = r.isSystemTx, i.mint = r.mint ? on(r.mint) : void 0, i.sourceHash = r.sourceHash, i.type = "deposit"), i;
        }),
        stateRoot: e.stateRoot
      };
    }
  }),
  transaction: /* @__PURE__ */ Zf({
    format(e) {
      const t = {};
      return e.type === "0x7e" && (t.isSystemTx = e.isSystemTx, t.mint = e.mint ? on(e.mint) : void 0, t.sourceHash = e.sourceHash, t.type = "deposit"), t;
    }
  }),
  transactionReceipt: /* @__PURE__ */ el({
    format(e) {
      return {
        l1GasPrice: e.l1GasPrice ? on(e.l1GasPrice) : null,
        l1GasUsed: e.l1GasUsed ? on(e.l1GasUsed) : null,
        l1Fee: e.l1Fee ? on(e.l1Fee) : null,
        l1FeeScalar: e.l1FeeScalar ? Number(e.l1FeeScalar) : null
      };
    }
  })
};
function Eh(e, t) {
  return Ih(e) ? Bh(e) : ph(e, t);
}
const vh = {
  transaction: Eh
};
function Bh(e) {
  Mh(e);
  const { sourceHash: t, data: n, from: r, gas: i, isSystemTx: s, mint: o, to: u, value: d } = e, w = [
    t,
    r,
    u ?? "0x",
    o ? lt(o) : "0x",
    d ? lt(d) : "0x",
    i ? lt(i) : "0x",
    s ? "0x1" : "0x",
    n ?? "0x"
  ];
  return mr([
    "0x7e",
    vn(w)
  ]);
}
function Ih(e) {
  return e.type === "deposit" || typeof e.sourceHash < "u";
}
function Mh(e) {
  const { from: t, to: n } = e;
  if (t && !Je(t))
    throw new Ze({ address: t });
  if (n && !Je(n))
    throw new Ze({ address: n });
}
const Se = {
  contracts: Ah,
  formatters: xh,
  serializers: vh
}, Th = /* @__PURE__ */ ve({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
}), Yr = 1, Ch = /* @__PURE__ */ ve({
  ...Se,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...Se.contracts,
    l2OutputOracle: {
      [Yr]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [Yr]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [Yr]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: Yr
}), Zr = 5, Sh = /* @__PURE__ */ ve({
  ...Se,
  id: 84531,
  name: "Base Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://goerli.base.org"] }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org",
      apiUrl: "https://goerli.basescan.org/api"
    }
  },
  contracts: {
    ...Se.contracts,
    l2OutputOracle: {
      [Zr]: {
        address: "0x2A35891ff30313CcFa6CE88dcf3858bb075A2298"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1376988
    },
    portal: {
      [Zr]: {
        address: "0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA"
      }
    },
    l1StandardBridge: {
      [Zr]: {
        address: "0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a"
      }
    }
  },
  testnet: !0,
  sourceId: Zr
}), vr = 11155111, Uh = /* @__PURE__ */ ve({
  ...Se,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...Se.contracts,
    disputeGameFactory: {
      [vr]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [vr]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [vr]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [vr]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: !0,
  sourceId: vr
}), Fh = /* @__PURE__ */ ve({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/eth_goerli"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: !0
}), kh = /* @__PURE__ */ ve({
  id: 100,
  name: "Gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io",
      apiUrl: "https://api.gnosisscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
});
function zr(e) {
  return typeof e == "string" ? { address: e, type: "json-rpc" } : e;
}
class Nh extends it {
  constructor() {
    super("`baseFeeMultiplier` must be greater than 1.", {
      name: "BaseFeeScalarError"
    });
  }
}
class yo extends it {
  constructor() {
    super("Chain does not support EIP-1559 fees.", {
      name: "Eip1559FeesNotSupportedError"
    });
  }
}
class Rh extends it {
  constructor({ maxPriorityFeePerGas: t }) {
    super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${He(t)} gwei).`, { name: "MaxFeePerGasTooLowError" });
  }
}
function cn(e, t, n) {
  const r = e[t.name];
  if (typeof r == "function")
    return r;
  const i = e[n];
  return typeof i == "function" ? i : (s) => t(e, s);
}
class Ph extends it {
  constructor({ blockHash: t, blockNumber: n }) {
    let r = "Block";
    t && (r = `Block at hash "${t}"`), n && (r = `Block at number "${n}"`), super(`${r} could not be found.`, { name: "BlockNotFoundError" });
  }
}
async function ai(e, { blockHash: t, blockNumber: n, blockTag: r, includeTransactions: i } = {}) {
  var g, v, I;
  const s = r ?? "latest", o = i ?? !1, u = n !== void 0 ? Lt(n) : void 0;
  let d = null;
  if (t ? d = await e.request({
    method: "eth_getBlockByHash",
    params: [t, o]
  }, { dedupe: !0 }) : d = await e.request({
    method: "eth_getBlockByNumber",
    params: [u || s, o]
  }, { dedupe: !!u }), !d)
    throw new Ph({ blockHash: t, blockNumber: n });
  return (((I = (v = (g = e.chain) == null ? void 0 : g.formatters) == null ? void 0 : v.block) == null ? void 0 : I.format) || ou)(d);
}
async function Du(e) {
  const t = await e.request({
    method: "eth_gasPrice"
  });
  return BigInt(t);
}
async function Dh(e, t) {
  var s, o;
  const { block: n, chain: r = e.chain, request: i } = t || {};
  try {
    const u = ((s = r == null ? void 0 : r.fees) == null ? void 0 : s.maxPriorityFeePerGas) ?? ((o = r == null ? void 0 : r.fees) == null ? void 0 : o.defaultPriorityFee);
    if (typeof u == "function") {
      const w = n || await cn(e, ai, "getBlock")({}), g = await u({
        block: w,
        client: e,
        request: i
      });
      if (g === null)
        throw new Error();
      return g;
    }
    if (typeof u < "u")
      return u;
    const d = await e.request({
      method: "eth_maxPriorityFeePerGas"
    });
    return on(d);
  } catch {
    const [u, d] = await Promise.all([
      n ? Promise.resolve(n) : cn(e, ai, "getBlock")({}),
      cn(e, Du, "getGasPrice")({})
    ]);
    if (typeof u.baseFeePerGas != "bigint")
      throw new yo();
    const w = d - u.baseFeePerGas;
    return w < 0n ? 0n : w;
  }
}
async function ca(e, t) {
  var I, S;
  const { block: n, chain: r = e.chain, request: i, type: s = "eip1559" } = t || {}, o = await (async () => {
    var D, N;
    return typeof ((D = r == null ? void 0 : r.fees) == null ? void 0 : D.baseFeeMultiplier) == "function" ? r.fees.baseFeeMultiplier({
      block: n,
      client: e,
      request: i
    }) : ((N = r == null ? void 0 : r.fees) == null ? void 0 : N.baseFeeMultiplier) ?? 1.2;
  })();
  if (o < 1)
    throw new Nh();
  const d = 10 ** (((I = o.toString().split(".")[1]) == null ? void 0 : I.length) ?? 0), w = (D) => D * BigInt(Math.ceil(o * d)) / BigInt(d), g = n || await cn(e, ai, "getBlock")({});
  if (typeof ((S = r == null ? void 0 : r.fees) == null ? void 0 : S.estimateFeesPerGas) == "function") {
    const D = await r.fees.estimateFeesPerGas({
      block: n,
      client: e,
      multiply: w,
      request: i,
      type: s
    });
    if (D !== null)
      return D;
  }
  if (s === "eip1559") {
    if (typeof g.baseFeePerGas != "bigint")
      throw new yo();
    const D = typeof (i == null ? void 0 : i.maxPriorityFeePerGas) == "bigint" ? i.maxPriorityFeePerGas : await Dh(e, {
      block: g,
      chain: r,
      request: i
    }), N = w(g.baseFeePerGas);
    return {
      maxFeePerGas: (i == null ? void 0 : i.maxFeePerGas) ?? N + D,
      maxPriorityFeePerGas: D
    };
  }
  return {
    gasPrice: (i == null ? void 0 : i.gasPrice) ?? w(await cn(e, Du, "getGasPrice")({}))
  };
}
function Oh(e) {
  const t = ho(`0x${e.substring(4)}`).substring(26);
  return ku(`0x${t}`);
}
async function Lh({ hash: e, signature: t }) {
  const n = Rn(e) ? e : lt(e), { secp256k1: r } = await Promise.resolve().then(() => qy);
  return `0x${(() => {
    if (typeof t == "object" && "r" in t && "s" in t) {
      const { r: w, s: g, v, yParity: I } = t, S = Number(I ?? v), D = fa(S);
      return new r.Signature(on(w), on(g)).addRecoveryBit(D);
    }
    const o = Rn(t) ? t : lt(t), u = Pn(`0x${o.slice(130)}`), d = fa(u);
    return r.Signature.fromCompact(o.substring(2, 130)).addRecoveryBit(d);
  })().recoverPublicKey(n.substring(2)).toHex(!1)}`;
}
function fa(e) {
  if (e === 0 || e === 1)
    return e;
  if (e === 27)
    return 0;
  if (e === 28)
    return 1;
  throw new Error("Invalid yParityOrV value");
}
async function _h({ hash: e, signature: t }) {
  return Oh(await Lh({ hash: e, signature: t }));
}
function Gh(e) {
  const { chainId: t, contractAddress: n, nonce: r, to: i } = e, s = ho(mr([
    "0x05",
    vn([
      t ? Lt(t) : "0x",
      n,
      r ? Lt(r) : "0x"
    ])
  ]));
  return i === "bytes" ? En(s) : s;
}
async function zh(e) {
  const { authorization: t, signature: n } = e;
  return _h({
    hash: Gh(t),
    signature: n ?? t
  });
}
class Hh extends it {
  constructor(t, { account: n, docsPath: r, chain: i, data: s, gas: o, gasPrice: u, maxFeePerGas: d, maxPriorityFeePerGas: w, nonce: g, to: v, value: I }) {
    var D;
    const S = io({
      from: n == null ? void 0 : n.address,
      to: v,
      value: typeof I < "u" && `${hu(I)} ${((D = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : D.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof u < "u" && `${He(u)} gwei`,
      maxFeePerGas: typeof d < "u" && `${He(d)} gwei`,
      maxPriorityFeePerGas: typeof w < "u" && `${He(w)} gwei`,
      nonce: g
    });
    super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Estimate Gas Arguments:",
        S
      ].filter(Boolean),
      name: "EstimateGasExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
function Ou(e, t) {
  const n = (e.details || "").toLowerCase(), r = e instanceof it ? e.walk((i) => (i == null ? void 0 : i.code) === $n.code) : e;
  return r instanceof it ? new $n({
    cause: e,
    message: r.details
  }) : $n.nodeMessage.test(n) ? new $n({
    cause: e,
    message: e.details
  }) : Dn.nodeMessage.test(n) ? new Dn({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : Fs.nodeMessage.test(n) ? new Fs({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas
  }) : ks.nodeMessage.test(n) ? new ks({ cause: e, nonce: t == null ? void 0 : t.nonce }) : Ns.nodeMessage.test(n) ? new Ns({ cause: e, nonce: t == null ? void 0 : t.nonce }) : Rs.nodeMessage.test(n) ? new Rs({ cause: e, nonce: t == null ? void 0 : t.nonce }) : Ps.nodeMessage.test(n) ? new Ps({ cause: e }) : Ds.nodeMessage.test(n) ? new Ds({ cause: e, gas: t == null ? void 0 : t.gas }) : Os.nodeMessage.test(n) ? new Os({ cause: e, gas: t == null ? void 0 : t.gas }) : Ls.nodeMessage.test(n) ? new Ls({ cause: e }) : Sr.nodeMessage.test(n) ? new Sr({
    cause: e,
    maxFeePerGas: t == null ? void 0 : t.maxFeePerGas,
    maxPriorityFeePerGas: t == null ? void 0 : t.maxPriorityFeePerGas
  }) : new fo({
    cause: e
  });
}
function Vh(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = Ou(e, n);
    return i instanceof fo ? e : i;
  })();
  return new Hh(r, {
    docsPath: t,
    ...n
  });
}
function Lu(e, { format: t }) {
  if (!t)
    return {};
  const n = {};
  function r(s) {
    const o = Object.keys(s);
    for (const u of o)
      u in e && (n[u] = e[u]), s[u] && typeof s[u] == "object" && !Array.isArray(s[u]) && r(s[u]);
  }
  const i = t(e || {});
  return r(i), n;
}
class Qh extends it {
  constructor({ address: t }) {
    super(`State for account "${t}" is set multiple times.`, {
      name: "AccountStateConflictError"
    });
  }
}
class Kh extends it {
  constructor() {
    super("state and stateDiff are set on the same account.", {
      name: "StateAssignmentConflictError"
    });
  }
}
function la(e) {
  return e.reduce((t, { slot: n, value: r }) => `${t}        ${n}: ${r}
`, "");
}
function qh(e) {
  return e.reduce((t, { address: n, ...r }) => {
    let i = `${t}    ${n}:
`;
    return r.nonce && (i += `      nonce: ${r.nonce}
`), r.balance && (i += `      balance: ${r.balance}
`), r.code && (i += `      code: ${r.code}
`), r.state && (i += `      state:
`, i += la(r.state)), r.stateDiff && (i += `      stateDiff:
`, i += la(r.stateDiff)), i;
  }, `  State Override:
`).slice(0, -1);
}
function ha(e) {
  if (!(!e || e.length === 0))
    return e.reduce((t, { slot: n, value: r }) => {
      if (n.length !== 66)
        throw new ta({
          size: n.length,
          targetSize: 66,
          type: "hex"
        });
      if (r.length !== 66)
        throw new ta({
          size: r.length,
          targetSize: 66,
          type: "hex"
        });
      return t[n] = r, t;
    }, {});
}
function jh(e) {
  const { balance: t, nonce: n, state: r, stateDiff: i, code: s } = e, o = {};
  if (s !== void 0 && (o.code = s), t !== void 0 && (o.balance = Lt(t)), n !== void 0 && (o.nonce = Lt(n)), r !== void 0 && (o.state = ha(r)), i !== void 0) {
    if (o.state)
      throw new Kh();
    o.stateDiff = ha(i);
  }
  return o;
}
function Yh(e) {
  if (!e)
    return;
  const t = {};
  for (const { address: n, ...r } of e) {
    if (!Je(n, { strict: !1 }))
      throw new Ze({ address: n });
    if (t[n])
      throw new Qh({ address: n });
    t[n] = jh(r);
  }
  return t;
}
function mo(e) {
  const { account: t, gasPrice: n, maxFeePerGas: r, maxPriorityFeePerGas: i, to: s } = e, o = t ? zr(t) : void 0;
  if (o && !Je(o.address))
    throw new Ze({ address: o.address });
  if (s && !Je(s))
    throw new Ze({ address: s });
  if (typeof n < "u" && (typeof r < "u" || typeof i < "u"))
    throw new ll();
  if (r && r > Ei)
    throw new Dn({ maxFeePerGas: r });
  if (i && r && i > r)
    throw new Sr({ maxFeePerGas: r, maxPriorityFeePerGas: i });
}
async function Zh(e, { address: t, blockNumber: n, blockTag: r = "latest" }) {
  const i = n ? Lt(n) : void 0, s = await e.request({
    method: "eth_getBalance",
    params: [t, i || r]
  });
  return BigInt(s);
}
async function Jh(e, t) {
  var i, s, o;
  const n = t.account ?? e.account, r = n ? zr(n) : void 0;
  try {
    let a = function(p) {
      const { block: y, request: A, rpcStateOverride: B } = p;
      return e.request({
        method: "eth_estimateGas",
        params: B ? [A, y ?? "latest", B] : y ? [A, y] : [A]
      });
    };
    const { accessList: u, authorizationList: d, blobs: w, blobVersionedHashes: g, blockNumber: v, blockTag: I, data: S, gas: D, gasPrice: N, maxFeePerBlobGas: T, maxFeePerGas: O, maxPriorityFeePerGas: _, nonce: k, value: V, stateOverride: H, ...z } = await _u(e, {
      ...t,
      parameters: (
        // Some RPC Providers do not compute versioned hashes from blobs. We will need
        // to compute them.
        (r == null ? void 0 : r.type) === "local" ? void 0 : ["blobVersionedHashes"]
      )
    }), Y = (v ? Lt(v) : void 0) || I, J = Yh(H), gt = await (async () => {
      if (z.to)
        return z.to;
      if (d && d.length > 0)
        return await zh({
          authorization: d[0]
        }).catch(() => {
          throw new it("`to` is required. Could not infer from `authorizationList`");
        });
    })();
    mo(t);
    const $ = (o = (s = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionRequest) == null ? void 0 : o.format, M = ($ || au)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...Lu(z, { format: $ }),
      from: r == null ? void 0 : r.address,
      accessList: u,
      authorizationList: d,
      blobs: w,
      blobVersionedHashes: g,
      data: S,
      gas: D,
      gasPrice: N,
      maxFeePerBlobGas: T,
      maxFeePerGas: O,
      maxPriorityFeePerGas: _,
      nonce: k,
      to: gt,
      value: V
    });
    let h = BigInt(await a({ block: Y, request: M, rpcStateOverride: J }));
    if (d) {
      const p = await Zh(e, { address: M.from }), y = await Promise.all(d.map(async (A) => {
        const { contractAddress: B } = A, C = await a({
          block: Y,
          request: {
            authorizationList: void 0,
            data: S,
            from: r == null ? void 0 : r.address,
            to: B,
            value: Lt(p)
          },
          rpcStateOverride: J
        }).catch(() => 100000n);
        return 2n * BigInt(C);
      }));
      h += y.reduce((A, B) => A + B, 0n);
    }
    return h;
  } catch (u) {
    throw Vh(u, {
      ...t,
      account: r,
      chain: e.chain
    });
  }
}
async function Xh(e, { address: t, blockTag: n = "latest", blockNumber: r }) {
  const i = await e.request({
    method: "eth_getTransactionCount",
    params: [t, r ? Lt(r) : n]
  }, { dedupe: !!r });
  return Pn(i);
}
async function Wh(e) {
  const t = await e.request({
    method: "eth_chainId"
  }, { dedupe: !0 });
  return Pn(t);
}
const $h = [
  "blobVersionedHashes",
  "chainId",
  "fees",
  "gas",
  "nonce",
  "type"
];
async function _u(e, t) {
  const { account: n = e.account, blobs: r, chain: i, gas: s, kzg: o, nonce: u, nonceManager: d, parameters: w = $h, type: g } = t, v = n ? zr(n) : void 0, I = { ...t, ...v ? { from: v == null ? void 0 : v.address } : {} };
  let S;
  async function D() {
    return S || (S = await cn(e, ai, "getBlock")({ blockTag: "latest" }), S);
  }
  let N;
  async function T() {
    return N || (i ? i.id : typeof t.chainId < "u" ? t.chainId : (N = await cn(e, Wh, "getChainId")({}), N));
  }
  if ((w.includes("blobVersionedHashes") || w.includes("sidecars")) && r && o) {
    const O = so({ blobs: r, kzg: o });
    if (w.includes("blobVersionedHashes")) {
      const _ = mu({
        commitments: O,
        to: "hex"
      });
      I.blobVersionedHashes = _;
    }
    if (w.includes("sidecars")) {
      const _ = oo({ blobs: r, commitments: O, kzg: o }), k = xu({
        blobs: r,
        commitments: O,
        proofs: _,
        to: "hex"
      });
      I.sidecars = k;
    }
  }
  if (w.includes("chainId") && (I.chainId = await T()), w.includes("nonce") && typeof u > "u" && v)
    if (d) {
      const O = await T();
      I.nonce = await d.consume({
        address: v.address,
        chainId: O,
        client: e
      });
    } else
      I.nonce = await cn(e, Xh, "getTransactionCount")({
        address: v.address,
        blockTag: "pending"
      });
  if ((w.includes("fees") || w.includes("type")) && typeof g > "u")
    try {
      I.type = Pu(I);
    } catch {
      const O = await D();
      I.type = typeof (O == null ? void 0 : O.baseFeePerGas) == "bigint" ? "eip1559" : "legacy";
    }
  if (w.includes("fees"))
    if (I.type !== "legacy" && I.type !== "eip2930") {
      if (typeof I.maxFeePerGas > "u" || typeof I.maxPriorityFeePerGas > "u") {
        const O = await D(), { maxFeePerGas: _, maxPriorityFeePerGas: k } = await ca(e, {
          block: O,
          chain: i,
          request: I
        });
        if (typeof t.maxPriorityFeePerGas > "u" && t.maxFeePerGas && t.maxFeePerGas < k)
          throw new Rh({
            maxPriorityFeePerGas: k
          });
        I.maxPriorityFeePerGas = k, I.maxFeePerGas = _;
      }
    } else {
      if (typeof t.maxFeePerGas < "u" || typeof t.maxPriorityFeePerGas < "u")
        throw new yo();
      const O = await D(), { gasPrice: _ } = await ca(e, {
        block: O,
        chain: i,
        request: I,
        type: "legacy"
      });
      I.gasPrice = _;
    }
  return w.includes("gas") && typeof s > "u" && (I.gas = await cn(e, Jh, "estimateGas")({
    ...I,
    account: v ? { address: v.address, type: "json-rpc" } : void 0
  })), mo(I), delete I.parameters, I;
}
class t0 extends it {
  constructor({ docsPath: t } = {}) {
    super([
      "Could not find an Account to execute with this Action.",
      "Please provide an Account with the `account` argument on the Action, or by supplying an `account` to the Client."
    ].join(`
`), {
      docsPath: t,
      docsSlug: "account",
      name: "AccountNotFoundError"
    });
  }
}
class e0 extends it {
  constructor(t, { account: n, docsPath: r, chain: i, data: s, gas: o, gasPrice: u, maxFeePerGas: d, maxPriorityFeePerGas: w, nonce: g, to: v, value: I, stateOverride: S }) {
    var T;
    const D = n ? zr(n) : void 0;
    let N = io({
      from: D == null ? void 0 : D.address,
      to: v,
      value: typeof I < "u" && `${hu(I)} ${((T = i == null ? void 0 : i.nativeCurrency) == null ? void 0 : T.symbol) || "ETH"}`,
      data: s,
      gas: o,
      gasPrice: typeof u < "u" && `${He(u)} gwei`,
      maxFeePerGas: typeof d < "u" && `${He(d)} gwei`,
      maxPriorityFeePerGas: typeof w < "u" && `${He(w)} gwei`,
      nonce: g
    });
    S && (N += `
${qh(S)}`), super(t.shortMessage, {
      cause: t,
      docsPath: r,
      metaMessages: [
        ...t.metaMessages ? [...t.metaMessages, " "] : [],
        "Raw Call Arguments:",
        N
      ].filter(Boolean),
      name: "CallExecutionError"
    }), Object.defineProperty(this, "cause", {
      enumerable: !0,
      configurable: !0,
      writable: !0,
      value: void 0
    }), this.cause = t;
  }
}
function n0(e, { docsPath: t, ...n }) {
  const r = (() => {
    const i = Ou(e, n);
    return i instanceof fo ? e : i;
  })();
  return new e0(r, {
    docsPath: t,
    ...n
  });
}
async function r0(e, t) {
  var i, s, o;
  const { account: n = e.account } = t;
  if (!n)
    throw new t0();
  const r = zr(n);
  try {
    const { accessList: u, blockNumber: d, blockTag: w, data: g, gas: v, gasPrice: I, maxFeePerGas: S, maxPriorityFeePerGas: D, nonce: N, to: T, value: O, ..._ } = (r == null ? void 0 : r.type) === "local" ? await _u(e, t) : t, V = (d ? Lt(d) : void 0) || w;
    mo(t);
    const H = (o = (s = (i = e.chain) == null ? void 0 : i.formatters) == null ? void 0 : s.transactionRequest) == null ? void 0 : o.format, j = (H || au)({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...Lu(_, { format: H }),
      from: r == null ? void 0 : r.address,
      accessList: u,
      data: g,
      gas: v,
      gasPrice: I,
      maxFeePerGas: S,
      maxPriorityFeePerGas: D,
      nonce: N,
      to: T,
      value: O
    }), { baseFeePerGas: Y, gasLimit: J, priorityFeePerGas: gt } = await e.request({
      method: "linea_estimateGas",
      params: V ? [j, V] : [j]
    });
    return {
      baseFeePerGas: BigInt(Y),
      gasLimit: BigInt(J),
      priorityFeePerGas: BigInt(gt)
    };
  } catch (u) {
    throw n0(u, {
      ...t,
      account: r,
      chain: e.chain
    });
  }
}
const i0 = {
  fees: {
    estimateFeesPerGas: da,
    async maxPriorityFeePerGas({ block: e, client: t, request: n }) {
      const r = await da({
        block: e,
        client: t,
        multiply: (i) => i,
        request: n,
        type: "eip1559"
      });
      return r != null && r.maxPriorityFeePerGas ? r.maxPriorityFeePerGas : null;
    }
  }
};
async function da({ client: e, multiply: t, request: n, type: r }) {
  try {
    const i = await r0(e, {
      ...n,
      account: n == null ? void 0 : n.account
    }), { priorityFeePerGas: s } = i, u = t(BigInt(i.baseFeePerGas)) + s;
    return r === "legacy" ? { gasPrice: u } : {
      maxFeePerGas: u,
      maxPriorityFeePerGas: s
    };
  } catch {
    return null;
  }
}
const s0 = /* @__PURE__ */ ve({
  ...i0,
  id: 59144,
  name: "Linea Mainnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    }
  },
  testnet: !1
}), o0 = /* @__PURE__ */ ve({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: !0
}), a0 = /* @__PURE__ */ ve({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cloudflare-eth.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
}), Br = 1, u0 = /* @__PURE__ */ ve({
  ...Se,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...Se.contracts,
    disputeGameFactory: {
      [Br]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [Br]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [Br]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [Br]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: Br
}), Jr = 5, c0 = /* @__PURE__ */ ve({
  ...Se,
  id: 420,
  name: "Optimism Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io",
      apiUrl: "https://goerli-optimism.etherscan.io/api"
    }
  },
  contracts: {
    ...Se.contracts,
    l2OutputOracle: {
      [Jr]: {
        address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    },
    portal: {
      [Jr]: {
        address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
      }
    },
    l1StandardBridge: {
      [Jr]: {
        address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
      }
    }
  },
  testnet: !0,
  sourceId: Jr
}), f0 = /* @__PURE__ */ ve({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
}), l0 = /* @__PURE__ */ ve({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ankr.com/polygon_mumbai"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://api-testnet.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: !0
}), h0 = /* @__PURE__ */ ve({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc2.sepolia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: !0
}), Xr = 1, d0 = /* @__PURE__ */ ve({
  ...Se,
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zora.energy"],
      webSocket: ["wss://rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  },
  contracts: {
    ...Se.contracts,
    l2OutputOracle: {
      [Xr]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 5882
    },
    portal: {
      [Xr]: {
        address: "0x1a0ad011913A150f69f6A19DF447A0CfD9551054"
      }
    },
    l1StandardBridge: {
      [Xr]: {
        address: "0x3e2Ea9B92B7E48A52296fD261dc26fd995284631"
      }
    }
  },
  sourceId: Xr
}), pa = 5, p0 = /* @__PURE__ */ ve({
  ...Se,
  id: 999,
  name: "Zora Goerli Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Goerli",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.zora.energy"],
      webSocket: ["wss://testnet.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.explorer.zora.energy",
      apiUrl: "https://testnet.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...Se.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 189123
    },
    portal: {
      [pa]: {
        address: "0xDb9F51790365e7dc196e7D072728df39Be958ACe"
      }
    }
  },
  sourceId: pa,
  testnet: !0
}), y0 = {
  mainnet: a0,
  goerli: Fh,
  optimismGoerli: c0,
  polygon: f0,
  polygonMumbai: l0,
  sepolia: h0,
  optimism: u0,
  arbitrum: Th,
  base: Ch,
  gnosis: kh,
  baseGoerli: Sh,
  baseSepolia: Uh,
  lineaTestnet: o0,
  linea: s0,
  zora: d0,
  zoraTestnet: p0
};
function m0(e) {
  for (const t of Object.values(y0))
    if (t.id === e)
      return t;
  throw new Error(`Chain with id ${e} not found`);
}
const Ee = {
  IMPLEMENTATION: {
    ADDRESS: Vt("0x2d25602551487c3f3354dd80d76d54383a243358"),
    ABI: Uf
  },
  REGISTRY: {
    ADDRESS: Vt("0x02101dfB77FDE026414827Fdc604ddAF224F0921"),
    ABI: Sf
  }
}, Ht = {
  ACCOUNT_PROXY: {
    ADDRESS: Vt("0x55266d75D1a14E4572138116aF39863Ed6596E7F"),
    // Proxy for the upgradeable implementation, initialization lives here
    ABI: Pf
  },
  IMPLEMENTATION: {
    ADDRESS: Vt("0x41C8f39463A868d3A88af00cd0fe7102F30E44eC"),
    // Upgradeable
    ABI: Df
  },
  REGISTRY: {
    ADDRESS: Vt("0x000000006551c19487814612e58FE06813775758"),
    ABI: Of
  }
}, w0 = "0x5af43d82803e903d91602b57fd5bf3", g0 = Vt(
  "0xcA1167915584462449EE5b4Ea51c37fE81eCDCCD"
), jn = "0xEF7B07Db21d449C50b00De4563FfFe4C9dd33f1f", Yn = "0x0F220412Bf22E05EBcC5070D60fd7136A08aF22C", b0 = {
  // ethereum
  1: Yn,
  // polygon
  137: Yn,
  // optimism
  10: Yn,
  // base
  8453: Yn,
  // linea
  59144: Yn,
  // arbitrum
  42161: Yn
}, A0 = {
  // sepolia
  11155111: jn,
  // mumbai
  80001: jn,
  // op sepolia
  11155420: jn,
  // base sepolia
  84532: jn,
  // linea testnet
  59140: jn,
  // arbitrum sepolia
  421614: jn
}, x0 = {
  ...A0,
  ...b0
}, E0 = {
  // ethereum
  1: 30101,
  // polygon
  137: 30109,
  // optimism
  10: 30111,
  // base
  8453: 30184,
  // linea
  59144: 30183,
  // arbitrum
  42161: 30110
}, v0 = {
  // sepolia
  11155111: 40161,
  // mumbai
  80001: 40109,
  // op sepolia
  11155420: 40232,
  // base sepolia
  84532: 40245,
  // linea testnet
  59140: 40157,
  // arbitrum sepolia
  421614: 40231
}, B0 = {
  ...v0,
  ...E0
};
function I0(e) {
  var t;
  switch (e) {
    case Ee.IMPLEMENTATION.ADDRESS:
      return "Implementation: Default V1";
    case ((t = Ht.ACCOUNT_PROXY) == null ? void 0 : t.ADDRESS):
    case void 0:
      return "Implementation: Default V3";
    default:
      return `Custom Implementation: ${e}`;
  }
}
function M0(e) {
  return Array.isArray(e) || typeof e == "string" || "length" in e && !("byteLength" in e);
}
function T0(e) {
  return typeof e == "string" || e instanceof Uint8Array;
}
function C0(e) {
  return typeof e == "string" || "raw" in e;
}
function S0(e) {
  return typeof e == "string" || e instanceof Uint8Array ? e : new Uint8Array(Array.from(e));
}
var U0 = "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";
const ya = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]), ma = 4;
function F0(e) {
  let t = 0;
  function n() {
    return e[t++] << 8 | e[t++];
  }
  let r = n(), i = 1, s = [0, 1];
  for (let H = 1; H < r; H++)
    s.push(i += n());
  let o = n(), u = t;
  t += o;
  let d = 0, w = 0;
  function g() {
    return d == 0 && (w = w << 8 | e[t++], d = 8), w >> --d & 1;
  }
  const v = 31, I = 2 ** v, S = I >>> 1, D = S >> 1, N = I - 1;
  let T = 0;
  for (let H = 0; H < v; H++)
    T = T << 1 | g();
  let O = [], _ = 0, k = I;
  for (; ; ) {
    let H = Math.floor(((T - _ + 1) * i - 1) / k), z = 0, j = r;
    for (; j - z > 1; ) {
      let gt = z + j >>> 1;
      H < s[gt] ? j = gt : z = gt;
    }
    if (z == 0)
      break;
    O.push(z);
    let Y = _ + Math.floor(k * s[z] / i), J = _ + Math.floor(k * s[z + 1] / i) - 1;
    for (; !((Y ^ J) & S); )
      T = T << 1 & N | g(), Y = Y << 1 & N, J = J << 1 & N | 1;
    for (; Y & ~J & D; )
      T = T & S | T << 1 & N >>> 1 | g(), Y = Y << 1 ^ S, J = (J ^ S) << 1 | S | 1;
    _ = Y, k = 1 + J - Y;
  }
  let V = r - 4;
  return O.map((H) => {
    switch (H - V) {
      case 3:
        return V + 65792 + (e[u++] << 16 | e[u++] << 8 | e[u++]);
      case 2:
        return V + 256 + (e[u++] << 8 | e[u++]);
      case 1:
        return V + e[u++];
      default:
        return H - 1;
    }
  });
}
function k0(e) {
  let t = 0;
  return () => e[t++];
}
function Gu(e) {
  return k0(F0(N0(e)));
}
function N0(e) {
  let t = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((i, s) => t[i.charCodeAt(0)] = s);
  let n = e.length, r = new Uint8Array(6 * n >> 3);
  for (let i = 0, s = 0, o = 0, u = 0; i < n; i++)
    u = u << 6 | t[e.charCodeAt(i)], o += 6, o >= 8 && (r[s++] = u >> (o -= 8));
  return r;
}
function R0(e) {
  return e & 1 ? ~e >> 1 : e >> 1;
}
function P0(e, t) {
  let n = Array(e);
  for (let r = 0, i = 0; r < e; r++)
    n[r] = i += R0(t());
  return n;
}
function Ur(e, t = 0) {
  let n = [];
  for (; ; ) {
    let r = e(), i = e();
    if (!i)
      break;
    t += r;
    for (let s = 0; s < i; s++)
      n.push(t + s);
    t += i + 1;
  }
  return n;
}
function zu(e) {
  return Fr(() => {
    let t = Ur(e);
    if (t.length)
      return t;
  });
}
function Hu(e) {
  let t = [];
  for (; ; ) {
    let n = e();
    if (n == 0)
      break;
    t.push(D0(n, e));
  }
  for (; ; ) {
    let n = e() - 1;
    if (n < 0)
      break;
    t.push(O0(n, e));
  }
  return t.flat();
}
function Fr(e) {
  let t = [];
  for (; ; ) {
    let n = e(t.length);
    if (!n)
      break;
    t.push(n);
  }
  return t;
}
function Vu(e, t, n) {
  let r = Array(e).fill().map(() => []);
  for (let i = 0; i < t; i++)
    P0(e, n).forEach((s, o) => r[o].push(s));
  return r;
}
function D0(e, t) {
  let n = 1 + t(), r = t(), i = Fr(t);
  return Vu(i.length, 1 + e, t).flatMap((o, u) => {
    let [d, ...w] = o;
    return Array(i[u]).fill().map((g, v) => {
      let I = v * r;
      return [d + v * n, w.map((S) => S + I)];
    });
  });
}
function O0(e, t) {
  let n = 1 + t();
  return Vu(n, 1 + e, t).map((i) => [i[0], i.slice(1)]);
}
function L0(e) {
  let t = [], n = Ur(e);
  return i(r([]), []), t;
  function r(s) {
    let o = e(), u = Fr(() => {
      let d = Ur(e).map((w) => n[w]);
      if (d.length)
        return r(d);
    });
    return { S: o, B: u, Q: s };
  }
  function i({ S: s, B: o }, u, d) {
    if (!(s & 4 && d === u[u.length - 1])) {
      s & 2 && (d = u[u.length - 1]), s & 1 && t.push(u);
      for (let w of o)
        for (let g of w.Q)
          i(w, [...u, g], d);
    }
  }
}
function _0(e) {
  return e.toString(16).toUpperCase().padStart(2, "0");
}
function Qu(e) {
  return `{${_0(e)}}`;
}
function G0(e) {
  let t = [];
  for (let n = 0, r = e.length; n < r; ) {
    let i = e.codePointAt(n);
    n += i < 65536 ? 1 : 2, t.push(i);
  }
  return t;
}
function or(e) {
  let n = e.length;
  if (n < 4096)
    return String.fromCodePoint(...e);
  let r = [];
  for (let i = 0; i < n; )
    r.push(String.fromCodePoint(...e.slice(i, i += 4096)));
  return r.join("");
}
function z0(e, t) {
  let n = e.length, r = n - t.length;
  for (let i = 0; r == 0 && i < n; i++)
    r = e[i] - t[i];
  return r;
}
var H0 = "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";
const kr = 44032, ui = 4352, ci = 4449, fi = 4519, Ku = 19, qu = 21, ar = 28, li = qu * ar, V0 = Ku * li, Q0 = kr + V0, K0 = ui + Ku, q0 = ci + qu, j0 = fi + ar;
function Tr(e) {
  return e >> 24 & 255;
}
function ju(e) {
  return e & 16777215;
}
let Gs, wa, zs, ei;
function Y0() {
  let e = Gu(H0);
  Gs = new Map(zu(e).flatMap((t, n) => t.map((r) => [r, n + 1 << 24]))), wa = new Set(Ur(e)), zs = /* @__PURE__ */ new Map(), ei = /* @__PURE__ */ new Map();
  for (let [t, n] of Hu(e)) {
    if (!wa.has(t) && n.length == 2) {
      let [r, i] = n, s = ei.get(r);
      s || (s = /* @__PURE__ */ new Map(), ei.set(r, s)), s.set(i, t);
    }
    zs.set(t, n.reverse());
  }
}
function Yu(e) {
  return e >= kr && e < Q0;
}
function Z0(e, t) {
  if (e >= ui && e < K0 && t >= ci && t < q0)
    return kr + (e - ui) * li + (t - ci) * ar;
  if (Yu(e) && t > fi && t < j0 && (e - kr) % ar == 0)
    return e + (t - fi);
  {
    let n = ei.get(e);
    return n && (n = n.get(t), n) ? n : -1;
  }
}
function Zu(e) {
  Gs || Y0();
  let t = [], n = [], r = !1;
  function i(s) {
    let o = Gs.get(s);
    o && (r = !0, s |= o), t.push(s);
  }
  for (let s of e)
    for (; ; ) {
      if (s < 128)
        t.push(s);
      else if (Yu(s)) {
        let o = s - kr, u = o / li | 0, d = o % li / ar | 0, w = o % ar;
        i(ui + u), i(ci + d), w > 0 && i(fi + w);
      } else {
        let o = zs.get(s);
        o ? n.push(...o) : i(s);
      }
      if (!n.length)
        break;
      s = n.pop();
    }
  if (r && t.length > 1) {
    let s = Tr(t[0]);
    for (let o = 1; o < t.length; o++) {
      let u = Tr(t[o]);
      if (u == 0 || s <= u) {
        s = u;
        continue;
      }
      let d = o - 1;
      for (; ; ) {
        let w = t[d + 1];
        if (t[d + 1] = t[d], t[d] = w, !d || (s = Tr(t[--d]), s <= u))
          break;
      }
      s = Tr(t[o]);
    }
  }
  return t;
}
function J0(e) {
  let t = [], n = [], r = -1, i = 0;
  for (let s of e) {
    let o = Tr(s), u = ju(s);
    if (r == -1)
      o == 0 ? r = u : t.push(u);
    else if (i > 0 && i >= o)
      o == 0 ? (t.push(r, ...n), n.length = 0, r = u) : n.push(u), i = o;
    else {
      let d = Z0(r, u);
      d >= 0 ? r = d : i == 0 && o == 0 ? (t.push(r), r = u) : (n.push(u), i = o);
    }
  }
  return r >= 0 && t.push(r, ...n), t;
}
function Ju(e) {
  return Zu(e).map(ju);
}
function X0(e) {
  return J0(Zu(e));
}
const ga = 45, Xu = ".", Wu = 65039, $u = 1, hi = (e) => Array.from(e);
function Nr(e, t) {
  return e.P.has(t) || e.Q.has(t);
}
class W0 extends Array {
  get is_emoji() {
    return !0;
  }
  // free tagging system
}
let Hs, tc, Sn, di, ec, nr, cs, Jn, In, ba, Vs;
function wo() {
  if (Hs)
    return;
  let e = Gu(U0);
  const t = () => Ur(e), n = () => new Set(t()), r = (g, v) => v.forEach((I) => g.add(I));
  Hs = new Map(Hu(e)), tc = n(), Sn = t(), di = new Set(t().map((g) => Sn[g])), Sn = new Set(Sn), ec = n(), n();
  let i = zu(e), s = e();
  const o = () => {
    let g = /* @__PURE__ */ new Set();
    return t().forEach((v) => r(g, i[v])), r(g, t()), g;
  };
  nr = Fr((g) => {
    let v = Fr(e).map((I) => I + 96);
    if (v.length) {
      let I = g >= s;
      v[0] -= 32, v = or(v), I && (v = `Restricted[${v}]`);
      let S = o(), D = o(), N = !e();
      return { N: v, P: S, Q: D, M: N, R: I };
    }
  }), cs = n(), Jn = /* @__PURE__ */ new Map();
  let u = t().concat(hi(cs)).sort((g, v) => g - v);
  u.forEach((g, v) => {
    let I = e(), S = u[v] = I ? u[v - I] : { V: [], M: /* @__PURE__ */ new Map() };
    S.V.push(g), cs.has(g) || Jn.set(g, S);
  });
  for (let { V: g, M: v } of new Set(Jn.values())) {
    let I = [];
    for (let D of g) {
      let N = nr.filter((O) => Nr(O, D)), T = I.find(({ G: O }) => N.some((_) => O.has(_)));
      T || (T = { G: /* @__PURE__ */ new Set(), V: [] }, I.push(T)), T.V.push(D), r(T.G, N);
    }
    let S = I.flatMap((D) => hi(D.G));
    for (let { G: D, V: N } of I) {
      let T = new Set(S.filter((O) => !D.has(O)));
      for (let O of N)
        v.set(O, T);
    }
  }
  In = /* @__PURE__ */ new Set();
  let d = /* @__PURE__ */ new Set();
  const w = (g) => In.has(g) ? d.add(g) : In.add(g);
  for (let g of nr) {
    for (let v of g.P)
      w(v);
    for (let v of g.Q)
      w(v);
  }
  for (let g of In)
    !Jn.has(g) && !d.has(g) && Jn.set(g, $u);
  r(In, Ju(In)), ba = L0(e).map((g) => W0.from(g)).sort(z0), Vs = /* @__PURE__ */ new Map();
  for (let g of ba) {
    let v = [Vs];
    for (let I of g) {
      let S = v.map((D) => {
        let N = D.get(I);
        return N || (N = /* @__PURE__ */ new Map(), D.set(I, N)), N;
      });
      I === Wu ? v.push(...S) : v = S;
    }
    for (let I of v)
      I.V = g;
  }
}
function go(e) {
  return (nc(e) ? "" : `${bo(Mi([e]))} `) + Qu(e);
}
function bo(e) {
  return `"${e}"‎`;
}
function $0(e) {
  if (e.length >= 4 && e[2] == ga && e[3] == ga)
    throw new Error(`invalid label extension: "${or(e.slice(0, 4))}"`);
}
function td(e) {
  for (let n = e.lastIndexOf(95); n > 0; )
    if (e[--n] !== 95)
      throw new Error("underscore allowed only at start");
}
function ed(e) {
  let t = e[0], n = ya.get(t);
  if (n)
    throw Cr(`leading ${n}`);
  let r = e.length, i = -1;
  for (let s = 1; s < r; s++) {
    t = e[s];
    let o = ya.get(t);
    if (o) {
      if (i == s)
        throw Cr(`${n} + ${o}`);
      i = s + 1, n = o;
    }
  }
  if (i == r)
    throw Cr(`trailing ${n}`);
}
function Mi(e, t = 1 / 0, n = Qu) {
  let r = [];
  nd(e[0]) && r.push("◌"), e.length > t && (t >>= 1, e = [...e.slice(0, t), 8230, ...e.slice(-t)]);
  let i = 0, s = e.length;
  for (let o = 0; o < s; o++) {
    let u = e[o];
    nc(u) && (r.push(or(e.slice(i, o))), r.push(n(u)), i = o + 1);
  }
  return r.push(or(e.slice(i, s))), r.join("");
}
function nd(e, t) {
  return wo(), t ? di.has(e) : Sn.has(e);
}
function nc(e) {
  return wo(), ec.has(e);
}
function rd(e) {
  return ad(id(e, X0, fd));
}
function id(e, t, n) {
  if (!e)
    return [];
  wo();
  let r = 0;
  return e.split(Xu).map((i) => {
    let s = G0(i), o = {
      input: s,
      offset: r
      // codepoint, not substring!
    };
    r += s.length + 1;
    try {
      let u = o.tokens = cd(s, t, n), d = u.length, w;
      if (!d)
        throw new Error("empty label");
      let g = o.output = u.flat();
      if (td(g), !(o.emoji = d > 1 || u[0].is_emoji) && g.every((I) => I < 128))
        $0(g), w = "ASCII";
      else {
        let I = u.flatMap((S) => S.is_emoji ? [] : S);
        if (!I.length)
          w = "Emoji";
        else {
          if (Sn.has(g[0]))
            throw Cr("leading combining mark");
          for (let N = 1; N < d; N++) {
            let T = u[N];
            if (!T.is_emoji && Sn.has(T[0]))
              throw Cr(`emoji + combining mark: "${or(u[N - 1])} + ${Mi([T[0]])}"`);
          }
          ed(g);
          let S = hi(new Set(I)), [D] = od(S);
          ud(D, I), sd(D, S), w = D.N;
        }
      }
      o.type = w;
    } catch (u) {
      o.error = u;
    }
    return o;
  });
}
function sd(e, t) {
  let n, r = [];
  for (let i of t) {
    let s = Jn.get(i);
    if (s === $u)
      return;
    if (s) {
      let o = s.M.get(i);
      if (n = n ? n.filter((u) => o.has(u)) : hi(o), !n.length)
        return;
    } else
      r.push(i);
  }
  if (n) {
    for (let i of n)
      if (r.every((s) => Nr(i, s)))
        throw new Error(`whole-script confusable: ${e.N}/${i.N}`);
  }
}
function od(e) {
  let t = nr;
  for (let n of e) {
    let r = t.filter((i) => Nr(i, n));
    if (!r.length)
      throw nr.some((i) => Nr(i, n)) ? ic(t[0], n) : rc(n);
    if (t = r, r.length == 1)
      break;
  }
  return t;
}
function ad(e) {
  return e.map(({ input: t, error: n, output: r }) => {
    if (n) {
      let i = n.message;
      throw new Error(e.length == 1 ? i : `Invalid label ${bo(Mi(t, 63))}: ${i}`);
    }
    return or(r);
  }).join(Xu);
}
function rc(e) {
  return new Error(`disallowed character: ${go(e)}`);
}
function ic(e, t) {
  let n = go(t), r = nr.find((i) => i.P.has(t));
  return r && (n = `${r.N} ${n}`), new Error(`illegal mixture: ${e.N} + ${n}`);
}
function Cr(e) {
  return new Error(`illegal placement: ${e}`);
}
function ud(e, t) {
  for (let n of t)
    if (!Nr(e, n))
      throw ic(e, n);
  if (e.M) {
    let n = Ju(t);
    for (let r = 1, i = n.length; r < i; r++)
      if (di.has(n[r])) {
        let s = r + 1;
        for (let o; s < i && di.has(o = n[s]); s++)
          for (let u = r; u < s; u++)
            if (n[u] == o)
              throw new Error(`duplicate non-spacing marks: ${go(o)}`);
        if (s - r > ma)
          throw new Error(`excessive non-spacing marks: ${bo(Mi(n.slice(r - 1, s)))} (${s - r}/${ma})`);
        r = s;
      }
  }
}
function cd(e, t, n) {
  let r = [], i = [];
  for (e = e.slice().reverse(); e.length; ) {
    let s = ld(e);
    if (s)
      i.length && (r.push(t(i)), i = []), r.push(n(s));
    else {
      let o = e.pop();
      if (In.has(o))
        i.push(o);
      else {
        let u = Hs.get(o);
        if (u)
          i.push(...u);
        else if (!tc.has(o))
          throw rc(o);
      }
    }
  }
  return i.length && r.push(t(i)), r;
}
function fd(e) {
  return e.filter((t) => t != Wu);
}
function ld(e, t) {
  let n = Vs, r, i = e.length;
  for (; i && (n = n.get(e[--i]), !!n); ) {
    let { V: s } = n;
    s && (r = s, t && t.push(...e.slice(i).reverse()), e.length = i);
  }
  return r;
}
function hd(e) {
  return rd(e);
}
async function fs(e, t) {
  const r = t.endsWith(".eth") ? await e.getEnsAddress({
    name: hd(t)
  }) : Vt(t);
  if (!r)
    throw new Error("Failed to resolve ENS address");
  return r;
}
function dd(e, ...t) {
  let n = 0;
  const r = [], i = e.startsWith("0x") ? e.substring(2) : e;
  for (const s of t)
    r.push(i.substr(n, s * 2)), n += s * 2;
  return r;
}
async function Q1(e, t, n, r, i) {
  const s = i ? Vt(i) : Ee.REGISTRY.ADDRESS, o = eo({
    address: s,
    abi: Ee.REGISTRY.ABI,
    client: {
      public: n
    }
  }), u = await n.getChainId();
  return await o.read.account([
    r ? Vt(r) : Ee.IMPLEMENTATION.ADDRESS,
    u,
    e,
    t,
    0
  ]);
}
async function pd(e, t, n, r, i, s) {
  s = s ?? 0;
  const o = r ? Vt(r) : Ee.IMPLEMENTATION.ADDRESS, u = i ? Vt(i) : Ee.REGISTRY.ADDRESS, d = De({
    abi: [
      {
        inputs: [],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    functionName: "initialize"
  });
  return {
    to: u,
    value: BigInt(0),
    data: De({
      abi: Ee.REGISTRY.ABI,
      functionName: "createAccount",
      args: [o, n, e, t, s, d]
    })
  };
}
async function yd(e, t, n, r, i, s, o) {
  s = s ?? 0;
  const u = r ? Vt(r) : Ee.IMPLEMENTATION.ADDRESS, d = i ? Vt(i) : Ee.REGISTRY.ADDRESS, w = eo({
    address: d,
    abi: Ee.REGISTRY.ABI,
    client: {
      wallet: n
    }
  }), g = o || await n.getChainId(), v = De({
    abi: [
      {
        inputs: [],
        name: "initialize",
        outputs: [],
        stateMutability: "nonpayable",
        type: "function"
      }
    ],
    functionName: "initialize"
  });
  return w.write.createAccount([
    u,
    g,
    e,
    t,
    s,
    v
  ]);
}
async function md(e, t, n, r) {
  return {
    to: e,
    value: 0n,
    data: De({
      abi: Ee.IMPLEMENTATION.ABI,
      functionName: "executeCall",
      args: [t, n, r]
    })
  };
}
async function K1(e, t, n, r, i) {
  return eo({
    address: e,
    abi: Ee.IMPLEMENTATION.ABI,
    client: {
      wallet: i
    }
  }).write.executeCall([
    t,
    n,
    r
  ]);
}
function ls(e, t, n, r, i, s) {
  s = s ?? 0;
  const o = r ? Vt(r) : Ee.IMPLEMENTATION.ADDRESS, u = i ? Vt(i) : Ee.REGISTRY.ADDRESS, d = wd(
    o,
    n,
    e,
    t,
    s.toString()
  ), w = BigInt(s).toString(16), g = Ya(w, { size: 32 });
  return Za({
    bytecode: d,
    from: u,
    opcode: "CREATE2",
    salt: g
  });
}
function wd(e, t, n, r, i) {
  const s = [
    { type: "uint256" },
    { type: "uint256" },
    { type: "address" },
    { type: "uint256" }
  ], o = [
    i,
    BigInt(t),
    n,
    r
  ], u = Ja(s, o), w = Xa([
    "0x3d60ad80600a3d3981f3363d3d373d3d3d363d73",
    e,
    "0x5af43d82803e903d91602b57fd5bf3",
    u
  ]);
  return Wa(w);
}
async function gd(e, t, n, r, i, s) {
  var w;
  if (!Ht.ACCOUNT_PROXY)
    throw new Error("ERC_6551_DEFAULT.ACCOUNT_PROXY is undefined");
  const o = s ?? 0, u = r ?? ((w = Ht.ACCOUNT_PROXY) == null ? void 0 : w.ADDRESS), d = i ?? Ht.REGISTRY.ADDRESS;
  return {
    to: Vt(d),
    value: BigInt(0),
    data: De({
      abi: Ht.REGISTRY.ABI,
      functionName: "createAccount",
      args: [
        Vt(u),
        xf(Ef(o, { size: 32 })),
        n,
        e,
        t
      ]
    })
  };
}
function hs(e, t, n, r, i, s) {
  const o = s ?? 0;
  if (!Ht.ACCOUNT_PROXY)
    throw new Error("ERC_6551_DEFAULT.ACCOUNT_PROXY is undefined");
  const u = r ?? Ht.ACCOUNT_PROXY.ADDRESS, d = i ?? Ht.REGISTRY.ADDRESS, w = [
    { type: "uint256" },
    // salt
    { type: "uint256" },
    // chainId
    { type: "address" },
    // tokenContract
    { type: "uint256" }
    // tokenId
  ], g = [
    o.toString(),
    BigInt(n),
    e,
    t
  ], v = Ja(w, g), I = Xa([
    "0x3d60ad80600a3d3981f3363d3d373d3d3d363d73",
    Vt(u),
    w0,
    v
  ]), S = Wa(I), D = BigInt(o).toString(16), N = Ya(D, { size: 32 });
  return Za({
    bytecode: S,
    from: Vt(d),
    opcode: "CREATE2",
    salt: N
  });
}
const bd = "logger/5.7.0";
let Aa = !1, xa = !1;
const ni = { debug: 1, default: 2, info: 2, warning: 3, error: 4, off: 5 };
let Ea = ni.default, ds = null;
function Ad() {
  try {
    const e = [];
    if (["NFD", "NFC", "NFKD", "NFKC"].forEach((t) => {
      try {
        if ("test".normalize(t) !== "test")
          throw new Error("bad normalize");
      } catch {
        e.push(t);
      }
    }), e.length)
      throw new Error("missing " + e.join(", "));
    if (String.fromCharCode(233).normalize("NFD") !== String.fromCharCode(101, 769))
      throw new Error("broken implementation");
  } catch (e) {
    return e.message;
  }
  return null;
}
const va = Ad();
var Qs;
(function(e) {
  e.DEBUG = "DEBUG", e.INFO = "INFO", e.WARNING = "WARNING", e.ERROR = "ERROR", e.OFF = "OFF";
})(Qs || (Qs = {}));
var ze;
(function(e) {
  e.UNKNOWN_ERROR = "UNKNOWN_ERROR", e.NOT_IMPLEMENTED = "NOT_IMPLEMENTED", e.UNSUPPORTED_OPERATION = "UNSUPPORTED_OPERATION", e.NETWORK_ERROR = "NETWORK_ERROR", e.SERVER_ERROR = "SERVER_ERROR", e.TIMEOUT = "TIMEOUT", e.BUFFER_OVERRUN = "BUFFER_OVERRUN", e.NUMERIC_FAULT = "NUMERIC_FAULT", e.MISSING_NEW = "MISSING_NEW", e.INVALID_ARGUMENT = "INVALID_ARGUMENT", e.MISSING_ARGUMENT = "MISSING_ARGUMENT", e.UNEXPECTED_ARGUMENT = "UNEXPECTED_ARGUMENT", e.CALL_EXCEPTION = "CALL_EXCEPTION", e.INSUFFICIENT_FUNDS = "INSUFFICIENT_FUNDS", e.NONCE_EXPIRED = "NONCE_EXPIRED", e.REPLACEMENT_UNDERPRICED = "REPLACEMENT_UNDERPRICED", e.UNPREDICTABLE_GAS_LIMIT = "UNPREDICTABLE_GAS_LIMIT", e.TRANSACTION_REPLACED = "TRANSACTION_REPLACED", e.ACTION_REJECTED = "ACTION_REJECTED";
})(ze || (ze = {}));
const Ba = "0123456789abcdef";
class vt {
  constructor(t) {
    Object.defineProperty(this, "version", {
      enumerable: !0,
      value: t,
      writable: !1
    });
  }
  _log(t, n) {
    const r = t.toLowerCase();
    ni[r] == null && this.throwArgumentError("invalid log level name", "logLevel", t), !(Ea > ni[r]) && console.log.apply(console, n);
  }
  debug(...t) {
    this._log(vt.levels.DEBUG, t);
  }
  info(...t) {
    this._log(vt.levels.INFO, t);
  }
  warn(...t) {
    this._log(vt.levels.WARNING, t);
  }
  makeError(t, n, r) {
    if (xa)
      return this.makeError("censored error", n, {});
    n || (n = vt.errors.UNKNOWN_ERROR), r || (r = {});
    const i = [];
    Object.keys(r).forEach((d) => {
      const w = r[d];
      try {
        if (w instanceof Uint8Array) {
          let g = "";
          for (let v = 0; v < w.length; v++)
            g += Ba[w[v] >> 4], g += Ba[w[v] & 15];
          i.push(d + "=Uint8Array(0x" + g + ")");
        } else
          i.push(d + "=" + JSON.stringify(w));
      } catch {
        i.push(d + "=" + JSON.stringify(r[d].toString()));
      }
    }), i.push(`code=${n}`), i.push(`version=${this.version}`);
    const s = t;
    let o = "";
    switch (n) {
      case ze.NUMERIC_FAULT: {
        o = "NUMERIC_FAULT";
        const d = t;
        switch (d) {
          case "overflow":
          case "underflow":
          case "division-by-zero":
            o += "-" + d;
            break;
          case "negative-power":
          case "negative-width":
            o += "-unsupported";
            break;
          case "unbound-bitwise-result":
            o += "-unbound-result";
            break;
        }
        break;
      }
      case ze.CALL_EXCEPTION:
      case ze.INSUFFICIENT_FUNDS:
      case ze.MISSING_NEW:
      case ze.NONCE_EXPIRED:
      case ze.REPLACEMENT_UNDERPRICED:
      case ze.TRANSACTION_REPLACED:
      case ze.UNPREDICTABLE_GAS_LIMIT:
        o = n;
        break;
    }
    o && (t += " [ See: https://links.ethers.org/v5-errors-" + o + " ]"), i.length && (t += " (" + i.join(", ") + ")");
    const u = new Error(t);
    return u.reason = s, u.code = n, Object.keys(r).forEach(function(d) {
      u[d] = r[d];
    }), u;
  }
  throwError(t, n, r) {
    throw this.makeError(t, n, r);
  }
  throwArgumentError(t, n, r) {
    return this.throwError(t, vt.errors.INVALID_ARGUMENT, {
      argument: n,
      value: r
    });
  }
  assert(t, n, r, i) {
    t || this.throwError(n, r, i);
  }
  assertArgument(t, n, r, i) {
    t || this.throwArgumentError(n, r, i);
  }
  checkNormalize(t) {
    va && this.throwError("platform missing String.prototype.normalize", vt.errors.UNSUPPORTED_OPERATION, {
      operation: "String.prototype.normalize",
      form: va
    });
  }
  checkSafeUint53(t, n) {
    typeof t == "number" && (n == null && (n = "value not safe"), (t < 0 || t >= 9007199254740991) && this.throwError(n, vt.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "out-of-safe-range",
      value: t
    }), t % 1 && this.throwError(n, vt.errors.NUMERIC_FAULT, {
      operation: "checkSafeInteger",
      fault: "non-integer",
      value: t
    }));
  }
  checkArgumentCount(t, n, r) {
    r ? r = ": " + r : r = "", t < n && this.throwError("missing argument" + r, vt.errors.MISSING_ARGUMENT, {
      count: t,
      expectedCount: n
    }), t > n && this.throwError("too many arguments" + r, vt.errors.UNEXPECTED_ARGUMENT, {
      count: t,
      expectedCount: n
    });
  }
  checkNew(t, n) {
    (t === Object || t == null) && this.throwError("missing new", vt.errors.MISSING_NEW, { name: n.name });
  }
  checkAbstract(t, n) {
    t === n ? this.throwError("cannot instantiate abstract class " + JSON.stringify(n.name) + " directly; use a sub-class", vt.errors.UNSUPPORTED_OPERATION, { name: t.name, operation: "new" }) : (t === Object || t == null) && this.throwError("missing new", vt.errors.MISSING_NEW, { name: n.name });
  }
  static globalLogger() {
    return ds || (ds = new vt(bd)), ds;
  }
  static setCensorship(t, n) {
    if (!t && n && this.globalLogger().throwError("cannot permanently disable censorship", vt.errors.UNSUPPORTED_OPERATION, {
      operation: "setCensorship"
    }), Aa) {
      if (!t)
        return;
      this.globalLogger().throwError("error censorship permanent", vt.errors.UNSUPPORTED_OPERATION, {
        operation: "setCensorship"
      });
    }
    xa = !!t, Aa = !!n;
  }
  static setLogLevel(t) {
    const n = ni[t.toLowerCase()];
    if (n == null) {
      vt.globalLogger().warn("invalid log level - " + t);
      return;
    }
    Ea = n;
  }
  static from(t) {
    return new vt(t);
  }
}
vt.errors = ze;
vt.levels = Qs;
const xd = "bytes/5.7.0", fn = new vt(xd);
function sc(e) {
  return !!e.toHexString;
}
function rr(e) {
  return e.slice || (e.slice = function() {
    const t = Array.prototype.slice.call(arguments);
    return rr(new Uint8Array(Array.prototype.slice.apply(e, t)));
  }), e;
}
function Ia(e) {
  return typeof e == "number" && e == e && e % 1 === 0;
}
function Ao(e) {
  if (e == null)
    return !1;
  if (e.constructor === Uint8Array)
    return !0;
  if (typeof e == "string" || !Ia(e.length) || e.length < 0)
    return !1;
  for (let t = 0; t < e.length; t++) {
    const n = e[t];
    if (!Ia(n) || n < 0 || n >= 256)
      return !1;
  }
  return !0;
}
function je(e, t) {
  if (t || (t = {}), typeof e == "number") {
    fn.checkSafeUint53(e, "invalid arrayify value");
    const n = [];
    for (; e; )
      n.unshift(e & 255), e = parseInt(String(e / 256));
    return n.length === 0 && n.push(0), rr(new Uint8Array(n));
  }
  if (t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), sc(e) && (e = e.toHexString()), Rr(e)) {
    let n = e.substring(2);
    n.length % 2 && (t.hexPad === "left" ? n = "0" + n : t.hexPad === "right" ? n += "0" : fn.throwArgumentError("hex data is odd-length", "value", e));
    const r = [];
    for (let i = 0; i < n.length; i += 2)
      r.push(parseInt(n.substring(i, i + 2), 16));
    return rr(new Uint8Array(r));
  }
  return Ao(e) ? rr(new Uint8Array(e)) : fn.throwArgumentError("invalid arrayify value", "value", e);
}
function oc(e) {
  const t = e.map((i) => je(i)), n = t.reduce((i, s) => i + s.length, 0), r = new Uint8Array(n);
  return t.reduce((i, s) => (r.set(s, i), i + s.length), 0), rr(r);
}
function ps(e, t) {
  e = je(e), e.length > t && fn.throwArgumentError("value out of range", "value", arguments[0]);
  const n = new Uint8Array(t);
  return n.set(e, t - e.length), rr(n);
}
function Rr(e, t) {
  return !(typeof e != "string" || !e.match(/^0x[0-9A-Fa-f]*$/) || t && e.length !== 2 + 2 * t);
}
const ys = "0123456789abcdef";
function Un(e, t) {
  if (t || (t = {}), typeof e == "number") {
    fn.checkSafeUint53(e, "invalid hexlify value");
    let n = "";
    for (; e; )
      n = ys[e & 15] + n, e = Math.floor(e / 16);
    return n.length ? (n.length % 2 && (n = "0" + n), "0x" + n) : "0x00";
  }
  if (typeof e == "bigint")
    return e = e.toString(16), e.length % 2 ? "0x0" + e : "0x" + e;
  if (t.allowMissingPrefix && typeof e == "string" && e.substring(0, 2) !== "0x" && (e = "0x" + e), sc(e))
    return e.toHexString();
  if (Rr(e))
    return e.length % 2 && (t.hexPad === "left" ? e = "0x0" + e.substring(2) : t.hexPad === "right" ? e += "0" : fn.throwArgumentError("hex data is odd-length", "value", e)), e.toLowerCase();
  if (Ao(e)) {
    let n = "0x";
    for (let r = 0; r < e.length; r++) {
      let i = e[r];
      n += ys[(i & 240) >> 4] + ys[i & 15];
    }
    return n;
  }
  return fn.throwArgumentError("invalid hexlify value", "value", e);
}
function Ed(e, t) {
  for (typeof e != "string" ? e = Un(e) : Rr(e) || fn.throwArgumentError("invalid hex string", "value", e), e.length > 2 * t + 2 && fn.throwArgumentError("value out of range", "value", arguments[1]); e.length < 2 * t + 2; )
    e = "0x0" + e.substring(2);
  return e;
}
var Qe = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function ac(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
function xo(e) {
  if (e.__esModule)
    return e;
  var t = e.default;
  if (typeof t == "function") {
    var n = function r() {
      return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
    };
    n.prototype = t.prototype;
  } else
    n = {};
  return Object.defineProperty(n, "__esModule", { value: !0 }), Object.keys(e).forEach(function(r) {
    var i = Object.getOwnPropertyDescriptor(e, r);
    Object.defineProperty(n, r, i.get ? i : {
      enumerable: !0,
      get: function() {
        return e[r];
      }
    });
  }), n;
}
var Eo = { exports: {} };
const vd = {}, Bd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: vd
}, Symbol.toStringTag, { value: "Module" })), Id = /* @__PURE__ */ xo(Bd);
Eo.exports;
(function(e) {
  (function(t, n) {
    function r(M, a) {
      if (!M)
        throw new Error(a || "Assertion failed");
    }
    function i(M, a) {
      M.super_ = a;
      var h = function() {
      };
      h.prototype = a.prototype, M.prototype = new h(), M.prototype.constructor = M;
    }
    function s(M, a, h) {
      if (s.isBN(M))
        return M;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, M !== null && ((a === "le" || a === "be") && (h = a, a = 10), this._init(M || 0, a || 10, h || "be"));
    }
    typeof t == "object" ? t.exports = s : n.BN = s, s.BN = s, s.wordSize = 26;
    var o;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? o = window.Buffer : o = Id.Buffer;
    } catch {
    }
    s.isBN = function(a) {
      return a instanceof s ? !0 : a !== null && typeof a == "object" && a.constructor.wordSize === s.wordSize && Array.isArray(a.words);
    }, s.max = function(a, h) {
      return a.cmp(h) > 0 ? a : h;
    }, s.min = function(a, h) {
      return a.cmp(h) < 0 ? a : h;
    }, s.prototype._init = function(a, h, p) {
      if (typeof a == "number")
        return this._initNumber(a, h, p);
      if (typeof a == "object")
        return this._initArray(a, h, p);
      h === "hex" && (h = 16), r(h === (h | 0) && h >= 2 && h <= 36), a = a.toString().replace(/\s+/g, "");
      var y = 0;
      a[0] === "-" && (y++, this.negative = 1), y < a.length && (h === 16 ? this._parseHex(a, y, p) : (this._parseBase(a, h, y), p === "le" && this._initArray(this.toArray(), h, p)));
    }, s.prototype._initNumber = function(a, h, p) {
      a < 0 && (this.negative = 1, a = -a), a < 67108864 ? (this.words = [a & 67108863], this.length = 1) : a < 4503599627370496 ? (this.words = [
        a & 67108863,
        a / 67108864 & 67108863
      ], this.length = 2) : (r(a < 9007199254740992), this.words = [
        a & 67108863,
        a / 67108864 & 67108863,
        1
      ], this.length = 3), p === "le" && this._initArray(this.toArray(), h, p);
    }, s.prototype._initArray = function(a, h, p) {
      if (r(typeof a.length == "number"), a.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(a.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var A, B, C = 0;
      if (p === "be")
        for (y = a.length - 1, A = 0; y >= 0; y -= 3)
          B = a[y] | a[y - 1] << 8 | a[y - 2] << 16, this.words[A] |= B << C & 67108863, this.words[A + 1] = B >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, A++);
      else if (p === "le")
        for (y = 0, A = 0; y < a.length; y += 3)
          B = a[y] | a[y + 1] << 8 | a[y + 2] << 16, this.words[A] |= B << C & 67108863, this.words[A + 1] = B >>> 26 - C & 67108863, C += 24, C >= 26 && (C -= 26, A++);
      return this._strip();
    };
    function u(M, a) {
      var h = M.charCodeAt(a);
      if (h >= 48 && h <= 57)
        return h - 48;
      if (h >= 65 && h <= 70)
        return h - 55;
      if (h >= 97 && h <= 102)
        return h - 87;
      r(!1, "Invalid character in " + M);
    }
    function d(M, a, h) {
      var p = u(M, h);
      return h - 1 >= a && (p |= u(M, h - 1) << 4), p;
    }
    s.prototype._parseHex = function(a, h, p) {
      this.length = Math.ceil((a.length - h) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var A = 0, B = 0, C;
      if (p === "be")
        for (y = a.length - 1; y >= h; y -= 2)
          C = d(a, h, y) << A, this.words[B] |= C & 67108863, A >= 18 ? (A -= 18, B += 1, this.words[B] |= C >>> 26) : A += 8;
      else {
        var b = a.length - h;
        for (y = b % 2 === 0 ? h + 1 : h; y < a.length; y += 2)
          C = d(a, h, y) << A, this.words[B] |= C & 67108863, A >= 18 ? (A -= 18, B += 1, this.words[B] |= C >>> 26) : A += 8;
      }
      this._strip();
    };
    function w(M, a, h, p) {
      for (var y = 0, A = 0, B = Math.min(M.length, h), C = a; C < B; C++) {
        var b = M.charCodeAt(C) - 48;
        y *= p, b >= 49 ? A = b - 49 + 10 : b >= 17 ? A = b - 17 + 10 : A = b, r(b >= 0 && A < p, "Invalid character"), y += A;
      }
      return y;
    }
    s.prototype._parseBase = function(a, h, p) {
      this.words = [0], this.length = 1;
      for (var y = 0, A = 1; A <= 67108863; A *= h)
        y++;
      y--, A = A / h | 0;
      for (var B = a.length - p, C = B % y, b = Math.min(B, B - C) + p, l = 0, E = p; E < b; E += y)
        l = w(a, E, E + y, h), this.imuln(A), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      if (C !== 0) {
        var Q = 1;
        for (l = w(a, E, a.length, h), E = 0; E < C; E++)
          Q *= h;
        this.imuln(Q), this.words[0] + l < 67108864 ? this.words[0] += l : this._iaddn(l);
      }
      this._strip();
    }, s.prototype.copy = function(a) {
      a.words = new Array(this.length);
      for (var h = 0; h < this.length; h++)
        a.words[h] = this.words[h];
      a.length = this.length, a.negative = this.negative, a.red = this.red;
    };
    function g(M, a) {
      M.words = a.words, M.length = a.length, M.negative = a.negative, M.red = a.red;
    }
    if (s.prototype._move = function(a) {
      g(a, this);
    }, s.prototype.clone = function() {
      var a = new s(null);
      return this.copy(a), a;
    }, s.prototype._expand = function(a) {
      for (; this.length < a; )
        this.words[this.length++] = 0;
      return this;
    }, s.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, s.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        s.prototype[Symbol.for("nodejs.util.inspect.custom")] = v;
      } catch {
        s.prototype.inspect = v;
      }
    else
      s.prototype.inspect = v;
    function v() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var I = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], S = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], D = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    s.prototype.toString = function(a, h) {
      a = a || 10, h = h | 0 || 1;
      var p;
      if (a === 16 || a === "hex") {
        p = "";
        for (var y = 0, A = 0, B = 0; B < this.length; B++) {
          var C = this.words[B], b = ((C << y | A) & 16777215).toString(16);
          A = C >>> 24 - y & 16777215, y += 2, y >= 26 && (y -= 26, B--), A !== 0 || B !== this.length - 1 ? p = I[6 - b.length] + b + p : p = b + p;
        }
        for (A !== 0 && (p = A.toString(16) + p); p.length % h !== 0; )
          p = "0" + p;
        return this.negative !== 0 && (p = "-" + p), p;
      }
      if (a === (a | 0) && a >= 2 && a <= 36) {
        var l = S[a], E = D[a];
        p = "";
        var Q = this.clone();
        for (Q.negative = 0; !Q.isZero(); ) {
          var q = Q.modrn(E).toString(a);
          Q = Q.idivn(E), Q.isZero() ? p = q + p : p = I[l - q.length] + q + p;
        }
        for (this.isZero() && (p = "0" + p); p.length % h !== 0; )
          p = "0" + p;
        return this.negative !== 0 && (p = "-" + p), p;
      }
      r(!1, "Base should be between 2 and 36");
    }, s.prototype.toNumber = function() {
      var a = this.words[0];
      return this.length === 2 ? a += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? a += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -a : a;
    }, s.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, o && (s.prototype.toBuffer = function(a, h) {
      return this.toArrayLike(o, a, h);
    }), s.prototype.toArray = function(a, h) {
      return this.toArrayLike(Array, a, h);
    };
    var N = function(a, h) {
      return a.allocUnsafe ? a.allocUnsafe(h) : new a(h);
    };
    s.prototype.toArrayLike = function(a, h, p) {
      this._strip();
      var y = this.byteLength(), A = p || Math.max(1, y);
      r(y <= A, "byte array longer than desired length"), r(A > 0, "Requested array length <= 0");
      var B = N(a, A), C = h === "le" ? "LE" : "BE";
      return this["_toArrayLike" + C](B, y), B;
    }, s.prototype._toArrayLikeLE = function(a, h) {
      for (var p = 0, y = 0, A = 0, B = 0; A < this.length; A++) {
        var C = this.words[A] << B | y;
        a[p++] = C & 255, p < a.length && (a[p++] = C >> 8 & 255), p < a.length && (a[p++] = C >> 16 & 255), B === 6 ? (p < a.length && (a[p++] = C >> 24 & 255), y = 0, B = 0) : (y = C >>> 24, B += 2);
      }
      if (p < a.length)
        for (a[p++] = y; p < a.length; )
          a[p++] = 0;
    }, s.prototype._toArrayLikeBE = function(a, h) {
      for (var p = a.length - 1, y = 0, A = 0, B = 0; A < this.length; A++) {
        var C = this.words[A] << B | y;
        a[p--] = C & 255, p >= 0 && (a[p--] = C >> 8 & 255), p >= 0 && (a[p--] = C >> 16 & 255), B === 6 ? (p >= 0 && (a[p--] = C >> 24 & 255), y = 0, B = 0) : (y = C >>> 24, B += 2);
      }
      if (p >= 0)
        for (a[p--] = y; p >= 0; )
          a[p--] = 0;
    }, Math.clz32 ? s.prototype._countBits = function(a) {
      return 32 - Math.clz32(a);
    } : s.prototype._countBits = function(a) {
      var h = a, p = 0;
      return h >= 4096 && (p += 13, h >>>= 13), h >= 64 && (p += 7, h >>>= 7), h >= 8 && (p += 4, h >>>= 4), h >= 2 && (p += 2, h >>>= 2), p + h;
    }, s.prototype._zeroBits = function(a) {
      if (a === 0)
        return 26;
      var h = a, p = 0;
      return h & 8191 || (p += 13, h >>>= 13), h & 127 || (p += 7, h >>>= 7), h & 15 || (p += 4, h >>>= 4), h & 3 || (p += 2, h >>>= 2), h & 1 || p++, p;
    }, s.prototype.bitLength = function() {
      var a = this.words[this.length - 1], h = this._countBits(a);
      return (this.length - 1) * 26 + h;
    };
    function T(M) {
      for (var a = new Array(M.bitLength()), h = 0; h < a.length; h++) {
        var p = h / 26 | 0, y = h % 26;
        a[h] = M.words[p] >>> y & 1;
      }
      return a;
    }
    s.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var a = 0, h = 0; h < this.length; h++) {
        var p = this._zeroBits(this.words[h]);
        if (a += p, p !== 26)
          break;
      }
      return a;
    }, s.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, s.prototype.toTwos = function(a) {
      return this.negative !== 0 ? this.abs().inotn(a).iaddn(1) : this.clone();
    }, s.prototype.fromTwos = function(a) {
      return this.testn(a - 1) ? this.notn(a).iaddn(1).ineg() : this.clone();
    }, s.prototype.isNeg = function() {
      return this.negative !== 0;
    }, s.prototype.neg = function() {
      return this.clone().ineg();
    }, s.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, s.prototype.iuor = function(a) {
      for (; this.length < a.length; )
        this.words[this.length++] = 0;
      for (var h = 0; h < a.length; h++)
        this.words[h] = this.words[h] | a.words[h];
      return this._strip();
    }, s.prototype.ior = function(a) {
      return r((this.negative | a.negative) === 0), this.iuor(a);
    }, s.prototype.or = function(a) {
      return this.length > a.length ? this.clone().ior(a) : a.clone().ior(this);
    }, s.prototype.uor = function(a) {
      return this.length > a.length ? this.clone().iuor(a) : a.clone().iuor(this);
    }, s.prototype.iuand = function(a) {
      var h;
      this.length > a.length ? h = a : h = this;
      for (var p = 0; p < h.length; p++)
        this.words[p] = this.words[p] & a.words[p];
      return this.length = h.length, this._strip();
    }, s.prototype.iand = function(a) {
      return r((this.negative | a.negative) === 0), this.iuand(a);
    }, s.prototype.and = function(a) {
      return this.length > a.length ? this.clone().iand(a) : a.clone().iand(this);
    }, s.prototype.uand = function(a) {
      return this.length > a.length ? this.clone().iuand(a) : a.clone().iuand(this);
    }, s.prototype.iuxor = function(a) {
      var h, p;
      this.length > a.length ? (h = this, p = a) : (h = a, p = this);
      for (var y = 0; y < p.length; y++)
        this.words[y] = h.words[y] ^ p.words[y];
      if (this !== h)
        for (; y < h.length; y++)
          this.words[y] = h.words[y];
      return this.length = h.length, this._strip();
    }, s.prototype.ixor = function(a) {
      return r((this.negative | a.negative) === 0), this.iuxor(a);
    }, s.prototype.xor = function(a) {
      return this.length > a.length ? this.clone().ixor(a) : a.clone().ixor(this);
    }, s.prototype.uxor = function(a) {
      return this.length > a.length ? this.clone().iuxor(a) : a.clone().iuxor(this);
    }, s.prototype.inotn = function(a) {
      r(typeof a == "number" && a >= 0);
      var h = Math.ceil(a / 26) | 0, p = a % 26;
      this._expand(h), p > 0 && h--;
      for (var y = 0; y < h; y++)
        this.words[y] = ~this.words[y] & 67108863;
      return p > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - p), this._strip();
    }, s.prototype.notn = function(a) {
      return this.clone().inotn(a);
    }, s.prototype.setn = function(a, h) {
      r(typeof a == "number" && a >= 0);
      var p = a / 26 | 0, y = a % 26;
      return this._expand(p + 1), h ? this.words[p] = this.words[p] | 1 << y : this.words[p] = this.words[p] & ~(1 << y), this._strip();
    }, s.prototype.iadd = function(a) {
      var h;
      if (this.negative !== 0 && a.negative === 0)
        return this.negative = 0, h = this.isub(a), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && a.negative !== 0)
        return a.negative = 0, h = this.isub(a), a.negative = 1, h._normSign();
      var p, y;
      this.length > a.length ? (p = this, y = a) : (p = a, y = this);
      for (var A = 0, B = 0; B < y.length; B++)
        h = (p.words[B] | 0) + (y.words[B] | 0) + A, this.words[B] = h & 67108863, A = h >>> 26;
      for (; A !== 0 && B < p.length; B++)
        h = (p.words[B] | 0) + A, this.words[B] = h & 67108863, A = h >>> 26;
      if (this.length = p.length, A !== 0)
        this.words[this.length] = A, this.length++;
      else if (p !== this)
        for (; B < p.length; B++)
          this.words[B] = p.words[B];
      return this;
    }, s.prototype.add = function(a) {
      var h;
      return a.negative !== 0 && this.negative === 0 ? (a.negative = 0, h = this.sub(a), a.negative ^= 1, h) : a.negative === 0 && this.negative !== 0 ? (this.negative = 0, h = a.sub(this), this.negative = 1, h) : this.length > a.length ? this.clone().iadd(a) : a.clone().iadd(this);
    }, s.prototype.isub = function(a) {
      if (a.negative !== 0) {
        a.negative = 0;
        var h = this.iadd(a);
        return a.negative = 1, h._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(a), this.negative = 1, this._normSign();
      var p = this.cmp(a);
      if (p === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, A;
      p > 0 ? (y = this, A = a) : (y = a, A = this);
      for (var B = 0, C = 0; C < A.length; C++)
        h = (y.words[C] | 0) - (A.words[C] | 0) + B, B = h >> 26, this.words[C] = h & 67108863;
      for (; B !== 0 && C < y.length; C++)
        h = (y.words[C] | 0) + B, B = h >> 26, this.words[C] = h & 67108863;
      if (B === 0 && C < y.length && y !== this)
        for (; C < y.length; C++)
          this.words[C] = y.words[C];
      return this.length = Math.max(this.length, C), y !== this && (this.negative = 1), this._strip();
    }, s.prototype.sub = function(a) {
      return this.clone().isub(a);
    };
    function O(M, a, h) {
      h.negative = a.negative ^ M.negative;
      var p = M.length + a.length | 0;
      h.length = p, p = p - 1 | 0;
      var y = M.words[0] | 0, A = a.words[0] | 0, B = y * A, C = B & 67108863, b = B / 67108864 | 0;
      h.words[0] = C;
      for (var l = 1; l < p; l++) {
        for (var E = b >>> 26, Q = b & 67108863, q = Math.min(l, a.length - 1), Z = Math.max(0, l - M.length + 1); Z <= q; Z++) {
          var pt = l - Z | 0;
          y = M.words[pt] | 0, A = a.words[Z] | 0, B = y * A + Q, E += B / 67108864 | 0, Q = B & 67108863;
        }
        h.words[l] = Q | 0, b = E | 0;
      }
      return b !== 0 ? h.words[l] = b | 0 : h.length--, h._strip();
    }
    var _ = function(a, h, p) {
      var y = a.words, A = h.words, B = p.words, C = 0, b, l, E, Q = y[0] | 0, q = Q & 8191, Z = Q >>> 13, pt = y[1] | 0, nt = pt & 8191, at = pt >>> 13, Qt = y[2] | 0, yt = Qt & 8191, ct = Qt >>> 13, Kt = y[3] | 0, At = Kt & 8191, It = Kt >>> 13, Qn = y[4] | 0, St = Qn & 8191, Pt = Qn >>> 13, Kn = y[5] | 0, Ut = Kn & 8191, Mt = Kn >>> 13, pe = y[6] | 0, Ct = pe & 8191, kt = pe >>> 13, Ie = y[7] | 0, Nt = Ie & 8191, m = Ie >>> 13, c = y[8] | 0, f = c & 8191, x = c >>> 13, U = y[9] | 0, F = U & 8191, L = U >>> 13, ht = A[0] | 0, ft = ht & 8191, ut = ht >>> 13, Rt = A[1] | 0, st = Rt & 8191, qt = Rt >>> 13, Ko = A[2] | 0, jt = Ko & 8191, Yt = Ko >>> 13, qo = A[3] | 0, Zt = qo & 8191, Jt = qo >>> 13, jo = A[4] | 0, Xt = jo & 8191, Wt = jo >>> 13, Yo = A[5] | 0, $t = Yo & 8191, te = Yo >>> 13, Zo = A[6] | 0, ee = Zo & 8191, ne = Zo >>> 13, Jo = A[7] | 0, re = Jo & 8191, ie = Jo >>> 13, Xo = A[8] | 0, se = Xo & 8191, oe = Xo >>> 13, Wo = A[9] | 0, ae = Wo & 8191, ue = Wo >>> 13;
      p.negative = a.negative ^ h.negative, p.length = 19, b = Math.imul(q, ft), l = Math.imul(q, ut), l = l + Math.imul(Z, ft) | 0, E = Math.imul(Z, ut);
      var Gi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Gi >>> 26) | 0, Gi &= 67108863, b = Math.imul(nt, ft), l = Math.imul(nt, ut), l = l + Math.imul(at, ft) | 0, E = Math.imul(at, ut), b = b + Math.imul(q, st) | 0, l = l + Math.imul(q, qt) | 0, l = l + Math.imul(Z, st) | 0, E = E + Math.imul(Z, qt) | 0;
      var zi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (zi >>> 26) | 0, zi &= 67108863, b = Math.imul(yt, ft), l = Math.imul(yt, ut), l = l + Math.imul(ct, ft) | 0, E = Math.imul(ct, ut), b = b + Math.imul(nt, st) | 0, l = l + Math.imul(nt, qt) | 0, l = l + Math.imul(at, st) | 0, E = E + Math.imul(at, qt) | 0, b = b + Math.imul(q, jt) | 0, l = l + Math.imul(q, Yt) | 0, l = l + Math.imul(Z, jt) | 0, E = E + Math.imul(Z, Yt) | 0;
      var Hi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Hi >>> 26) | 0, Hi &= 67108863, b = Math.imul(At, ft), l = Math.imul(At, ut), l = l + Math.imul(It, ft) | 0, E = Math.imul(It, ut), b = b + Math.imul(yt, st) | 0, l = l + Math.imul(yt, qt) | 0, l = l + Math.imul(ct, st) | 0, E = E + Math.imul(ct, qt) | 0, b = b + Math.imul(nt, jt) | 0, l = l + Math.imul(nt, Yt) | 0, l = l + Math.imul(at, jt) | 0, E = E + Math.imul(at, Yt) | 0, b = b + Math.imul(q, Zt) | 0, l = l + Math.imul(q, Jt) | 0, l = l + Math.imul(Z, Zt) | 0, E = E + Math.imul(Z, Jt) | 0;
      var Vi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Vi >>> 26) | 0, Vi &= 67108863, b = Math.imul(St, ft), l = Math.imul(St, ut), l = l + Math.imul(Pt, ft) | 0, E = Math.imul(Pt, ut), b = b + Math.imul(At, st) | 0, l = l + Math.imul(At, qt) | 0, l = l + Math.imul(It, st) | 0, E = E + Math.imul(It, qt) | 0, b = b + Math.imul(yt, jt) | 0, l = l + Math.imul(yt, Yt) | 0, l = l + Math.imul(ct, jt) | 0, E = E + Math.imul(ct, Yt) | 0, b = b + Math.imul(nt, Zt) | 0, l = l + Math.imul(nt, Jt) | 0, l = l + Math.imul(at, Zt) | 0, E = E + Math.imul(at, Jt) | 0, b = b + Math.imul(q, Xt) | 0, l = l + Math.imul(q, Wt) | 0, l = l + Math.imul(Z, Xt) | 0, E = E + Math.imul(Z, Wt) | 0;
      var Qi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Qi >>> 26) | 0, Qi &= 67108863, b = Math.imul(Ut, ft), l = Math.imul(Ut, ut), l = l + Math.imul(Mt, ft) | 0, E = Math.imul(Mt, ut), b = b + Math.imul(St, st) | 0, l = l + Math.imul(St, qt) | 0, l = l + Math.imul(Pt, st) | 0, E = E + Math.imul(Pt, qt) | 0, b = b + Math.imul(At, jt) | 0, l = l + Math.imul(At, Yt) | 0, l = l + Math.imul(It, jt) | 0, E = E + Math.imul(It, Yt) | 0, b = b + Math.imul(yt, Zt) | 0, l = l + Math.imul(yt, Jt) | 0, l = l + Math.imul(ct, Zt) | 0, E = E + Math.imul(ct, Jt) | 0, b = b + Math.imul(nt, Xt) | 0, l = l + Math.imul(nt, Wt) | 0, l = l + Math.imul(at, Xt) | 0, E = E + Math.imul(at, Wt) | 0, b = b + Math.imul(q, $t) | 0, l = l + Math.imul(q, te) | 0, l = l + Math.imul(Z, $t) | 0, E = E + Math.imul(Z, te) | 0;
      var Ki = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Ki >>> 26) | 0, Ki &= 67108863, b = Math.imul(Ct, ft), l = Math.imul(Ct, ut), l = l + Math.imul(kt, ft) | 0, E = Math.imul(kt, ut), b = b + Math.imul(Ut, st) | 0, l = l + Math.imul(Ut, qt) | 0, l = l + Math.imul(Mt, st) | 0, E = E + Math.imul(Mt, qt) | 0, b = b + Math.imul(St, jt) | 0, l = l + Math.imul(St, Yt) | 0, l = l + Math.imul(Pt, jt) | 0, E = E + Math.imul(Pt, Yt) | 0, b = b + Math.imul(At, Zt) | 0, l = l + Math.imul(At, Jt) | 0, l = l + Math.imul(It, Zt) | 0, E = E + Math.imul(It, Jt) | 0, b = b + Math.imul(yt, Xt) | 0, l = l + Math.imul(yt, Wt) | 0, l = l + Math.imul(ct, Xt) | 0, E = E + Math.imul(ct, Wt) | 0, b = b + Math.imul(nt, $t) | 0, l = l + Math.imul(nt, te) | 0, l = l + Math.imul(at, $t) | 0, E = E + Math.imul(at, te) | 0, b = b + Math.imul(q, ee) | 0, l = l + Math.imul(q, ne) | 0, l = l + Math.imul(Z, ee) | 0, E = E + Math.imul(Z, ne) | 0;
      var qi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (qi >>> 26) | 0, qi &= 67108863, b = Math.imul(Nt, ft), l = Math.imul(Nt, ut), l = l + Math.imul(m, ft) | 0, E = Math.imul(m, ut), b = b + Math.imul(Ct, st) | 0, l = l + Math.imul(Ct, qt) | 0, l = l + Math.imul(kt, st) | 0, E = E + Math.imul(kt, qt) | 0, b = b + Math.imul(Ut, jt) | 0, l = l + Math.imul(Ut, Yt) | 0, l = l + Math.imul(Mt, jt) | 0, E = E + Math.imul(Mt, Yt) | 0, b = b + Math.imul(St, Zt) | 0, l = l + Math.imul(St, Jt) | 0, l = l + Math.imul(Pt, Zt) | 0, E = E + Math.imul(Pt, Jt) | 0, b = b + Math.imul(At, Xt) | 0, l = l + Math.imul(At, Wt) | 0, l = l + Math.imul(It, Xt) | 0, E = E + Math.imul(It, Wt) | 0, b = b + Math.imul(yt, $t) | 0, l = l + Math.imul(yt, te) | 0, l = l + Math.imul(ct, $t) | 0, E = E + Math.imul(ct, te) | 0, b = b + Math.imul(nt, ee) | 0, l = l + Math.imul(nt, ne) | 0, l = l + Math.imul(at, ee) | 0, E = E + Math.imul(at, ne) | 0, b = b + Math.imul(q, re) | 0, l = l + Math.imul(q, ie) | 0, l = l + Math.imul(Z, re) | 0, E = E + Math.imul(Z, ie) | 0;
      var ji = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (ji >>> 26) | 0, ji &= 67108863, b = Math.imul(f, ft), l = Math.imul(f, ut), l = l + Math.imul(x, ft) | 0, E = Math.imul(x, ut), b = b + Math.imul(Nt, st) | 0, l = l + Math.imul(Nt, qt) | 0, l = l + Math.imul(m, st) | 0, E = E + Math.imul(m, qt) | 0, b = b + Math.imul(Ct, jt) | 0, l = l + Math.imul(Ct, Yt) | 0, l = l + Math.imul(kt, jt) | 0, E = E + Math.imul(kt, Yt) | 0, b = b + Math.imul(Ut, Zt) | 0, l = l + Math.imul(Ut, Jt) | 0, l = l + Math.imul(Mt, Zt) | 0, E = E + Math.imul(Mt, Jt) | 0, b = b + Math.imul(St, Xt) | 0, l = l + Math.imul(St, Wt) | 0, l = l + Math.imul(Pt, Xt) | 0, E = E + Math.imul(Pt, Wt) | 0, b = b + Math.imul(At, $t) | 0, l = l + Math.imul(At, te) | 0, l = l + Math.imul(It, $t) | 0, E = E + Math.imul(It, te) | 0, b = b + Math.imul(yt, ee) | 0, l = l + Math.imul(yt, ne) | 0, l = l + Math.imul(ct, ee) | 0, E = E + Math.imul(ct, ne) | 0, b = b + Math.imul(nt, re) | 0, l = l + Math.imul(nt, ie) | 0, l = l + Math.imul(at, re) | 0, E = E + Math.imul(at, ie) | 0, b = b + Math.imul(q, se) | 0, l = l + Math.imul(q, oe) | 0, l = l + Math.imul(Z, se) | 0, E = E + Math.imul(Z, oe) | 0;
      var Yi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Yi >>> 26) | 0, Yi &= 67108863, b = Math.imul(F, ft), l = Math.imul(F, ut), l = l + Math.imul(L, ft) | 0, E = Math.imul(L, ut), b = b + Math.imul(f, st) | 0, l = l + Math.imul(f, qt) | 0, l = l + Math.imul(x, st) | 0, E = E + Math.imul(x, qt) | 0, b = b + Math.imul(Nt, jt) | 0, l = l + Math.imul(Nt, Yt) | 0, l = l + Math.imul(m, jt) | 0, E = E + Math.imul(m, Yt) | 0, b = b + Math.imul(Ct, Zt) | 0, l = l + Math.imul(Ct, Jt) | 0, l = l + Math.imul(kt, Zt) | 0, E = E + Math.imul(kt, Jt) | 0, b = b + Math.imul(Ut, Xt) | 0, l = l + Math.imul(Ut, Wt) | 0, l = l + Math.imul(Mt, Xt) | 0, E = E + Math.imul(Mt, Wt) | 0, b = b + Math.imul(St, $t) | 0, l = l + Math.imul(St, te) | 0, l = l + Math.imul(Pt, $t) | 0, E = E + Math.imul(Pt, te) | 0, b = b + Math.imul(At, ee) | 0, l = l + Math.imul(At, ne) | 0, l = l + Math.imul(It, ee) | 0, E = E + Math.imul(It, ne) | 0, b = b + Math.imul(yt, re) | 0, l = l + Math.imul(yt, ie) | 0, l = l + Math.imul(ct, re) | 0, E = E + Math.imul(ct, ie) | 0, b = b + Math.imul(nt, se) | 0, l = l + Math.imul(nt, oe) | 0, l = l + Math.imul(at, se) | 0, E = E + Math.imul(at, oe) | 0, b = b + Math.imul(q, ae) | 0, l = l + Math.imul(q, ue) | 0, l = l + Math.imul(Z, ae) | 0, E = E + Math.imul(Z, ue) | 0;
      var Zi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Zi >>> 26) | 0, Zi &= 67108863, b = Math.imul(F, st), l = Math.imul(F, qt), l = l + Math.imul(L, st) | 0, E = Math.imul(L, qt), b = b + Math.imul(f, jt) | 0, l = l + Math.imul(f, Yt) | 0, l = l + Math.imul(x, jt) | 0, E = E + Math.imul(x, Yt) | 0, b = b + Math.imul(Nt, Zt) | 0, l = l + Math.imul(Nt, Jt) | 0, l = l + Math.imul(m, Zt) | 0, E = E + Math.imul(m, Jt) | 0, b = b + Math.imul(Ct, Xt) | 0, l = l + Math.imul(Ct, Wt) | 0, l = l + Math.imul(kt, Xt) | 0, E = E + Math.imul(kt, Wt) | 0, b = b + Math.imul(Ut, $t) | 0, l = l + Math.imul(Ut, te) | 0, l = l + Math.imul(Mt, $t) | 0, E = E + Math.imul(Mt, te) | 0, b = b + Math.imul(St, ee) | 0, l = l + Math.imul(St, ne) | 0, l = l + Math.imul(Pt, ee) | 0, E = E + Math.imul(Pt, ne) | 0, b = b + Math.imul(At, re) | 0, l = l + Math.imul(At, ie) | 0, l = l + Math.imul(It, re) | 0, E = E + Math.imul(It, ie) | 0, b = b + Math.imul(yt, se) | 0, l = l + Math.imul(yt, oe) | 0, l = l + Math.imul(ct, se) | 0, E = E + Math.imul(ct, oe) | 0, b = b + Math.imul(nt, ae) | 0, l = l + Math.imul(nt, ue) | 0, l = l + Math.imul(at, ae) | 0, E = E + Math.imul(at, ue) | 0;
      var Ji = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Ji >>> 26) | 0, Ji &= 67108863, b = Math.imul(F, jt), l = Math.imul(F, Yt), l = l + Math.imul(L, jt) | 0, E = Math.imul(L, Yt), b = b + Math.imul(f, Zt) | 0, l = l + Math.imul(f, Jt) | 0, l = l + Math.imul(x, Zt) | 0, E = E + Math.imul(x, Jt) | 0, b = b + Math.imul(Nt, Xt) | 0, l = l + Math.imul(Nt, Wt) | 0, l = l + Math.imul(m, Xt) | 0, E = E + Math.imul(m, Wt) | 0, b = b + Math.imul(Ct, $t) | 0, l = l + Math.imul(Ct, te) | 0, l = l + Math.imul(kt, $t) | 0, E = E + Math.imul(kt, te) | 0, b = b + Math.imul(Ut, ee) | 0, l = l + Math.imul(Ut, ne) | 0, l = l + Math.imul(Mt, ee) | 0, E = E + Math.imul(Mt, ne) | 0, b = b + Math.imul(St, re) | 0, l = l + Math.imul(St, ie) | 0, l = l + Math.imul(Pt, re) | 0, E = E + Math.imul(Pt, ie) | 0, b = b + Math.imul(At, se) | 0, l = l + Math.imul(At, oe) | 0, l = l + Math.imul(It, se) | 0, E = E + Math.imul(It, oe) | 0, b = b + Math.imul(yt, ae) | 0, l = l + Math.imul(yt, ue) | 0, l = l + Math.imul(ct, ae) | 0, E = E + Math.imul(ct, ue) | 0;
      var Xi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Xi >>> 26) | 0, Xi &= 67108863, b = Math.imul(F, Zt), l = Math.imul(F, Jt), l = l + Math.imul(L, Zt) | 0, E = Math.imul(L, Jt), b = b + Math.imul(f, Xt) | 0, l = l + Math.imul(f, Wt) | 0, l = l + Math.imul(x, Xt) | 0, E = E + Math.imul(x, Wt) | 0, b = b + Math.imul(Nt, $t) | 0, l = l + Math.imul(Nt, te) | 0, l = l + Math.imul(m, $t) | 0, E = E + Math.imul(m, te) | 0, b = b + Math.imul(Ct, ee) | 0, l = l + Math.imul(Ct, ne) | 0, l = l + Math.imul(kt, ee) | 0, E = E + Math.imul(kt, ne) | 0, b = b + Math.imul(Ut, re) | 0, l = l + Math.imul(Ut, ie) | 0, l = l + Math.imul(Mt, re) | 0, E = E + Math.imul(Mt, ie) | 0, b = b + Math.imul(St, se) | 0, l = l + Math.imul(St, oe) | 0, l = l + Math.imul(Pt, se) | 0, E = E + Math.imul(Pt, oe) | 0, b = b + Math.imul(At, ae) | 0, l = l + Math.imul(At, ue) | 0, l = l + Math.imul(It, ae) | 0, E = E + Math.imul(It, ue) | 0;
      var Wi = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (Wi >>> 26) | 0, Wi &= 67108863, b = Math.imul(F, Xt), l = Math.imul(F, Wt), l = l + Math.imul(L, Xt) | 0, E = Math.imul(L, Wt), b = b + Math.imul(f, $t) | 0, l = l + Math.imul(f, te) | 0, l = l + Math.imul(x, $t) | 0, E = E + Math.imul(x, te) | 0, b = b + Math.imul(Nt, ee) | 0, l = l + Math.imul(Nt, ne) | 0, l = l + Math.imul(m, ee) | 0, E = E + Math.imul(m, ne) | 0, b = b + Math.imul(Ct, re) | 0, l = l + Math.imul(Ct, ie) | 0, l = l + Math.imul(kt, re) | 0, E = E + Math.imul(kt, ie) | 0, b = b + Math.imul(Ut, se) | 0, l = l + Math.imul(Ut, oe) | 0, l = l + Math.imul(Mt, se) | 0, E = E + Math.imul(Mt, oe) | 0, b = b + Math.imul(St, ae) | 0, l = l + Math.imul(St, ue) | 0, l = l + Math.imul(Pt, ae) | 0, E = E + Math.imul(Pt, ue) | 0;
      var $i = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + ($i >>> 26) | 0, $i &= 67108863, b = Math.imul(F, $t), l = Math.imul(F, te), l = l + Math.imul(L, $t) | 0, E = Math.imul(L, te), b = b + Math.imul(f, ee) | 0, l = l + Math.imul(f, ne) | 0, l = l + Math.imul(x, ee) | 0, E = E + Math.imul(x, ne) | 0, b = b + Math.imul(Nt, re) | 0, l = l + Math.imul(Nt, ie) | 0, l = l + Math.imul(m, re) | 0, E = E + Math.imul(m, ie) | 0, b = b + Math.imul(Ct, se) | 0, l = l + Math.imul(Ct, oe) | 0, l = l + Math.imul(kt, se) | 0, E = E + Math.imul(kt, oe) | 0, b = b + Math.imul(Ut, ae) | 0, l = l + Math.imul(Ut, ue) | 0, l = l + Math.imul(Mt, ae) | 0, E = E + Math.imul(Mt, ue) | 0;
      var ts = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (ts >>> 26) | 0, ts &= 67108863, b = Math.imul(F, ee), l = Math.imul(F, ne), l = l + Math.imul(L, ee) | 0, E = Math.imul(L, ne), b = b + Math.imul(f, re) | 0, l = l + Math.imul(f, ie) | 0, l = l + Math.imul(x, re) | 0, E = E + Math.imul(x, ie) | 0, b = b + Math.imul(Nt, se) | 0, l = l + Math.imul(Nt, oe) | 0, l = l + Math.imul(m, se) | 0, E = E + Math.imul(m, oe) | 0, b = b + Math.imul(Ct, ae) | 0, l = l + Math.imul(Ct, ue) | 0, l = l + Math.imul(kt, ae) | 0, E = E + Math.imul(kt, ue) | 0;
      var es = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (es >>> 26) | 0, es &= 67108863, b = Math.imul(F, re), l = Math.imul(F, ie), l = l + Math.imul(L, re) | 0, E = Math.imul(L, ie), b = b + Math.imul(f, se) | 0, l = l + Math.imul(f, oe) | 0, l = l + Math.imul(x, se) | 0, E = E + Math.imul(x, oe) | 0, b = b + Math.imul(Nt, ae) | 0, l = l + Math.imul(Nt, ue) | 0, l = l + Math.imul(m, ae) | 0, E = E + Math.imul(m, ue) | 0;
      var ns = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (ns >>> 26) | 0, ns &= 67108863, b = Math.imul(F, se), l = Math.imul(F, oe), l = l + Math.imul(L, se) | 0, E = Math.imul(L, oe), b = b + Math.imul(f, ae) | 0, l = l + Math.imul(f, ue) | 0, l = l + Math.imul(x, ae) | 0, E = E + Math.imul(x, ue) | 0;
      var rs = (C + b | 0) + ((l & 8191) << 13) | 0;
      C = (E + (l >>> 13) | 0) + (rs >>> 26) | 0, rs &= 67108863, b = Math.imul(F, ae), l = Math.imul(F, ue), l = l + Math.imul(L, ae) | 0, E = Math.imul(L, ue);
      var is = (C + b | 0) + ((l & 8191) << 13) | 0;
      return C = (E + (l >>> 13) | 0) + (is >>> 26) | 0, is &= 67108863, B[0] = Gi, B[1] = zi, B[2] = Hi, B[3] = Vi, B[4] = Qi, B[5] = Ki, B[6] = qi, B[7] = ji, B[8] = Yi, B[9] = Zi, B[10] = Ji, B[11] = Xi, B[12] = Wi, B[13] = $i, B[14] = ts, B[15] = es, B[16] = ns, B[17] = rs, B[18] = is, C !== 0 && (B[19] = C, p.length++), p;
    };
    Math.imul || (_ = O);
    function k(M, a, h) {
      h.negative = a.negative ^ M.negative, h.length = M.length + a.length;
      for (var p = 0, y = 0, A = 0; A < h.length - 1; A++) {
        var B = y;
        y = 0;
        for (var C = p & 67108863, b = Math.min(A, a.length - 1), l = Math.max(0, A - M.length + 1); l <= b; l++) {
          var E = A - l, Q = M.words[E] | 0, q = a.words[l] | 0, Z = Q * q, pt = Z & 67108863;
          B = B + (Z / 67108864 | 0) | 0, pt = pt + C | 0, C = pt & 67108863, B = B + (pt >>> 26) | 0, y += B >>> 26, B &= 67108863;
        }
        h.words[A] = C, p = B, B = y;
      }
      return p !== 0 ? h.words[A] = p : h.length--, h._strip();
    }
    function V(M, a, h) {
      return k(M, a, h);
    }
    s.prototype.mulTo = function(a, h) {
      var p, y = this.length + a.length;
      return this.length === 10 && a.length === 10 ? p = _(this, a, h) : y < 63 ? p = O(this, a, h) : y < 1024 ? p = k(this, a, h) : p = V(this, a, h), p;
    }, s.prototype.mul = function(a) {
      var h = new s(null);
      return h.words = new Array(this.length + a.length), this.mulTo(a, h);
    }, s.prototype.mulf = function(a) {
      var h = new s(null);
      return h.words = new Array(this.length + a.length), V(this, a, h);
    }, s.prototype.imul = function(a) {
      return this.clone().mulTo(a, this);
    }, s.prototype.imuln = function(a) {
      var h = a < 0;
      h && (a = -a), r(typeof a == "number"), r(a < 67108864);
      for (var p = 0, y = 0; y < this.length; y++) {
        var A = (this.words[y] | 0) * a, B = (A & 67108863) + (p & 67108863);
        p >>= 26, p += A / 67108864 | 0, p += B >>> 26, this.words[y] = B & 67108863;
      }
      return p !== 0 && (this.words[y] = p, this.length++), h ? this.ineg() : this;
    }, s.prototype.muln = function(a) {
      return this.clone().imuln(a);
    }, s.prototype.sqr = function() {
      return this.mul(this);
    }, s.prototype.isqr = function() {
      return this.imul(this.clone());
    }, s.prototype.pow = function(a) {
      var h = T(a);
      if (h.length === 0)
        return new s(1);
      for (var p = this, y = 0; y < h.length && h[y] === 0; y++, p = p.sqr())
        ;
      if (++y < h.length)
        for (var A = p.sqr(); y < h.length; y++, A = A.sqr())
          h[y] !== 0 && (p = p.mul(A));
      return p;
    }, s.prototype.iushln = function(a) {
      r(typeof a == "number" && a >= 0);
      var h = a % 26, p = (a - h) / 26, y = 67108863 >>> 26 - h << 26 - h, A;
      if (h !== 0) {
        var B = 0;
        for (A = 0; A < this.length; A++) {
          var C = this.words[A] & y, b = (this.words[A] | 0) - C << h;
          this.words[A] = b | B, B = C >>> 26 - h;
        }
        B && (this.words[A] = B, this.length++);
      }
      if (p !== 0) {
        for (A = this.length - 1; A >= 0; A--)
          this.words[A + p] = this.words[A];
        for (A = 0; A < p; A++)
          this.words[A] = 0;
        this.length += p;
      }
      return this._strip();
    }, s.prototype.ishln = function(a) {
      return r(this.negative === 0), this.iushln(a);
    }, s.prototype.iushrn = function(a, h, p) {
      r(typeof a == "number" && a >= 0);
      var y;
      h ? y = (h - h % 26) / 26 : y = 0;
      var A = a % 26, B = Math.min((a - A) / 26, this.length), C = 67108863 ^ 67108863 >>> A << A, b = p;
      if (y -= B, y = Math.max(0, y), b) {
        for (var l = 0; l < B; l++)
          b.words[l] = this.words[l];
        b.length = B;
      }
      if (B !== 0)
        if (this.length > B)
          for (this.length -= B, l = 0; l < this.length; l++)
            this.words[l] = this.words[l + B];
        else
          this.words[0] = 0, this.length = 1;
      var E = 0;
      for (l = this.length - 1; l >= 0 && (E !== 0 || l >= y); l--) {
        var Q = this.words[l] | 0;
        this.words[l] = E << 26 - A | Q >>> A, E = Q & C;
      }
      return b && E !== 0 && (b.words[b.length++] = E), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, s.prototype.ishrn = function(a, h, p) {
      return r(this.negative === 0), this.iushrn(a, h, p);
    }, s.prototype.shln = function(a) {
      return this.clone().ishln(a);
    }, s.prototype.ushln = function(a) {
      return this.clone().iushln(a);
    }, s.prototype.shrn = function(a) {
      return this.clone().ishrn(a);
    }, s.prototype.ushrn = function(a) {
      return this.clone().iushrn(a);
    }, s.prototype.testn = function(a) {
      r(typeof a == "number" && a >= 0);
      var h = a % 26, p = (a - h) / 26, y = 1 << h;
      if (this.length <= p)
        return !1;
      var A = this.words[p];
      return !!(A & y);
    }, s.prototype.imaskn = function(a) {
      r(typeof a == "number" && a >= 0);
      var h = a % 26, p = (a - h) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= p)
        return this;
      if (h !== 0 && p++, this.length = Math.min(p, this.length), h !== 0) {
        var y = 67108863 ^ 67108863 >>> h << h;
        this.words[this.length - 1] &= y;
      }
      return this._strip();
    }, s.prototype.maskn = function(a) {
      return this.clone().imaskn(a);
    }, s.prototype.iaddn = function(a) {
      return r(typeof a == "number"), r(a < 67108864), a < 0 ? this.isubn(-a) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= a ? (this.words[0] = a - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(a), this.negative = 1, this) : this._iaddn(a);
    }, s.prototype._iaddn = function(a) {
      this.words[0] += a;
      for (var h = 0; h < this.length && this.words[h] >= 67108864; h++)
        this.words[h] -= 67108864, h === this.length - 1 ? this.words[h + 1] = 1 : this.words[h + 1]++;
      return this.length = Math.max(this.length, h + 1), this;
    }, s.prototype.isubn = function(a) {
      if (r(typeof a == "number"), r(a < 67108864), a < 0)
        return this.iaddn(-a);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(a), this.negative = 1, this;
      if (this.words[0] -= a, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var h = 0; h < this.length && this.words[h] < 0; h++)
          this.words[h] += 67108864, this.words[h + 1] -= 1;
      return this._strip();
    }, s.prototype.addn = function(a) {
      return this.clone().iaddn(a);
    }, s.prototype.subn = function(a) {
      return this.clone().isubn(a);
    }, s.prototype.iabs = function() {
      return this.negative = 0, this;
    }, s.prototype.abs = function() {
      return this.clone().iabs();
    }, s.prototype._ishlnsubmul = function(a, h, p) {
      var y = a.length + p, A;
      this._expand(y);
      var B, C = 0;
      for (A = 0; A < a.length; A++) {
        B = (this.words[A + p] | 0) + C;
        var b = (a.words[A] | 0) * h;
        B -= b & 67108863, C = (B >> 26) - (b / 67108864 | 0), this.words[A + p] = B & 67108863;
      }
      for (; A < this.length - p; A++)
        B = (this.words[A + p] | 0) + C, C = B >> 26, this.words[A + p] = B & 67108863;
      if (C === 0)
        return this._strip();
      for (r(C === -1), C = 0, A = 0; A < this.length; A++)
        B = -(this.words[A] | 0) + C, C = B >> 26, this.words[A] = B & 67108863;
      return this.negative = 1, this._strip();
    }, s.prototype._wordDiv = function(a, h) {
      var p = this.length - a.length, y = this.clone(), A = a, B = A.words[A.length - 1] | 0, C = this._countBits(B);
      p = 26 - C, p !== 0 && (A = A.ushln(p), y.iushln(p), B = A.words[A.length - 1] | 0);
      var b = y.length - A.length, l;
      if (h !== "mod") {
        l = new s(null), l.length = b + 1, l.words = new Array(l.length);
        for (var E = 0; E < l.length; E++)
          l.words[E] = 0;
      }
      var Q = y.clone()._ishlnsubmul(A, 1, b);
      Q.negative === 0 && (y = Q, l && (l.words[b] = 1));
      for (var q = b - 1; q >= 0; q--) {
        var Z = (y.words[A.length + q] | 0) * 67108864 + (y.words[A.length + q - 1] | 0);
        for (Z = Math.min(Z / B | 0, 67108863), y._ishlnsubmul(A, Z, q); y.negative !== 0; )
          Z--, y.negative = 0, y._ishlnsubmul(A, 1, q), y.isZero() || (y.negative ^= 1);
        l && (l.words[q] = Z);
      }
      return l && l._strip(), y._strip(), h !== "div" && p !== 0 && y.iushrn(p), {
        div: l || null,
        mod: y
      };
    }, s.prototype.divmod = function(a, h, p) {
      if (r(!a.isZero()), this.isZero())
        return {
          div: new s(0),
          mod: new s(0)
        };
      var y, A, B;
      return this.negative !== 0 && a.negative === 0 ? (B = this.neg().divmod(a, h), h !== "mod" && (y = B.div.neg()), h !== "div" && (A = B.mod.neg(), p && A.negative !== 0 && A.iadd(a)), {
        div: y,
        mod: A
      }) : this.negative === 0 && a.negative !== 0 ? (B = this.divmod(a.neg(), h), h !== "mod" && (y = B.div.neg()), {
        div: y,
        mod: B.mod
      }) : this.negative & a.negative ? (B = this.neg().divmod(a.neg(), h), h !== "div" && (A = B.mod.neg(), p && A.negative !== 0 && A.isub(a)), {
        div: B.div,
        mod: A
      }) : a.length > this.length || this.cmp(a) < 0 ? {
        div: new s(0),
        mod: this
      } : a.length === 1 ? h === "div" ? {
        div: this.divn(a.words[0]),
        mod: null
      } : h === "mod" ? {
        div: null,
        mod: new s(this.modrn(a.words[0]))
      } : {
        div: this.divn(a.words[0]),
        mod: new s(this.modrn(a.words[0]))
      } : this._wordDiv(a, h);
    }, s.prototype.div = function(a) {
      return this.divmod(a, "div", !1).div;
    }, s.prototype.mod = function(a) {
      return this.divmod(a, "mod", !1).mod;
    }, s.prototype.umod = function(a) {
      return this.divmod(a, "mod", !0).mod;
    }, s.prototype.divRound = function(a) {
      var h = this.divmod(a);
      if (h.mod.isZero())
        return h.div;
      var p = h.div.negative !== 0 ? h.mod.isub(a) : h.mod, y = a.ushrn(1), A = a.andln(1), B = p.cmp(y);
      return B < 0 || A === 1 && B === 0 ? h.div : h.div.negative !== 0 ? h.div.isubn(1) : h.div.iaddn(1);
    }, s.prototype.modrn = function(a) {
      var h = a < 0;
      h && (a = -a), r(a <= 67108863);
      for (var p = (1 << 26) % a, y = 0, A = this.length - 1; A >= 0; A--)
        y = (p * y + (this.words[A] | 0)) % a;
      return h ? -y : y;
    }, s.prototype.modn = function(a) {
      return this.modrn(a);
    }, s.prototype.idivn = function(a) {
      var h = a < 0;
      h && (a = -a), r(a <= 67108863);
      for (var p = 0, y = this.length - 1; y >= 0; y--) {
        var A = (this.words[y] | 0) + p * 67108864;
        this.words[y] = A / a | 0, p = A % a;
      }
      return this._strip(), h ? this.ineg() : this;
    }, s.prototype.divn = function(a) {
      return this.clone().idivn(a);
    }, s.prototype.egcd = function(a) {
      r(a.negative === 0), r(!a.isZero());
      var h = this, p = a.clone();
      h.negative !== 0 ? h = h.umod(a) : h = h.clone();
      for (var y = new s(1), A = new s(0), B = new s(0), C = new s(1), b = 0; h.isEven() && p.isEven(); )
        h.iushrn(1), p.iushrn(1), ++b;
      for (var l = p.clone(), E = h.clone(); !h.isZero(); ) {
        for (var Q = 0, q = 1; !(h.words[0] & q) && Q < 26; ++Q, q <<= 1)
          ;
        if (Q > 0)
          for (h.iushrn(Q); Q-- > 0; )
            (y.isOdd() || A.isOdd()) && (y.iadd(l), A.isub(E)), y.iushrn(1), A.iushrn(1);
        for (var Z = 0, pt = 1; !(p.words[0] & pt) && Z < 26; ++Z, pt <<= 1)
          ;
        if (Z > 0)
          for (p.iushrn(Z); Z-- > 0; )
            (B.isOdd() || C.isOdd()) && (B.iadd(l), C.isub(E)), B.iushrn(1), C.iushrn(1);
        h.cmp(p) >= 0 ? (h.isub(p), y.isub(B), A.isub(C)) : (p.isub(h), B.isub(y), C.isub(A));
      }
      return {
        a: B,
        b: C,
        gcd: p.iushln(b)
      };
    }, s.prototype._invmp = function(a) {
      r(a.negative === 0), r(!a.isZero());
      var h = this, p = a.clone();
      h.negative !== 0 ? h = h.umod(a) : h = h.clone();
      for (var y = new s(1), A = new s(0), B = p.clone(); h.cmpn(1) > 0 && p.cmpn(1) > 0; ) {
        for (var C = 0, b = 1; !(h.words[0] & b) && C < 26; ++C, b <<= 1)
          ;
        if (C > 0)
          for (h.iushrn(C); C-- > 0; )
            y.isOdd() && y.iadd(B), y.iushrn(1);
        for (var l = 0, E = 1; !(p.words[0] & E) && l < 26; ++l, E <<= 1)
          ;
        if (l > 0)
          for (p.iushrn(l); l-- > 0; )
            A.isOdd() && A.iadd(B), A.iushrn(1);
        h.cmp(p) >= 0 ? (h.isub(p), y.isub(A)) : (p.isub(h), A.isub(y));
      }
      var Q;
      return h.cmpn(1) === 0 ? Q = y : Q = A, Q.cmpn(0) < 0 && Q.iadd(a), Q;
    }, s.prototype.gcd = function(a) {
      if (this.isZero())
        return a.abs();
      if (a.isZero())
        return this.abs();
      var h = this.clone(), p = a.clone();
      h.negative = 0, p.negative = 0;
      for (var y = 0; h.isEven() && p.isEven(); y++)
        h.iushrn(1), p.iushrn(1);
      do {
        for (; h.isEven(); )
          h.iushrn(1);
        for (; p.isEven(); )
          p.iushrn(1);
        var A = h.cmp(p);
        if (A < 0) {
          var B = h;
          h = p, p = B;
        } else if (A === 0 || p.cmpn(1) === 0)
          break;
        h.isub(p);
      } while (!0);
      return p.iushln(y);
    }, s.prototype.invm = function(a) {
      return this.egcd(a).a.umod(a);
    }, s.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, s.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, s.prototype.andln = function(a) {
      return this.words[0] & a;
    }, s.prototype.bincn = function(a) {
      r(typeof a == "number");
      var h = a % 26, p = (a - h) / 26, y = 1 << h;
      if (this.length <= p)
        return this._expand(p + 1), this.words[p] |= y, this;
      for (var A = y, B = p; A !== 0 && B < this.length; B++) {
        var C = this.words[B] | 0;
        C += A, A = C >>> 26, C &= 67108863, this.words[B] = C;
      }
      return A !== 0 && (this.words[B] = A, this.length++), this;
    }, s.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, s.prototype.cmpn = function(a) {
      var h = a < 0;
      if (this.negative !== 0 && !h)
        return -1;
      if (this.negative === 0 && h)
        return 1;
      this._strip();
      var p;
      if (this.length > 1)
        p = 1;
      else {
        h && (a = -a), r(a <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        p = y === a ? 0 : y < a ? -1 : 1;
      }
      return this.negative !== 0 ? -p | 0 : p;
    }, s.prototype.cmp = function(a) {
      if (this.negative !== 0 && a.negative === 0)
        return -1;
      if (this.negative === 0 && a.negative !== 0)
        return 1;
      var h = this.ucmp(a);
      return this.negative !== 0 ? -h | 0 : h;
    }, s.prototype.ucmp = function(a) {
      if (this.length > a.length)
        return 1;
      if (this.length < a.length)
        return -1;
      for (var h = 0, p = this.length - 1; p >= 0; p--) {
        var y = this.words[p] | 0, A = a.words[p] | 0;
        if (y !== A) {
          y < A ? h = -1 : y > A && (h = 1);
          break;
        }
      }
      return h;
    }, s.prototype.gtn = function(a) {
      return this.cmpn(a) === 1;
    }, s.prototype.gt = function(a) {
      return this.cmp(a) === 1;
    }, s.prototype.gten = function(a) {
      return this.cmpn(a) >= 0;
    }, s.prototype.gte = function(a) {
      return this.cmp(a) >= 0;
    }, s.prototype.ltn = function(a) {
      return this.cmpn(a) === -1;
    }, s.prototype.lt = function(a) {
      return this.cmp(a) === -1;
    }, s.prototype.lten = function(a) {
      return this.cmpn(a) <= 0;
    }, s.prototype.lte = function(a) {
      return this.cmp(a) <= 0;
    }, s.prototype.eqn = function(a) {
      return this.cmpn(a) === 0;
    }, s.prototype.eq = function(a) {
      return this.cmp(a) === 0;
    }, s.red = function(a) {
      return new $(a);
    }, s.prototype.toRed = function(a) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), a.convertTo(this)._forceRed(a);
    }, s.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, s.prototype._forceRed = function(a) {
      return this.red = a, this;
    }, s.prototype.forceRed = function(a) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(a);
    }, s.prototype.redAdd = function(a) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, a);
    }, s.prototype.redIAdd = function(a) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, a);
    }, s.prototype.redSub = function(a) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, a);
    }, s.prototype.redISub = function(a) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, a);
    }, s.prototype.redShl = function(a) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, a);
    }, s.prototype.redMul = function(a) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.mul(this, a);
    }, s.prototype.redIMul = function(a) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, a), this.red.imul(this, a);
    }, s.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, s.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, s.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, s.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, s.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, s.prototype.redPow = function(a) {
      return r(this.red && !a.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, a);
    };
    var H = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function z(M, a) {
      this.name = M, this.p = new s(a, 16), this.n = this.p.bitLength(), this.k = new s(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    z.prototype._tmp = function() {
      var a = new s(null);
      return a.words = new Array(Math.ceil(this.n / 13)), a;
    }, z.prototype.ireduce = function(a) {
      var h = a, p;
      do
        this.split(h, this.tmp), h = this.imulK(h), h = h.iadd(this.tmp), p = h.bitLength();
      while (p > this.n);
      var y = p < this.n ? -1 : h.ucmp(this.p);
      return y === 0 ? (h.words[0] = 0, h.length = 1) : y > 0 ? h.isub(this.p) : h.strip !== void 0 ? h.strip() : h._strip(), h;
    }, z.prototype.split = function(a, h) {
      a.iushrn(this.n, 0, h);
    }, z.prototype.imulK = function(a) {
      return a.imul(this.k);
    };
    function j() {
      z.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    i(j, z), j.prototype.split = function(a, h) {
      for (var p = 4194303, y = Math.min(a.length, 9), A = 0; A < y; A++)
        h.words[A] = a.words[A];
      if (h.length = y, a.length <= 9) {
        a.words[0] = 0, a.length = 1;
        return;
      }
      var B = a.words[9];
      for (h.words[h.length++] = B & p, A = 10; A < a.length; A++) {
        var C = a.words[A] | 0;
        a.words[A - 10] = (C & p) << 4 | B >>> 22, B = C;
      }
      B >>>= 22, a.words[A - 10] = B, B === 0 && a.length > 10 ? a.length -= 10 : a.length -= 9;
    }, j.prototype.imulK = function(a) {
      a.words[a.length] = 0, a.words[a.length + 1] = 0, a.length += 2;
      for (var h = 0, p = 0; p < a.length; p++) {
        var y = a.words[p] | 0;
        h += y * 977, a.words[p] = h & 67108863, h = y * 64 + (h / 67108864 | 0);
      }
      return a.words[a.length - 1] === 0 && (a.length--, a.words[a.length - 1] === 0 && a.length--), a;
    };
    function Y() {
      z.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    i(Y, z);
    function J() {
      z.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    i(J, z);
    function gt() {
      z.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    i(gt, z), gt.prototype.imulK = function(a) {
      for (var h = 0, p = 0; p < a.length; p++) {
        var y = (a.words[p] | 0) * 19 + h, A = y & 67108863;
        y >>>= 26, a.words[p] = A, h = y;
      }
      return h !== 0 && (a.words[a.length++] = h), a;
    }, s._prime = function(a) {
      if (H[a])
        return H[a];
      var h;
      if (a === "k256")
        h = new j();
      else if (a === "p224")
        h = new Y();
      else if (a === "p192")
        h = new J();
      else if (a === "p25519")
        h = new gt();
      else
        throw new Error("Unknown prime " + a);
      return H[a] = h, h;
    };
    function $(M) {
      if (typeof M == "string") {
        var a = s._prime(M);
        this.m = a.p, this.prime = a;
      } else
        r(M.gtn(1), "modulus must be greater than 1"), this.m = M, this.prime = null;
    }
    $.prototype._verify1 = function(a) {
      r(a.negative === 0, "red works only with positives"), r(a.red, "red works only with red numbers");
    }, $.prototype._verify2 = function(a, h) {
      r((a.negative | h.negative) === 0, "red works only with positives"), r(
        a.red && a.red === h.red,
        "red works only with red numbers"
      );
    }, $.prototype.imod = function(a) {
      return this.prime ? this.prime.ireduce(a)._forceRed(this) : (g(a, a.umod(this.m)._forceRed(this)), a);
    }, $.prototype.neg = function(a) {
      return a.isZero() ? a.clone() : this.m.sub(a)._forceRed(this);
    }, $.prototype.add = function(a, h) {
      this._verify2(a, h);
      var p = a.add(h);
      return p.cmp(this.m) >= 0 && p.isub(this.m), p._forceRed(this);
    }, $.prototype.iadd = function(a, h) {
      this._verify2(a, h);
      var p = a.iadd(h);
      return p.cmp(this.m) >= 0 && p.isub(this.m), p;
    }, $.prototype.sub = function(a, h) {
      this._verify2(a, h);
      var p = a.sub(h);
      return p.cmpn(0) < 0 && p.iadd(this.m), p._forceRed(this);
    }, $.prototype.isub = function(a, h) {
      this._verify2(a, h);
      var p = a.isub(h);
      return p.cmpn(0) < 0 && p.iadd(this.m), p;
    }, $.prototype.shl = function(a, h) {
      return this._verify1(a), this.imod(a.ushln(h));
    }, $.prototype.imul = function(a, h) {
      return this._verify2(a, h), this.imod(a.imul(h));
    }, $.prototype.mul = function(a, h) {
      return this._verify2(a, h), this.imod(a.mul(h));
    }, $.prototype.isqr = function(a) {
      return this.imul(a, a.clone());
    }, $.prototype.sqr = function(a) {
      return this.mul(a, a);
    }, $.prototype.sqrt = function(a) {
      if (a.isZero())
        return a.clone();
      var h = this.m.andln(3);
      if (r(h % 2 === 1), h === 3) {
        var p = this.m.add(new s(1)).iushrn(2);
        return this.pow(a, p);
      }
      for (var y = this.m.subn(1), A = 0; !y.isZero() && y.andln(1) === 0; )
        A++, y.iushrn(1);
      r(!y.isZero());
      var B = new s(1).toRed(this), C = B.redNeg(), b = this.m.subn(1).iushrn(1), l = this.m.bitLength();
      for (l = new s(2 * l * l).toRed(this); this.pow(l, b).cmp(C) !== 0; )
        l.redIAdd(C);
      for (var E = this.pow(l, y), Q = this.pow(a, y.addn(1).iushrn(1)), q = this.pow(a, y), Z = A; q.cmp(B) !== 0; ) {
        for (var pt = q, nt = 0; pt.cmp(B) !== 0; nt++)
          pt = pt.redSqr();
        r(nt < Z);
        var at = this.pow(E, new s(1).iushln(Z - nt - 1));
        Q = Q.redMul(at), E = at.redSqr(), q = q.redMul(E), Z = nt;
      }
      return Q;
    }, $.prototype.invm = function(a) {
      var h = a._invmp(this.m);
      return h.negative !== 0 ? (h.negative = 0, this.imod(h).redNeg()) : this.imod(h);
    }, $.prototype.pow = function(a, h) {
      if (h.isZero())
        return new s(1).toRed(this);
      if (h.cmpn(1) === 0)
        return a.clone();
      var p = 4, y = new Array(1 << p);
      y[0] = new s(1).toRed(this), y[1] = a;
      for (var A = 2; A < y.length; A++)
        y[A] = this.mul(y[A - 1], a);
      var B = y[0], C = 0, b = 0, l = h.bitLength() % 26;
      for (l === 0 && (l = 26), A = h.length - 1; A >= 0; A--) {
        for (var E = h.words[A], Q = l - 1; Q >= 0; Q--) {
          var q = E >> Q & 1;
          if (B !== y[0] && (B = this.sqr(B)), q === 0 && C === 0) {
            b = 0;
            continue;
          }
          C <<= 1, C |= q, b++, !(b !== p && (A !== 0 || Q !== 0)) && (B = this.mul(B, y[C]), b = 0, C = 0);
        }
        l = 26;
      }
      return B;
    }, $.prototype.convertTo = function(a) {
      var h = a.umod(this.m);
      return h === a ? h.clone() : h;
    }, $.prototype.convertFrom = function(a) {
      var h = a.clone();
      return h.red = null, h;
    }, s.mont = function(a) {
      return new ot(a);
    };
    function ot(M) {
      $.call(this, M), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new s(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    i(ot, $), ot.prototype.convertTo = function(a) {
      return this.imod(a.ushln(this.shift));
    }, ot.prototype.convertFrom = function(a) {
      var h = this.imod(a.mul(this.rinv));
      return h.red = null, h;
    }, ot.prototype.imul = function(a, h) {
      if (a.isZero() || h.isZero())
        return a.words[0] = 0, a.length = 1, a;
      var p = a.imul(h), y = p.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = p.isub(y).iushrn(this.shift), B = A;
      return A.cmp(this.m) >= 0 ? B = A.isub(this.m) : A.cmpn(0) < 0 && (B = A.iadd(this.m)), B._forceRed(this);
    }, ot.prototype.mul = function(a, h) {
      if (a.isZero() || h.isZero())
        return new s(0)._forceRed(this);
      var p = a.mul(h), y = p.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), A = p.isub(y).iushrn(this.shift), B = A;
      return A.cmp(this.m) >= 0 ? B = A.isub(this.m) : A.cmpn(0) < 0 && (B = A.iadd(this.m)), B._forceRed(this);
    }, ot.prototype.invm = function(a) {
      var h = this.imod(a._invmp(this.m).mul(this.r2));
      return h._forceRed(this);
    };
  })(e, Qe);
})(Eo);
var uc = Eo.exports;
const Ks = /* @__PURE__ */ ac(uc), Md = "bignumber/5.7.0";
var qs = Ks.BN;
const rn = new vt(Md), ms = {}, Ma = 9007199254740991;
let Ta = !1;
class mt {
  constructor(t, n) {
    t !== ms && rn.throwError("cannot call constructor directly; use BigNumber.from", vt.errors.UNSUPPORTED_OPERATION, {
      operation: "new (BigNumber)"
    }), this._hex = n, this._isBigNumber = !0, Object.freeze(this);
  }
  fromTwos(t) {
    return Me(wt(this).fromTwos(t));
  }
  toTwos(t) {
    return Me(wt(this).toTwos(t));
  }
  abs() {
    return this._hex[0] === "-" ? mt.from(this._hex.substring(1)) : this;
  }
  add(t) {
    return Me(wt(this).add(wt(t)));
  }
  sub(t) {
    return Me(wt(this).sub(wt(t)));
  }
  div(t) {
    return mt.from(t).isZero() && Ne("division-by-zero", "div"), Me(wt(this).div(wt(t)));
  }
  mul(t) {
    return Me(wt(this).mul(wt(t)));
  }
  mod(t) {
    const n = wt(t);
    return n.isNeg() && Ne("division-by-zero", "mod"), Me(wt(this).umod(n));
  }
  pow(t) {
    const n = wt(t);
    return n.isNeg() && Ne("negative-power", "pow"), Me(wt(this).pow(n));
  }
  and(t) {
    const n = wt(t);
    return (this.isNegative() || n.isNeg()) && Ne("unbound-bitwise-result", "and"), Me(wt(this).and(n));
  }
  or(t) {
    const n = wt(t);
    return (this.isNegative() || n.isNeg()) && Ne("unbound-bitwise-result", "or"), Me(wt(this).or(n));
  }
  xor(t) {
    const n = wt(t);
    return (this.isNegative() || n.isNeg()) && Ne("unbound-bitwise-result", "xor"), Me(wt(this).xor(n));
  }
  mask(t) {
    return (this.isNegative() || t < 0) && Ne("negative-width", "mask"), Me(wt(this).maskn(t));
  }
  shl(t) {
    return (this.isNegative() || t < 0) && Ne("negative-width", "shl"), Me(wt(this).shln(t));
  }
  shr(t) {
    return (this.isNegative() || t < 0) && Ne("negative-width", "shr"), Me(wt(this).shrn(t));
  }
  eq(t) {
    return wt(this).eq(wt(t));
  }
  lt(t) {
    return wt(this).lt(wt(t));
  }
  lte(t) {
    return wt(this).lte(wt(t));
  }
  gt(t) {
    return wt(this).gt(wt(t));
  }
  gte(t) {
    return wt(this).gte(wt(t));
  }
  isNegative() {
    return this._hex[0] === "-";
  }
  isZero() {
    return wt(this).isZero();
  }
  toNumber() {
    try {
      return wt(this).toNumber();
    } catch {
      Ne("overflow", "toNumber", this.toString());
    }
    return null;
  }
  toBigInt() {
    try {
      return BigInt(this.toString());
    } catch {
    }
    return rn.throwError("this platform does not support BigInt", vt.errors.UNSUPPORTED_OPERATION, {
      value: this.toString()
    });
  }
  toString() {
    return arguments.length > 0 && (arguments[0] === 10 ? Ta || (Ta = !0, rn.warn("BigNumber.toString does not accept any parameters; base-10 is assumed")) : arguments[0] === 16 ? rn.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", vt.errors.UNEXPECTED_ARGUMENT, {}) : rn.throwError("BigNumber.toString does not accept parameters", vt.errors.UNEXPECTED_ARGUMENT, {})), wt(this).toString(10);
  }
  toHexString() {
    return this._hex;
  }
  toJSON(t) {
    return { type: "BigNumber", hex: this.toHexString() };
  }
  static from(t) {
    if (t instanceof mt)
      return t;
    if (typeof t == "string")
      return t.match(/^-?0x[0-9a-f]+$/i) ? new mt(ms, Pr(t)) : t.match(/^-?[0-9]+$/) ? new mt(ms, Pr(new qs(t))) : rn.throwArgumentError("invalid BigNumber string", "value", t);
    if (typeof t == "number")
      return t % 1 && Ne("underflow", "BigNumber.from", t), (t >= Ma || t <= -Ma) && Ne("overflow", "BigNumber.from", t), mt.from(String(t));
    const n = t;
    if (typeof n == "bigint")
      return mt.from(n.toString());
    if (Ao(n))
      return mt.from(Un(n));
    if (n)
      if (n.toHexString) {
        const r = n.toHexString();
        if (typeof r == "string")
          return mt.from(r);
      } else {
        let r = n._hex;
        if (r == null && n.type === "BigNumber" && (r = n.hex), typeof r == "string" && (Rr(r) || r[0] === "-" && Rr(r.substring(1))))
          return mt.from(r);
      }
    return rn.throwArgumentError("invalid BigNumber value", "value", t);
  }
  static isBigNumber(t) {
    return !!(t && t._isBigNumber);
  }
}
function Pr(e) {
  if (typeof e != "string")
    return Pr(e.toString(16));
  if (e[0] === "-")
    return e = e.substring(1), e[0] === "-" && rn.throwArgumentError("invalid hex", "value", e), e = Pr(e), e === "0x00" ? e : "-" + e;
  if (e.substring(0, 2) !== "0x" && (e = "0x" + e), e === "0x")
    return "0x00";
  for (e.length % 2 && (e = "0x0" + e.substring(2)); e.length > 4 && e.substring(0, 4) === "0x00"; )
    e = "0x" + e.substring(4);
  return e;
}
function Me(e) {
  return mt.from(Pr(e));
}
function wt(e) {
  const t = mt.from(e).toHexString();
  return t[0] === "-" ? new qs("-" + t.substring(3), 16) : new qs(t.substring(2), 16);
}
function Ne(e, t, n) {
  const r = { fault: e, operation: t };
  return n != null && (r.value = n), rn.throwError(e, vt.errors.NUMERIC_FAULT, r);
}
var Ot = {}, Ti = {};
Ti.byteLength = Sd;
Ti.toByteArray = Fd;
Ti.fromByteArray = Rd;
var Ye = [], Re = [], Td = typeof Uint8Array < "u" ? Uint8Array : Array, ws = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var Zn = 0, Cd = ws.length; Zn < Cd; ++Zn)
  Ye[Zn] = ws[Zn], Re[ws.charCodeAt(Zn)] = Zn;
Re["-".charCodeAt(0)] = 62;
Re["_".charCodeAt(0)] = 63;
function cc(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var n = e.indexOf("=");
  n === -1 && (n = t);
  var r = n === t ? 0 : 4 - n % 4;
  return [n, r];
}
function Sd(e) {
  var t = cc(e), n = t[0], r = t[1];
  return (n + r) * 3 / 4 - r;
}
function Ud(e, t, n) {
  return (t + n) * 3 / 4 - n;
}
function Fd(e) {
  var t, n = cc(e), r = n[0], i = n[1], s = new Td(Ud(e, r, i)), o = 0, u = i > 0 ? r - 4 : r, d;
  for (d = 0; d < u; d += 4)
    t = Re[e.charCodeAt(d)] << 18 | Re[e.charCodeAt(d + 1)] << 12 | Re[e.charCodeAt(d + 2)] << 6 | Re[e.charCodeAt(d + 3)], s[o++] = t >> 16 & 255, s[o++] = t >> 8 & 255, s[o++] = t & 255;
  return i === 2 && (t = Re[e.charCodeAt(d)] << 2 | Re[e.charCodeAt(d + 1)] >> 4, s[o++] = t & 255), i === 1 && (t = Re[e.charCodeAt(d)] << 10 | Re[e.charCodeAt(d + 1)] << 4 | Re[e.charCodeAt(d + 2)] >> 2, s[o++] = t >> 8 & 255, s[o++] = t & 255), s;
}
function kd(e) {
  return Ye[e >> 18 & 63] + Ye[e >> 12 & 63] + Ye[e >> 6 & 63] + Ye[e & 63];
}
function Nd(e, t, n) {
  for (var r, i = [], s = t; s < n; s += 3)
    r = (e[s] << 16 & 16711680) + (e[s + 1] << 8 & 65280) + (e[s + 2] & 255), i.push(kd(r));
  return i.join("");
}
function Rd(e) {
  for (var t, n = e.length, r = n % 3, i = [], s = 16383, o = 0, u = n - r; o < u; o += s)
    i.push(Nd(e, o, o + s > u ? u : o + s));
  return r === 1 ? (t = e[n - 1], i.push(
    Ye[t >> 2] + Ye[t << 4 & 63] + "=="
  )) : r === 2 && (t = (e[n - 2] << 8) + e[n - 1], i.push(
    Ye[t >> 10] + Ye[t >> 4 & 63] + Ye[t << 2 & 63] + "="
  )), i.join("");
}
var vo = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
vo.read = function(e, t, n, r, i) {
  var s, o, u = i * 8 - r - 1, d = (1 << u) - 1, w = d >> 1, g = -7, v = n ? i - 1 : 0, I = n ? -1 : 1, S = e[t + v];
  for (v += I, s = S & (1 << -g) - 1, S >>= -g, g += u; g > 0; s = s * 256 + e[t + v], v += I, g -= 8)
    ;
  for (o = s & (1 << -g) - 1, s >>= -g, g += r; g > 0; o = o * 256 + e[t + v], v += I, g -= 8)
    ;
  if (s === 0)
    s = 1 - w;
  else {
    if (s === d)
      return o ? NaN : (S ? -1 : 1) * (1 / 0);
    o = o + Math.pow(2, r), s = s - w;
  }
  return (S ? -1 : 1) * o * Math.pow(2, s - r);
};
vo.write = function(e, t, n, r, i, s) {
  var o, u, d, w = s * 8 - i - 1, g = (1 << w) - 1, v = g >> 1, I = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, S = r ? 0 : s - 1, D = r ? 1 : -1, N = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (u = isNaN(t) ? 1 : 0, o = g) : (o = Math.floor(Math.log(t) / Math.LN2), t * (d = Math.pow(2, -o)) < 1 && (o--, d *= 2), o + v >= 1 ? t += I / d : t += I * Math.pow(2, 1 - v), t * d >= 2 && (o++, d /= 2), o + v >= g ? (u = 0, o = g) : o + v >= 1 ? (u = (t * d - 1) * Math.pow(2, i), o = o + v) : (u = t * Math.pow(2, v - 1) * Math.pow(2, i), o = 0)); i >= 8; e[n + S] = u & 255, S += D, u /= 256, i -= 8)
    ;
  for (o = o << i | u, w += i; w > 0; e[n + S] = o & 255, S += D, o /= 256, w -= 8)
    ;
  e[n + S - D] |= N * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  const t = Ti, n = vo, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = u, e.SlowBuffer = _, e.INSPECT_MAX_BYTES = 50;
  const i = 2147483647;
  e.kMaxLength = i, u.TYPED_ARRAY_SUPPORT = s(), !u.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function s() {
    try {
      const m = new Uint8Array(1), c = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(c, Uint8Array.prototype), Object.setPrototypeOf(m, c), m.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(u.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(u.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (u.isBuffer(this))
        return this.byteOffset;
    }
  });
  function o(m) {
    if (m > i)
      throw new RangeError('The value "' + m + '" is invalid for option "size"');
    const c = new Uint8Array(m);
    return Object.setPrototypeOf(c, u.prototype), c;
  }
  function u(m, c, f) {
    if (typeof m == "number") {
      if (typeof c == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return v(m);
    }
    return d(m, c, f);
  }
  u.poolSize = 8192;
  function d(m, c, f) {
    if (typeof m == "string")
      return I(m, c);
    if (ArrayBuffer.isView(m))
      return D(m);
    if (m == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m
      );
    if (pe(m, ArrayBuffer) || m && pe(m.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (pe(m, SharedArrayBuffer) || m && pe(m.buffer, SharedArrayBuffer)))
      return N(m, c, f);
    if (typeof m == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const x = m.valueOf && m.valueOf();
    if (x != null && x !== m)
      return u.from(x, c, f);
    const U = T(m);
    if (U)
      return U;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof m[Symbol.toPrimitive] == "function")
      return u.from(m[Symbol.toPrimitive]("string"), c, f);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof m
    );
  }
  u.from = function(m, c, f) {
    return d(m, c, f);
  }, Object.setPrototypeOf(u.prototype, Uint8Array.prototype), Object.setPrototypeOf(u, Uint8Array);
  function w(m) {
    if (typeof m != "number")
      throw new TypeError('"size" argument must be of type number');
    if (m < 0)
      throw new RangeError('The value "' + m + '" is invalid for option "size"');
  }
  function g(m, c, f) {
    return w(m), m <= 0 ? o(m) : c !== void 0 ? typeof f == "string" ? o(m).fill(c, f) : o(m).fill(c) : o(m);
  }
  u.alloc = function(m, c, f) {
    return g(m, c, f);
  };
  function v(m) {
    return w(m), o(m < 0 ? 0 : O(m) | 0);
  }
  u.allocUnsafe = function(m) {
    return v(m);
  }, u.allocUnsafeSlow = function(m) {
    return v(m);
  };
  function I(m, c) {
    if ((typeof c != "string" || c === "") && (c = "utf8"), !u.isEncoding(c))
      throw new TypeError("Unknown encoding: " + c);
    const f = k(m, c) | 0;
    let x = o(f);
    const U = x.write(m, c);
    return U !== f && (x = x.slice(0, U)), x;
  }
  function S(m) {
    const c = m.length < 0 ? 0 : O(m.length) | 0, f = o(c);
    for (let x = 0; x < c; x += 1)
      f[x] = m[x] & 255;
    return f;
  }
  function D(m) {
    if (pe(m, Uint8Array)) {
      const c = new Uint8Array(m);
      return N(c.buffer, c.byteOffset, c.byteLength);
    }
    return S(m);
  }
  function N(m, c, f) {
    if (c < 0 || m.byteLength < c)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (m.byteLength < c + (f || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let x;
    return c === void 0 && f === void 0 ? x = new Uint8Array(m) : f === void 0 ? x = new Uint8Array(m, c) : x = new Uint8Array(m, c, f), Object.setPrototypeOf(x, u.prototype), x;
  }
  function T(m) {
    if (u.isBuffer(m)) {
      const c = O(m.length) | 0, f = o(c);
      return f.length === 0 || m.copy(f, 0, 0, c), f;
    }
    if (m.length !== void 0)
      return typeof m.length != "number" || Ct(m.length) ? o(0) : S(m);
    if (m.type === "Buffer" && Array.isArray(m.data))
      return S(m.data);
  }
  function O(m) {
    if (m >= i)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
    return m | 0;
  }
  function _(m) {
    return +m != m && (m = 0), u.alloc(+m);
  }
  u.isBuffer = function(c) {
    return c != null && c._isBuffer === !0 && c !== u.prototype;
  }, u.compare = function(c, f) {
    if (pe(c, Uint8Array) && (c = u.from(c, c.offset, c.byteLength)), pe(f, Uint8Array) && (f = u.from(f, f.offset, f.byteLength)), !u.isBuffer(c) || !u.isBuffer(f))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (c === f)
      return 0;
    let x = c.length, U = f.length;
    for (let F = 0, L = Math.min(x, U); F < L; ++F)
      if (c[F] !== f[F]) {
        x = c[F], U = f[F];
        break;
      }
    return x < U ? -1 : U < x ? 1 : 0;
  }, u.isEncoding = function(c) {
    switch (String(c).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, u.concat = function(c, f) {
    if (!Array.isArray(c))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (c.length === 0)
      return u.alloc(0);
    let x;
    if (f === void 0)
      for (f = 0, x = 0; x < c.length; ++x)
        f += c[x].length;
    const U = u.allocUnsafe(f);
    let F = 0;
    for (x = 0; x < c.length; ++x) {
      let L = c[x];
      if (pe(L, Uint8Array))
        F + L.length > U.length ? (u.isBuffer(L) || (L = u.from(L)), L.copy(U, F)) : Uint8Array.prototype.set.call(
          U,
          L,
          F
        );
      else if (u.isBuffer(L))
        L.copy(U, F);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      F += L.length;
    }
    return U;
  };
  function k(m, c) {
    if (u.isBuffer(m))
      return m.length;
    if (ArrayBuffer.isView(m) || pe(m, ArrayBuffer))
      return m.byteLength;
    if (typeof m != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof m
      );
    const f = m.length, x = arguments.length > 2 && arguments[2] === !0;
    if (!x && f === 0)
      return 0;
    let U = !1;
    for (; ; )
      switch (c) {
        case "ascii":
        case "latin1":
        case "binary":
          return f;
        case "utf8":
        case "utf-8":
          return St(m).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return f * 2;
        case "hex":
          return f >>> 1;
        case "base64":
          return Ut(m).length;
        default:
          if (U)
            return x ? -1 : St(m).length;
          c = ("" + c).toLowerCase(), U = !0;
      }
  }
  u.byteLength = k;
  function V(m, c, f) {
    let x = !1;
    if ((c === void 0 || c < 0) && (c = 0), c > this.length || ((f === void 0 || f > this.length) && (f = this.length), f <= 0) || (f >>>= 0, c >>>= 0, f <= c))
      return "";
    for (m || (m = "utf8"); ; )
      switch (m) {
        case "hex":
          return B(this, c, f);
        case "utf8":
        case "utf-8":
          return a(this, c, f);
        case "ascii":
          return y(this, c, f);
        case "latin1":
        case "binary":
          return A(this, c, f);
        case "base64":
          return M(this, c, f);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return C(this, c, f);
        default:
          if (x)
            throw new TypeError("Unknown encoding: " + m);
          m = (m + "").toLowerCase(), x = !0;
      }
  }
  u.prototype._isBuffer = !0;
  function H(m, c, f) {
    const x = m[c];
    m[c] = m[f], m[f] = x;
  }
  u.prototype.swap16 = function() {
    const c = this.length;
    if (c % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let f = 0; f < c; f += 2)
      H(this, f, f + 1);
    return this;
  }, u.prototype.swap32 = function() {
    const c = this.length;
    if (c % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let f = 0; f < c; f += 4)
      H(this, f, f + 3), H(this, f + 1, f + 2);
    return this;
  }, u.prototype.swap64 = function() {
    const c = this.length;
    if (c % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let f = 0; f < c; f += 8)
      H(this, f, f + 7), H(this, f + 1, f + 6), H(this, f + 2, f + 5), H(this, f + 3, f + 4);
    return this;
  }, u.prototype.toString = function() {
    const c = this.length;
    return c === 0 ? "" : arguments.length === 0 ? a(this, 0, c) : V.apply(this, arguments);
  }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(c) {
    if (!u.isBuffer(c))
      throw new TypeError("Argument must be a Buffer");
    return this === c ? !0 : u.compare(this, c) === 0;
  }, u.prototype.inspect = function() {
    let c = "";
    const f = e.INSPECT_MAX_BYTES;
    return c = this.toString("hex", 0, f).replace(/(.{2})/g, "$1 ").trim(), this.length > f && (c += " ... "), "<Buffer " + c + ">";
  }, r && (u.prototype[r] = u.prototype.inspect), u.prototype.compare = function(c, f, x, U, F) {
    if (pe(c, Uint8Array) && (c = u.from(c, c.offset, c.byteLength)), !u.isBuffer(c))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof c
      );
    if (f === void 0 && (f = 0), x === void 0 && (x = c ? c.length : 0), U === void 0 && (U = 0), F === void 0 && (F = this.length), f < 0 || x > c.length || U < 0 || F > this.length)
      throw new RangeError("out of range index");
    if (U >= F && f >= x)
      return 0;
    if (U >= F)
      return -1;
    if (f >= x)
      return 1;
    if (f >>>= 0, x >>>= 0, U >>>= 0, F >>>= 0, this === c)
      return 0;
    let L = F - U, ht = x - f;
    const ft = Math.min(L, ht), ut = this.slice(U, F), Rt = c.slice(f, x);
    for (let st = 0; st < ft; ++st)
      if (ut[st] !== Rt[st]) {
        L = ut[st], ht = Rt[st];
        break;
      }
    return L < ht ? -1 : ht < L ? 1 : 0;
  };
  function z(m, c, f, x, U) {
    if (m.length === 0)
      return -1;
    if (typeof f == "string" ? (x = f, f = 0) : f > 2147483647 ? f = 2147483647 : f < -2147483648 && (f = -2147483648), f = +f, Ct(f) && (f = U ? 0 : m.length - 1), f < 0 && (f = m.length + f), f >= m.length) {
      if (U)
        return -1;
      f = m.length - 1;
    } else if (f < 0)
      if (U)
        f = 0;
      else
        return -1;
    if (typeof c == "string" && (c = u.from(c, x)), u.isBuffer(c))
      return c.length === 0 ? -1 : j(m, c, f, x, U);
    if (typeof c == "number")
      return c = c & 255, typeof Uint8Array.prototype.indexOf == "function" ? U ? Uint8Array.prototype.indexOf.call(m, c, f) : Uint8Array.prototype.lastIndexOf.call(m, c, f) : j(m, [c], f, x, U);
    throw new TypeError("val must be string, number or Buffer");
  }
  function j(m, c, f, x, U) {
    let F = 1, L = m.length, ht = c.length;
    if (x !== void 0 && (x = String(x).toLowerCase(), x === "ucs2" || x === "ucs-2" || x === "utf16le" || x === "utf-16le")) {
      if (m.length < 2 || c.length < 2)
        return -1;
      F = 2, L /= 2, ht /= 2, f /= 2;
    }
    function ft(Rt, st) {
      return F === 1 ? Rt[st] : Rt.readUInt16BE(st * F);
    }
    let ut;
    if (U) {
      let Rt = -1;
      for (ut = f; ut < L; ut++)
        if (ft(m, ut) === ft(c, Rt === -1 ? 0 : ut - Rt)) {
          if (Rt === -1 && (Rt = ut), ut - Rt + 1 === ht)
            return Rt * F;
        } else
          Rt !== -1 && (ut -= ut - Rt), Rt = -1;
    } else
      for (f + ht > L && (f = L - ht), ut = f; ut >= 0; ut--) {
        let Rt = !0;
        for (let st = 0; st < ht; st++)
          if (ft(m, ut + st) !== ft(c, st)) {
            Rt = !1;
            break;
          }
        if (Rt)
          return ut;
      }
    return -1;
  }
  u.prototype.includes = function(c, f, x) {
    return this.indexOf(c, f, x) !== -1;
  }, u.prototype.indexOf = function(c, f, x) {
    return z(this, c, f, x, !0);
  }, u.prototype.lastIndexOf = function(c, f, x) {
    return z(this, c, f, x, !1);
  };
  function Y(m, c, f, x) {
    f = Number(f) || 0;
    const U = m.length - f;
    x ? (x = Number(x), x > U && (x = U)) : x = U;
    const F = c.length;
    x > F / 2 && (x = F / 2);
    let L;
    for (L = 0; L < x; ++L) {
      const ht = parseInt(c.substr(L * 2, 2), 16);
      if (Ct(ht))
        return L;
      m[f + L] = ht;
    }
    return L;
  }
  function J(m, c, f, x) {
    return Mt(St(c, m.length - f), m, f, x);
  }
  function gt(m, c, f, x) {
    return Mt(Pt(c), m, f, x);
  }
  function $(m, c, f, x) {
    return Mt(Ut(c), m, f, x);
  }
  function ot(m, c, f, x) {
    return Mt(Kn(c, m.length - f), m, f, x);
  }
  u.prototype.write = function(c, f, x, U) {
    if (f === void 0)
      U = "utf8", x = this.length, f = 0;
    else if (x === void 0 && typeof f == "string")
      U = f, x = this.length, f = 0;
    else if (isFinite(f))
      f = f >>> 0, isFinite(x) ? (x = x >>> 0, U === void 0 && (U = "utf8")) : (U = x, x = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const F = this.length - f;
    if ((x === void 0 || x > F) && (x = F), c.length > 0 && (x < 0 || f < 0) || f > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    U || (U = "utf8");
    let L = !1;
    for (; ; )
      switch (U) {
        case "hex":
          return Y(this, c, f, x);
        case "utf8":
        case "utf-8":
          return J(this, c, f, x);
        case "ascii":
        case "latin1":
        case "binary":
          return gt(this, c, f, x);
        case "base64":
          return $(this, c, f, x);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ot(this, c, f, x);
        default:
          if (L)
            throw new TypeError("Unknown encoding: " + U);
          U = ("" + U).toLowerCase(), L = !0;
      }
  }, u.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function M(m, c, f) {
    return c === 0 && f === m.length ? t.fromByteArray(m) : t.fromByteArray(m.slice(c, f));
  }
  function a(m, c, f) {
    f = Math.min(m.length, f);
    const x = [];
    let U = c;
    for (; U < f; ) {
      const F = m[U];
      let L = null, ht = F > 239 ? 4 : F > 223 ? 3 : F > 191 ? 2 : 1;
      if (U + ht <= f) {
        let ft, ut, Rt, st;
        switch (ht) {
          case 1:
            F < 128 && (L = F);
            break;
          case 2:
            ft = m[U + 1], (ft & 192) === 128 && (st = (F & 31) << 6 | ft & 63, st > 127 && (L = st));
            break;
          case 3:
            ft = m[U + 1], ut = m[U + 2], (ft & 192) === 128 && (ut & 192) === 128 && (st = (F & 15) << 12 | (ft & 63) << 6 | ut & 63, st > 2047 && (st < 55296 || st > 57343) && (L = st));
            break;
          case 4:
            ft = m[U + 1], ut = m[U + 2], Rt = m[U + 3], (ft & 192) === 128 && (ut & 192) === 128 && (Rt & 192) === 128 && (st = (F & 15) << 18 | (ft & 63) << 12 | (ut & 63) << 6 | Rt & 63, st > 65535 && st < 1114112 && (L = st));
        }
      }
      L === null ? (L = 65533, ht = 1) : L > 65535 && (L -= 65536, x.push(L >>> 10 & 1023 | 55296), L = 56320 | L & 1023), x.push(L), U += ht;
    }
    return p(x);
  }
  const h = 4096;
  function p(m) {
    const c = m.length;
    if (c <= h)
      return String.fromCharCode.apply(String, m);
    let f = "", x = 0;
    for (; x < c; )
      f += String.fromCharCode.apply(
        String,
        m.slice(x, x += h)
      );
    return f;
  }
  function y(m, c, f) {
    let x = "";
    f = Math.min(m.length, f);
    for (let U = c; U < f; ++U)
      x += String.fromCharCode(m[U] & 127);
    return x;
  }
  function A(m, c, f) {
    let x = "";
    f = Math.min(m.length, f);
    for (let U = c; U < f; ++U)
      x += String.fromCharCode(m[U]);
    return x;
  }
  function B(m, c, f) {
    const x = m.length;
    (!c || c < 0) && (c = 0), (!f || f < 0 || f > x) && (f = x);
    let U = "";
    for (let F = c; F < f; ++F)
      U += kt[m[F]];
    return U;
  }
  function C(m, c, f) {
    const x = m.slice(c, f);
    let U = "";
    for (let F = 0; F < x.length - 1; F += 2)
      U += String.fromCharCode(x[F] + x[F + 1] * 256);
    return U;
  }
  u.prototype.slice = function(c, f) {
    const x = this.length;
    c = ~~c, f = f === void 0 ? x : ~~f, c < 0 ? (c += x, c < 0 && (c = 0)) : c > x && (c = x), f < 0 ? (f += x, f < 0 && (f = 0)) : f > x && (f = x), f < c && (f = c);
    const U = this.subarray(c, f);
    return Object.setPrototypeOf(U, u.prototype), U;
  };
  function b(m, c, f) {
    if (m % 1 !== 0 || m < 0)
      throw new RangeError("offset is not uint");
    if (m + c > f)
      throw new RangeError("Trying to access beyond buffer length");
  }
  u.prototype.readUintLE = u.prototype.readUIntLE = function(c, f, x) {
    c = c >>> 0, f = f >>> 0, x || b(c, f, this.length);
    let U = this[c], F = 1, L = 0;
    for (; ++L < f && (F *= 256); )
      U += this[c + L] * F;
    return U;
  }, u.prototype.readUintBE = u.prototype.readUIntBE = function(c, f, x) {
    c = c >>> 0, f = f >>> 0, x || b(c, f, this.length);
    let U = this[c + --f], F = 1;
    for (; f > 0 && (F *= 256); )
      U += this[c + --f] * F;
    return U;
  }, u.prototype.readUint8 = u.prototype.readUInt8 = function(c, f) {
    return c = c >>> 0, f || b(c, 1, this.length), this[c];
  }, u.prototype.readUint16LE = u.prototype.readUInt16LE = function(c, f) {
    return c = c >>> 0, f || b(c, 2, this.length), this[c] | this[c + 1] << 8;
  }, u.prototype.readUint16BE = u.prototype.readUInt16BE = function(c, f) {
    return c = c >>> 0, f || b(c, 2, this.length), this[c] << 8 | this[c + 1];
  }, u.prototype.readUint32LE = u.prototype.readUInt32LE = function(c, f) {
    return c = c >>> 0, f || b(c, 4, this.length), (this[c] | this[c + 1] << 8 | this[c + 2] << 16) + this[c + 3] * 16777216;
  }, u.prototype.readUint32BE = u.prototype.readUInt32BE = function(c, f) {
    return c = c >>> 0, f || b(c, 4, this.length), this[c] * 16777216 + (this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3]);
  }, u.prototype.readBigUInt64LE = Ie(function(c) {
    c = c >>> 0, Kt(c, "offset");
    const f = this[c], x = this[c + 7];
    (f === void 0 || x === void 0) && At(c, this.length - 8);
    const U = f + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + this[++c] * 2 ** 24, F = this[++c] + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + x * 2 ** 24;
    return BigInt(U) + (BigInt(F) << BigInt(32));
  }), u.prototype.readBigUInt64BE = Ie(function(c) {
    c = c >>> 0, Kt(c, "offset");
    const f = this[c], x = this[c + 7];
    (f === void 0 || x === void 0) && At(c, this.length - 8);
    const U = f * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + this[++c], F = this[++c] * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + x;
    return (BigInt(U) << BigInt(32)) + BigInt(F);
  }), u.prototype.readIntLE = function(c, f, x) {
    c = c >>> 0, f = f >>> 0, x || b(c, f, this.length);
    let U = this[c], F = 1, L = 0;
    for (; ++L < f && (F *= 256); )
      U += this[c + L] * F;
    return F *= 128, U >= F && (U -= Math.pow(2, 8 * f)), U;
  }, u.prototype.readIntBE = function(c, f, x) {
    c = c >>> 0, f = f >>> 0, x || b(c, f, this.length);
    let U = f, F = 1, L = this[c + --U];
    for (; U > 0 && (F *= 256); )
      L += this[c + --U] * F;
    return F *= 128, L >= F && (L -= Math.pow(2, 8 * f)), L;
  }, u.prototype.readInt8 = function(c, f) {
    return c = c >>> 0, f || b(c, 1, this.length), this[c] & 128 ? (255 - this[c] + 1) * -1 : this[c];
  }, u.prototype.readInt16LE = function(c, f) {
    c = c >>> 0, f || b(c, 2, this.length);
    const x = this[c] | this[c + 1] << 8;
    return x & 32768 ? x | 4294901760 : x;
  }, u.prototype.readInt16BE = function(c, f) {
    c = c >>> 0, f || b(c, 2, this.length);
    const x = this[c + 1] | this[c] << 8;
    return x & 32768 ? x | 4294901760 : x;
  }, u.prototype.readInt32LE = function(c, f) {
    return c = c >>> 0, f || b(c, 4, this.length), this[c] | this[c + 1] << 8 | this[c + 2] << 16 | this[c + 3] << 24;
  }, u.prototype.readInt32BE = function(c, f) {
    return c = c >>> 0, f || b(c, 4, this.length), this[c] << 24 | this[c + 1] << 16 | this[c + 2] << 8 | this[c + 3];
  }, u.prototype.readBigInt64LE = Ie(function(c) {
    c = c >>> 0, Kt(c, "offset");
    const f = this[c], x = this[c + 7];
    (f === void 0 || x === void 0) && At(c, this.length - 8);
    const U = this[c + 4] + this[c + 5] * 2 ** 8 + this[c + 6] * 2 ** 16 + (x << 24);
    return (BigInt(U) << BigInt(32)) + BigInt(f + this[++c] * 2 ** 8 + this[++c] * 2 ** 16 + this[++c] * 2 ** 24);
  }), u.prototype.readBigInt64BE = Ie(function(c) {
    c = c >>> 0, Kt(c, "offset");
    const f = this[c], x = this[c + 7];
    (f === void 0 || x === void 0) && At(c, this.length - 8);
    const U = (f << 24) + // Overflow
    this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + this[++c];
    return (BigInt(U) << BigInt(32)) + BigInt(this[++c] * 2 ** 24 + this[++c] * 2 ** 16 + this[++c] * 2 ** 8 + x);
  }), u.prototype.readFloatLE = function(c, f) {
    return c = c >>> 0, f || b(c, 4, this.length), n.read(this, c, !0, 23, 4);
  }, u.prototype.readFloatBE = function(c, f) {
    return c = c >>> 0, f || b(c, 4, this.length), n.read(this, c, !1, 23, 4);
  }, u.prototype.readDoubleLE = function(c, f) {
    return c = c >>> 0, f || b(c, 8, this.length), n.read(this, c, !0, 52, 8);
  }, u.prototype.readDoubleBE = function(c, f) {
    return c = c >>> 0, f || b(c, 8, this.length), n.read(this, c, !1, 52, 8);
  };
  function l(m, c, f, x, U, F) {
    if (!u.isBuffer(m))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (c > U || c < F)
      throw new RangeError('"value" argument is out of bounds');
    if (f + x > m.length)
      throw new RangeError("Index out of range");
  }
  u.prototype.writeUintLE = u.prototype.writeUIntLE = function(c, f, x, U) {
    if (c = +c, f = f >>> 0, x = x >>> 0, !U) {
      const ht = Math.pow(2, 8 * x) - 1;
      l(this, c, f, x, ht, 0);
    }
    let F = 1, L = 0;
    for (this[f] = c & 255; ++L < x && (F *= 256); )
      this[f + L] = c / F & 255;
    return f + x;
  }, u.prototype.writeUintBE = u.prototype.writeUIntBE = function(c, f, x, U) {
    if (c = +c, f = f >>> 0, x = x >>> 0, !U) {
      const ht = Math.pow(2, 8 * x) - 1;
      l(this, c, f, x, ht, 0);
    }
    let F = x - 1, L = 1;
    for (this[f + F] = c & 255; --F >= 0 && (L *= 256); )
      this[f + F] = c / L & 255;
    return f + x;
  }, u.prototype.writeUint8 = u.prototype.writeUInt8 = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 1, 255, 0), this[f] = c & 255, f + 1;
  }, u.prototype.writeUint16LE = u.prototype.writeUInt16LE = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 2, 65535, 0), this[f] = c & 255, this[f + 1] = c >>> 8, f + 2;
  }, u.prototype.writeUint16BE = u.prototype.writeUInt16BE = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 2, 65535, 0), this[f] = c >>> 8, this[f + 1] = c & 255, f + 2;
  }, u.prototype.writeUint32LE = u.prototype.writeUInt32LE = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 4, 4294967295, 0), this[f + 3] = c >>> 24, this[f + 2] = c >>> 16, this[f + 1] = c >>> 8, this[f] = c & 255, f + 4;
  }, u.prototype.writeUint32BE = u.prototype.writeUInt32BE = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 4, 4294967295, 0), this[f] = c >>> 24, this[f + 1] = c >>> 16, this[f + 2] = c >>> 8, this[f + 3] = c & 255, f + 4;
  };
  function E(m, c, f, x, U) {
    ct(c, x, U, m, f, 7);
    let F = Number(c & BigInt(4294967295));
    m[f++] = F, F = F >> 8, m[f++] = F, F = F >> 8, m[f++] = F, F = F >> 8, m[f++] = F;
    let L = Number(c >> BigInt(32) & BigInt(4294967295));
    return m[f++] = L, L = L >> 8, m[f++] = L, L = L >> 8, m[f++] = L, L = L >> 8, m[f++] = L, f;
  }
  function Q(m, c, f, x, U) {
    ct(c, x, U, m, f, 7);
    let F = Number(c & BigInt(4294967295));
    m[f + 7] = F, F = F >> 8, m[f + 6] = F, F = F >> 8, m[f + 5] = F, F = F >> 8, m[f + 4] = F;
    let L = Number(c >> BigInt(32) & BigInt(4294967295));
    return m[f + 3] = L, L = L >> 8, m[f + 2] = L, L = L >> 8, m[f + 1] = L, L = L >> 8, m[f] = L, f + 8;
  }
  u.prototype.writeBigUInt64LE = Ie(function(c, f = 0) {
    return E(this, c, f, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeBigUInt64BE = Ie(function(c, f = 0) {
    return Q(this, c, f, BigInt(0), BigInt("0xffffffffffffffff"));
  }), u.prototype.writeIntLE = function(c, f, x, U) {
    if (c = +c, f = f >>> 0, !U) {
      const ft = Math.pow(2, 8 * x - 1);
      l(this, c, f, x, ft - 1, -ft);
    }
    let F = 0, L = 1, ht = 0;
    for (this[f] = c & 255; ++F < x && (L *= 256); )
      c < 0 && ht === 0 && this[f + F - 1] !== 0 && (ht = 1), this[f + F] = (c / L >> 0) - ht & 255;
    return f + x;
  }, u.prototype.writeIntBE = function(c, f, x, U) {
    if (c = +c, f = f >>> 0, !U) {
      const ft = Math.pow(2, 8 * x - 1);
      l(this, c, f, x, ft - 1, -ft);
    }
    let F = x - 1, L = 1, ht = 0;
    for (this[f + F] = c & 255; --F >= 0 && (L *= 256); )
      c < 0 && ht === 0 && this[f + F + 1] !== 0 && (ht = 1), this[f + F] = (c / L >> 0) - ht & 255;
    return f + x;
  }, u.prototype.writeInt8 = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 1, 127, -128), c < 0 && (c = 255 + c + 1), this[f] = c & 255, f + 1;
  }, u.prototype.writeInt16LE = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 2, 32767, -32768), this[f] = c & 255, this[f + 1] = c >>> 8, f + 2;
  }, u.prototype.writeInt16BE = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 2, 32767, -32768), this[f] = c >>> 8, this[f + 1] = c & 255, f + 2;
  }, u.prototype.writeInt32LE = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 4, 2147483647, -2147483648), this[f] = c & 255, this[f + 1] = c >>> 8, this[f + 2] = c >>> 16, this[f + 3] = c >>> 24, f + 4;
  }, u.prototype.writeInt32BE = function(c, f, x) {
    return c = +c, f = f >>> 0, x || l(this, c, f, 4, 2147483647, -2147483648), c < 0 && (c = 4294967295 + c + 1), this[f] = c >>> 24, this[f + 1] = c >>> 16, this[f + 2] = c >>> 8, this[f + 3] = c & 255, f + 4;
  }, u.prototype.writeBigInt64LE = Ie(function(c, f = 0) {
    return E(this, c, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), u.prototype.writeBigInt64BE = Ie(function(c, f = 0) {
    return Q(this, c, f, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function q(m, c, f, x, U, F) {
    if (f + x > m.length)
      throw new RangeError("Index out of range");
    if (f < 0)
      throw new RangeError("Index out of range");
  }
  function Z(m, c, f, x, U) {
    return c = +c, f = f >>> 0, U || q(m, c, f, 4), n.write(m, c, f, x, 23, 4), f + 4;
  }
  u.prototype.writeFloatLE = function(c, f, x) {
    return Z(this, c, f, !0, x);
  }, u.prototype.writeFloatBE = function(c, f, x) {
    return Z(this, c, f, !1, x);
  };
  function pt(m, c, f, x, U) {
    return c = +c, f = f >>> 0, U || q(m, c, f, 8), n.write(m, c, f, x, 52, 8), f + 8;
  }
  u.prototype.writeDoubleLE = function(c, f, x) {
    return pt(this, c, f, !0, x);
  }, u.prototype.writeDoubleBE = function(c, f, x) {
    return pt(this, c, f, !1, x);
  }, u.prototype.copy = function(c, f, x, U) {
    if (!u.isBuffer(c))
      throw new TypeError("argument should be a Buffer");
    if (x || (x = 0), !U && U !== 0 && (U = this.length), f >= c.length && (f = c.length), f || (f = 0), U > 0 && U < x && (U = x), U === x || c.length === 0 || this.length === 0)
      return 0;
    if (f < 0)
      throw new RangeError("targetStart out of bounds");
    if (x < 0 || x >= this.length)
      throw new RangeError("Index out of range");
    if (U < 0)
      throw new RangeError("sourceEnd out of bounds");
    U > this.length && (U = this.length), c.length - f < U - x && (U = c.length - f + x);
    const F = U - x;
    return this === c && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(f, x, U) : Uint8Array.prototype.set.call(
      c,
      this.subarray(x, U),
      f
    ), F;
  }, u.prototype.fill = function(c, f, x, U) {
    if (typeof c == "string") {
      if (typeof f == "string" ? (U = f, f = 0, x = this.length) : typeof x == "string" && (U = x, x = this.length), U !== void 0 && typeof U != "string")
        throw new TypeError("encoding must be a string");
      if (typeof U == "string" && !u.isEncoding(U))
        throw new TypeError("Unknown encoding: " + U);
      if (c.length === 1) {
        const L = c.charCodeAt(0);
        (U === "utf8" && L < 128 || U === "latin1") && (c = L);
      }
    } else
      typeof c == "number" ? c = c & 255 : typeof c == "boolean" && (c = Number(c));
    if (f < 0 || this.length < f || this.length < x)
      throw new RangeError("Out of range index");
    if (x <= f)
      return this;
    f = f >>> 0, x = x === void 0 ? this.length : x >>> 0, c || (c = 0);
    let F;
    if (typeof c == "number")
      for (F = f; F < x; ++F)
        this[F] = c;
    else {
      const L = u.isBuffer(c) ? c : u.from(c, U), ht = L.length;
      if (ht === 0)
        throw new TypeError('The value "' + c + '" is invalid for argument "value"');
      for (F = 0; F < x - f; ++F)
        this[F + f] = L[F % ht];
    }
    return this;
  };
  const nt = {};
  function at(m, c, f) {
    nt[m] = class extends f {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: c.apply(this, arguments),
          writable: !0,
          configurable: !0
        }), this.name = `${this.name} [${m}]`, this.stack, delete this.name;
      }
      get code() {
        return m;
      }
      set code(U) {
        Object.defineProperty(this, "code", {
          configurable: !0,
          enumerable: !0,
          value: U,
          writable: !0
        });
      }
      toString() {
        return `${this.name} [${m}]: ${this.message}`;
      }
    };
  }
  at(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(m) {
      return m ? `${m} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), at(
    "ERR_INVALID_ARG_TYPE",
    function(m, c) {
      return `The "${m}" argument must be of type number. Received type ${typeof c}`;
    },
    TypeError
  ), at(
    "ERR_OUT_OF_RANGE",
    function(m, c, f) {
      let x = `The value of "${m}" is out of range.`, U = f;
      return Number.isInteger(f) && Math.abs(f) > 2 ** 32 ? U = Qt(String(f)) : typeof f == "bigint" && (U = String(f), (f > BigInt(2) ** BigInt(32) || f < -(BigInt(2) ** BigInt(32))) && (U = Qt(U)), U += "n"), x += ` It must be ${c}. Received ${U}`, x;
    },
    RangeError
  );
  function Qt(m) {
    let c = "", f = m.length;
    const x = m[0] === "-" ? 1 : 0;
    for (; f >= x + 4; f -= 3)
      c = `_${m.slice(f - 3, f)}${c}`;
    return `${m.slice(0, f)}${c}`;
  }
  function yt(m, c, f) {
    Kt(c, "offset"), (m[c] === void 0 || m[c + f] === void 0) && At(c, m.length - (f + 1));
  }
  function ct(m, c, f, x, U, F) {
    if (m > f || m < c) {
      const L = typeof c == "bigint" ? "n" : "";
      let ht;
      throw F > 3 ? c === 0 || c === BigInt(0) ? ht = `>= 0${L} and < 2${L} ** ${(F + 1) * 8}${L}` : ht = `>= -(2${L} ** ${(F + 1) * 8 - 1}${L}) and < 2 ** ${(F + 1) * 8 - 1}${L}` : ht = `>= ${c}${L} and <= ${f}${L}`, new nt.ERR_OUT_OF_RANGE("value", ht, m);
    }
    yt(x, U, F);
  }
  function Kt(m, c) {
    if (typeof m != "number")
      throw new nt.ERR_INVALID_ARG_TYPE(c, "number", m);
  }
  function At(m, c, f) {
    throw Math.floor(m) !== m ? (Kt(m, f), new nt.ERR_OUT_OF_RANGE(f || "offset", "an integer", m)) : c < 0 ? new nt.ERR_BUFFER_OUT_OF_BOUNDS() : new nt.ERR_OUT_OF_RANGE(
      f || "offset",
      `>= ${f ? 1 : 0} and <= ${c}`,
      m
    );
  }
  const It = /[^+/0-9A-Za-z-_]/g;
  function Qn(m) {
    if (m = m.split("=")[0], m = m.trim().replace(It, ""), m.length < 2)
      return "";
    for (; m.length % 4 !== 0; )
      m = m + "=";
    return m;
  }
  function St(m, c) {
    c = c || 1 / 0;
    let f;
    const x = m.length;
    let U = null;
    const F = [];
    for (let L = 0; L < x; ++L) {
      if (f = m.charCodeAt(L), f > 55295 && f < 57344) {
        if (!U) {
          if (f > 56319) {
            (c -= 3) > -1 && F.push(239, 191, 189);
            continue;
          } else if (L + 1 === x) {
            (c -= 3) > -1 && F.push(239, 191, 189);
            continue;
          }
          U = f;
          continue;
        }
        if (f < 56320) {
          (c -= 3) > -1 && F.push(239, 191, 189), U = f;
          continue;
        }
        f = (U - 55296 << 10 | f - 56320) + 65536;
      } else
        U && (c -= 3) > -1 && F.push(239, 191, 189);
      if (U = null, f < 128) {
        if ((c -= 1) < 0)
          break;
        F.push(f);
      } else if (f < 2048) {
        if ((c -= 2) < 0)
          break;
        F.push(
          f >> 6 | 192,
          f & 63 | 128
        );
      } else if (f < 65536) {
        if ((c -= 3) < 0)
          break;
        F.push(
          f >> 12 | 224,
          f >> 6 & 63 | 128,
          f & 63 | 128
        );
      } else if (f < 1114112) {
        if ((c -= 4) < 0)
          break;
        F.push(
          f >> 18 | 240,
          f >> 12 & 63 | 128,
          f >> 6 & 63 | 128,
          f & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return F;
  }
  function Pt(m) {
    const c = [];
    for (let f = 0; f < m.length; ++f)
      c.push(m.charCodeAt(f) & 255);
    return c;
  }
  function Kn(m, c) {
    let f, x, U;
    const F = [];
    for (let L = 0; L < m.length && !((c -= 2) < 0); ++L)
      f = m.charCodeAt(L), x = f >> 8, U = f % 256, F.push(U), F.push(x);
    return F;
  }
  function Ut(m) {
    return t.toByteArray(Qn(m));
  }
  function Mt(m, c, f, x) {
    let U;
    for (U = 0; U < x && !(U + f >= c.length || U >= m.length); ++U)
      c[U + f] = m[U];
    return U;
  }
  function pe(m, c) {
    return m instanceof c || m != null && m.constructor != null && m.constructor.name != null && m.constructor.name === c.name;
  }
  function Ct(m) {
    return m !== m;
  }
  const kt = function() {
    const m = "0123456789abcdef", c = new Array(256);
    for (let f = 0; f < 16; ++f) {
      const x = f * 16;
      for (let U = 0; U < 16; ++U)
        c[x + U] = m[f] + m[U];
    }
    return c;
  }();
  function Ie(m) {
    return typeof BigInt > "u" ? Nt : m;
  }
  function Nt() {
    throw new Error("BigInt not supported");
  }
})(Ot);
const [Pd, Dd] = /* @__PURE__ */ (() => dt.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((e) => BigInt(e))))(), yn = /* @__PURE__ */ new Uint32Array(80), mn = /* @__PURE__ */ new Uint32Array(80);
class Od extends yu {
  constructor() {
    super(128, 64, 16, !1), this.Ah = 1779033703, this.Al = -205731576, this.Bh = -1150833019, this.Bl = -2067093701, this.Ch = 1013904242, this.Cl = -23791573, this.Dh = -1521486534, this.Dl = 1595750129, this.Eh = 1359893119, this.El = -1377402159, this.Fh = -1694144372, this.Fl = 725511199, this.Gh = 528734635, this.Gl = -79577749, this.Hh = 1541459225, this.Hl = 327033209;
  }
  // prettier-ignore
  get() {
    const { Ah: t, Al: n, Bh: r, Bl: i, Ch: s, Cl: o, Dh: u, Dl: d, Eh: w, El: g, Fh: v, Fl: I, Gh: S, Gl: D, Hh: N, Hl: T } = this;
    return [t, n, r, i, s, o, u, d, w, g, v, I, S, D, N, T];
  }
  // prettier-ignore
  set(t, n, r, i, s, o, u, d, w, g, v, I, S, D, N, T) {
    this.Ah = t | 0, this.Al = n | 0, this.Bh = r | 0, this.Bl = i | 0, this.Ch = s | 0, this.Cl = o | 0, this.Dh = u | 0, this.Dl = d | 0, this.Eh = w | 0, this.El = g | 0, this.Fh = v | 0, this.Fl = I | 0, this.Gh = S | 0, this.Gl = D | 0, this.Hh = N | 0, this.Hl = T | 0;
  }
  process(t, n) {
    for (let k = 0; k < 16; k++, n += 4)
      yn[k] = t.getUint32(n), mn[k] = t.getUint32(n += 4);
    for (let k = 16; k < 80; k++) {
      const V = yn[k - 15] | 0, H = mn[k - 15] | 0, z = dt.rotrSH(V, H, 1) ^ dt.rotrSH(V, H, 8) ^ dt.shrSH(V, H, 7), j = dt.rotrSL(V, H, 1) ^ dt.rotrSL(V, H, 8) ^ dt.shrSL(V, H, 7), Y = yn[k - 2] | 0, J = mn[k - 2] | 0, gt = dt.rotrSH(Y, J, 19) ^ dt.rotrBH(Y, J, 61) ^ dt.shrSH(Y, J, 6), $ = dt.rotrSL(Y, J, 19) ^ dt.rotrBL(Y, J, 61) ^ dt.shrSL(Y, J, 6), ot = dt.add4L(j, $, mn[k - 7], mn[k - 16]), M = dt.add4H(ot, z, gt, yn[k - 7], yn[k - 16]);
      yn[k] = M | 0, mn[k] = ot | 0;
    }
    let { Ah: r, Al: i, Bh: s, Bl: o, Ch: u, Cl: d, Dh: w, Dl: g, Eh: v, El: I, Fh: S, Fl: D, Gh: N, Gl: T, Hh: O, Hl: _ } = this;
    for (let k = 0; k < 80; k++) {
      const V = dt.rotrSH(v, I, 14) ^ dt.rotrSH(v, I, 18) ^ dt.rotrBH(v, I, 41), H = dt.rotrSL(v, I, 14) ^ dt.rotrSL(v, I, 18) ^ dt.rotrBL(v, I, 41), z = v & S ^ ~v & N, j = I & D ^ ~I & T, Y = dt.add5L(_, H, j, Dd[k], mn[k]), J = dt.add5H(Y, O, V, z, Pd[k], yn[k]), gt = Y | 0, $ = dt.rotrSH(r, i, 28) ^ dt.rotrBH(r, i, 34) ^ dt.rotrBH(r, i, 39), ot = dt.rotrSL(r, i, 28) ^ dt.rotrBL(r, i, 34) ^ dt.rotrBL(r, i, 39), M = r & s ^ r & u ^ s & u, a = i & o ^ i & d ^ o & d;
      O = N | 0, _ = T | 0, N = S | 0, T = D | 0, S = v | 0, D = I | 0, { h: v, l: I } = dt.add(w | 0, g | 0, J | 0, gt | 0), w = u | 0, g = d | 0, u = s | 0, d = o | 0, s = r | 0, o = i | 0;
      const h = dt.add3L(gt, ot, a);
      r = dt.add3H(h, J, $, M), i = h | 0;
    }
    ({ h: r, l: i } = dt.add(this.Ah | 0, this.Al | 0, r | 0, i | 0)), { h: s, l: o } = dt.add(this.Bh | 0, this.Bl | 0, s | 0, o | 0), { h: u, l: d } = dt.add(this.Ch | 0, this.Cl | 0, u | 0, d | 0), { h: w, l: g } = dt.add(this.Dh | 0, this.Dl | 0, w | 0, g | 0), { h: v, l: I } = dt.add(this.Eh | 0, this.El | 0, v | 0, I | 0), { h: S, l: D } = dt.add(this.Fh | 0, this.Fl | 0, S | 0, D | 0), { h: N, l: T } = dt.add(this.Gh | 0, this.Gl | 0, N | 0, T | 0), { h: O, l: _ } = dt.add(this.Hh | 0, this.Hl | 0, O | 0, _ | 0), this.set(r, i, s, o, u, d, w, g, v, I, S, D, N, T, O, _);
  }
  roundClean() {
    yn.fill(0), mn.fill(0);
  }
  destroy() {
    this.buffer.fill(0), this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
const Ld = /* @__PURE__ */ uo(() => new Od());
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Bo = /* @__PURE__ */ BigInt(0), Ci = /* @__PURE__ */ BigInt(1), _d = /* @__PURE__ */ BigInt(2);
function On(e) {
  return e instanceof Uint8Array || e != null && typeof e == "object" && e.constructor.name === "Uint8Array";
}
function Hr(e) {
  if (!On(e))
    throw new Error("Uint8Array expected");
}
function ln(e, t) {
  if (typeof t != "boolean")
    throw new Error(`${e} must be valid boolean, got "${t}".`);
}
const Gd = /* @__PURE__ */ Array.from({ length: 256 }, (e, t) => t.toString(16).padStart(2, "0"));
function Ln(e) {
  Hr(e);
  let t = "";
  for (let n = 0; n < e.length; n++)
    t += Gd[e[n]];
  return t;
}
function tr(e) {
  const t = e.toString(16);
  return t.length & 1 ? `0${t}` : t;
}
function Io(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  return BigInt(e === "" ? "0" : `0x${e}`);
}
const nn = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function Ca(e) {
  if (e >= nn._0 && e <= nn._9)
    return e - nn._0;
  if (e >= nn._A && e <= nn._F)
    return e - (nn._A - 10);
  if (e >= nn._a && e <= nn._f)
    return e - (nn._a - 10);
}
function ur(e) {
  if (typeof e != "string")
    throw new Error("hex string expected, got " + typeof e);
  const t = e.length, n = t / 2;
  if (t % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + t);
  const r = new Uint8Array(n);
  for (let i = 0, s = 0; i < n; i++, s += 2) {
    const o = Ca(e.charCodeAt(s)), u = Ca(e.charCodeAt(s + 1));
    if (o === void 0 || u === void 0) {
      const d = e[s] + e[s + 1];
      throw new Error('hex string expected, got non-hex character "' + d + '" at index ' + s);
    }
    r[i] = o * 16 + u;
  }
  return r;
}
function kn(e) {
  return Io(Ln(e));
}
function ir(e) {
  return Hr(e), Io(Ln(Uint8Array.from(e).reverse()));
}
function cr(e, t) {
  return ur(e.toString(16).padStart(t * 2, "0"));
}
function Dr(e, t) {
  return cr(e, t).reverse();
}
function zd(e) {
  return ur(tr(e));
}
function fe(e, t, n) {
  let r;
  if (typeof t == "string")
    try {
      r = ur(t);
    } catch (s) {
      throw new Error(`${e} must be valid hex string, got "${t}". Cause: ${s}`);
    }
  else if (On(t))
    r = Uint8Array.from(t);
  else
    throw new Error(`${e} must be hex string or Uint8Array`);
  const i = r.length;
  if (typeof n == "number" && i !== n)
    throw new Error(`${e} expected ${n} bytes, got ${i}`);
  return r;
}
function _n(...e) {
  let t = 0;
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    Hr(i), t += i.length;
  }
  const n = new Uint8Array(t);
  for (let r = 0, i = 0; r < e.length; r++) {
    const s = e[r];
    n.set(s, i), i += s.length;
  }
  return n;
}
function Hd(e, t) {
  if (e.length !== t.length)
    return !1;
  let n = 0;
  for (let r = 0; r < e.length; r++)
    n |= e[r] ^ t[r];
  return n === 0;
}
function Vd(e) {
  if (typeof e != "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof e}`);
  return new Uint8Array(new TextEncoder().encode(e));
}
const gs = (e) => typeof e == "bigint" && Bo <= e;
function Si(e, t, n) {
  return gs(e) && gs(t) && gs(n) && t <= e && e < n;
}
function Oe(e, t, n, r) {
  if (!Si(t, n, r))
    throw new Error(`expected valid ${e}: ${n} <= n < ${r}, got ${typeof t} ${t}`);
}
function fc(e) {
  let t;
  for (t = 0; e > Bo; e >>= Ci, t += 1)
    ;
  return t;
}
function Qd(e, t) {
  return e >> BigInt(t) & Ci;
}
function Kd(e, t, n) {
  return e | (n ? Ci : Bo) << BigInt(t);
}
const Mo = (e) => (_d << BigInt(e - 1)) - Ci, bs = (e) => new Uint8Array(e), Sa = (e) => Uint8Array.from(e);
function lc(e, t, n) {
  if (typeof e != "number" || e < 2)
    throw new Error("hashLen must be a number");
  if (typeof t != "number" || t < 2)
    throw new Error("qByteLen must be a number");
  if (typeof n != "function")
    throw new Error("hmacFn must be a function");
  let r = bs(e), i = bs(e), s = 0;
  const o = () => {
    r.fill(1), i.fill(0), s = 0;
  }, u = (...v) => n(i, r, ...v), d = (v = bs()) => {
    i = u(Sa([0]), v), r = u(), v.length !== 0 && (i = u(Sa([1]), v), r = u());
  }, w = () => {
    if (s++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let v = 0;
    const I = [];
    for (; v < t; ) {
      r = u();
      const S = r.slice();
      I.push(S), v += r.length;
    }
    return _n(...I);
  };
  return (v, I) => {
    o(), d(v);
    let S;
    for (; !(S = I(w())); )
      d();
    return o(), S;
  };
}
const qd = {
  bigint: (e) => typeof e == "bigint",
  function: (e) => typeof e == "function",
  boolean: (e) => typeof e == "boolean",
  string: (e) => typeof e == "string",
  stringOrUint8Array: (e) => typeof e == "string" || On(e),
  isSafeInteger: (e) => Number.isSafeInteger(e),
  array: (e) => Array.isArray(e),
  field: (e, t) => t.Fp.isValid(e),
  hash: (e) => typeof e == "function" && Number.isSafeInteger(e.outputLen)
};
function wr(e, t, n = {}) {
  const r = (i, s, o) => {
    const u = qd[s];
    if (typeof u != "function")
      throw new Error(`Invalid validator "${s}", expected function`);
    const d = e[i];
    if (!(o && d === void 0) && !u(d, e))
      throw new Error(`Invalid param ${String(i)}=${d} (${typeof d}), expected ${s}`);
  };
  for (const [i, s] of Object.entries(t))
    r(i, s, !1);
  for (const [i, s] of Object.entries(n))
    r(i, s, !0);
  return e;
}
const jd = () => {
  throw new Error("not implemented");
};
function Or(e) {
  const t = /* @__PURE__ */ new WeakMap();
  return (n, ...r) => {
    const i = t.get(n);
    if (i !== void 0)
      return i;
    const s = e(n, ...r);
    return t.set(n, s), s;
  };
}
const Yd = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  aInRange: Oe,
  abool: ln,
  abytes: Hr,
  bitGet: Qd,
  bitLen: fc,
  bitMask: Mo,
  bitSet: Kd,
  bytesToHex: Ln,
  bytesToNumberBE: kn,
  bytesToNumberLE: ir,
  concatBytes: _n,
  createHmacDrbg: lc,
  ensureBytes: fe,
  equalBytes: Hd,
  hexToBytes: ur,
  hexToNumber: Io,
  inRange: Si,
  isBytes: On,
  memoized: Or,
  notImplemented: jd,
  numberToBytesBE: cr,
  numberToBytesLE: Dr,
  numberToHexUnpadded: tr,
  numberToVarBytesBE: zd,
  utf8ToBytes: Vd,
  validateObject: wr
}, Symbol.toStringTag, { value: "Module" }));
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const de = BigInt(0), Gt = BigInt(1), Mn = BigInt(2), Zd = BigInt(3), js = BigInt(4), Ua = BigInt(5), Fa = BigInt(8);
BigInt(9);
BigInt(16);
function Dt(e, t) {
  const n = e % t;
  return n >= de ? n : t + n;
}
function Jd(e, t, n) {
  if (n <= de || t < de)
    throw new Error("Expected power/modulo > 0");
  if (n === Gt)
    return de;
  let r = Gt;
  for (; t > de; )
    t & Gt && (r = r * e % n), e = e * e % n, t >>= Gt;
  return r;
}
function zt(e, t, n) {
  let r = e;
  for (; t-- > de; )
    r *= r, r %= n;
  return r;
}
function Ys(e, t) {
  if (e === de || t <= de)
    throw new Error(`invert: expected positive integers, got n=${e} mod=${t}`);
  let n = Dt(e, t), r = t, i = de, s = Gt;
  for (; n !== de; ) {
    const u = r / n, d = r % n, w = i - s * u;
    r = n, n = d, i = s, s = w;
  }
  if (r !== Gt)
    throw new Error("invert: does not exist");
  return Dt(i, t);
}
function Xd(e) {
  const t = (e - Gt) / Mn;
  let n, r, i;
  for (n = e - Gt, r = 0; n % Mn === de; n /= Mn, r++)
    ;
  for (i = Mn; i < e && Jd(i, t, e) !== e - Gt; i++)
    ;
  if (r === 1) {
    const o = (e + Gt) / js;
    return function(d, w) {
      const g = d.pow(w, o);
      if (!d.eql(d.sqr(g), w))
        throw new Error("Cannot find square root");
      return g;
    };
  }
  const s = (n + Gt) / Mn;
  return function(u, d) {
    if (u.pow(d, t) === u.neg(u.ONE))
      throw new Error("Cannot find square root");
    let w = r, g = u.pow(u.mul(u.ONE, i), n), v = u.pow(d, s), I = u.pow(d, n);
    for (; !u.eql(I, u.ONE); ) {
      if (u.eql(I, u.ZERO))
        return u.ZERO;
      let S = 1;
      for (let N = u.sqr(I); S < w && !u.eql(N, u.ONE); S++)
        N = u.sqr(N);
      const D = u.pow(g, Gt << BigInt(w - S - 1));
      g = u.sqr(D), v = u.mul(v, D), I = u.mul(I, g), w = S;
    }
    return v;
  };
}
function Wd(e) {
  if (e % js === Zd) {
    const t = (e + Gt) / js;
    return function(r, i) {
      const s = r.pow(i, t);
      if (!r.eql(r.sqr(s), i))
        throw new Error("Cannot find square root");
      return s;
    };
  }
  if (e % Fa === Ua) {
    const t = (e - Ua) / Fa;
    return function(r, i) {
      const s = r.mul(i, Mn), o = r.pow(s, t), u = r.mul(i, o), d = r.mul(r.mul(u, Mn), o), w = r.mul(u, r.sub(d, r.ONE));
      if (!r.eql(r.sqr(w), i))
        throw new Error("Cannot find square root");
      return w;
    };
  }
  return Xd(e);
}
const $d = (e, t) => (Dt(e, t) & Gt) === Gt, tp = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function ep(e) {
  const t = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  }, n = tp.reduce((r, i) => (r[i] = "function", r), t);
  return wr(e, n);
}
function np(e, t, n) {
  if (n < de)
    throw new Error("Expected power > 0");
  if (n === de)
    return e.ONE;
  if (n === Gt)
    return t;
  let r = e.ONE, i = t;
  for (; n > de; )
    n & Gt && (r = e.mul(r, i)), i = e.sqr(i), n >>= Gt;
  return r;
}
function rp(e, t) {
  const n = new Array(t.length), r = t.reduce((s, o, u) => e.is0(o) ? s : (n[u] = s, e.mul(s, o)), e.ONE), i = e.inv(r);
  return t.reduceRight((s, o, u) => e.is0(o) ? s : (n[u] = e.mul(s, n[u]), e.mul(s, o)), i), n;
}
function hc(e, t) {
  const n = t !== void 0 ? t : e.toString(2).length, r = Math.ceil(n / 8);
  return { nBitLength: n, nByteLength: r };
}
function Ui(e, t, n = !1, r = {}) {
  if (e <= de)
    throw new Error(`Expected Field ORDER > 0, got ${e}`);
  const { nBitLength: i, nByteLength: s } = hc(e, t);
  if (s > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const o = Wd(e), u = Object.freeze({
    ORDER: e,
    BITS: i,
    BYTES: s,
    MASK: Mo(i),
    ZERO: de,
    ONE: Gt,
    create: (d) => Dt(d, e),
    isValid: (d) => {
      if (typeof d != "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof d}`);
      return de <= d && d < e;
    },
    is0: (d) => d === de,
    isOdd: (d) => (d & Gt) === Gt,
    neg: (d) => Dt(-d, e),
    eql: (d, w) => d === w,
    sqr: (d) => Dt(d * d, e),
    add: (d, w) => Dt(d + w, e),
    sub: (d, w) => Dt(d - w, e),
    mul: (d, w) => Dt(d * w, e),
    pow: (d, w) => np(u, d, w),
    div: (d, w) => Dt(d * Ys(w, e), e),
    // Same as above, but doesn't normalize
    sqrN: (d) => d * d,
    addN: (d, w) => d + w,
    subN: (d, w) => d - w,
    mulN: (d, w) => d * w,
    inv: (d) => Ys(d, e),
    sqrt: r.sqrt || ((d) => o(u, d)),
    invertBatch: (d) => rp(u, d),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (d, w, g) => g ? w : d,
    toBytes: (d) => n ? Dr(d, s) : cr(d, s),
    fromBytes: (d) => {
      if (d.length !== s)
        throw new Error(`Fp.fromBytes: expected ${s}, got ${d.length}`);
      return n ? ir(d) : kn(d);
    }
  });
  return Object.freeze(u);
}
function dc(e) {
  if (typeof e != "bigint")
    throw new Error("field order must be bigint");
  const t = e.toString(2).length;
  return Math.ceil(t / 8);
}
function pc(e) {
  const t = dc(e);
  return t + Math.ceil(t / 2);
}
function ip(e, t, n = !1) {
  const r = e.length, i = dc(t), s = pc(t);
  if (r < 16 || r < s || r > 1024)
    throw new Error(`expected ${s}-1024 bytes of input, got ${r}`);
  const o = n ? kn(e) : ir(e), u = Dt(o, t - Gt) + Gt;
  return n ? Dr(u, i) : cr(u, i);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const sp = BigInt(0), As = BigInt(1), xs = /* @__PURE__ */ new WeakMap(), ka = /* @__PURE__ */ new WeakMap();
function yc(e, t) {
  const n = (s, o) => {
    const u = o.negate();
    return s ? u : o;
  }, r = (s) => {
    if (!Number.isSafeInteger(s) || s <= 0 || s > t)
      throw new Error(`Wrong window size=${s}, should be [1..${t}]`);
  }, i = (s) => {
    r(s);
    const o = Math.ceil(t / s) + 1, u = 2 ** (s - 1);
    return { windows: o, windowSize: u };
  };
  return {
    constTimeNegate: n,
    // non-const time multiplication ladder
    unsafeLadder(s, o) {
      let u = e.ZERO, d = s;
      for (; o > sp; )
        o & As && (u = u.add(d)), d = d.double(), o >>= As;
      return u;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(s, o) {
      const { windows: u, windowSize: d } = i(o), w = [];
      let g = s, v = g;
      for (let I = 0; I < u; I++) {
        v = g, w.push(v);
        for (let S = 1; S < d; S++)
          v = v.add(g), w.push(v);
        g = v.double();
      }
      return w;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(s, o, u) {
      const { windows: d, windowSize: w } = i(s);
      let g = e.ZERO, v = e.BASE;
      const I = BigInt(2 ** s - 1), S = 2 ** s, D = BigInt(s);
      for (let N = 0; N < d; N++) {
        const T = N * w;
        let O = Number(u & I);
        u >>= D, O > w && (O -= S, u += As);
        const _ = T, k = T + Math.abs(O) - 1, V = N % 2 !== 0, H = O < 0;
        O === 0 ? v = v.add(n(V, o[_])) : g = g.add(n(H, o[k]));
      }
      return { p: g, f: v };
    },
    wNAFCached(s, o, u) {
      const d = ka.get(s) || 1;
      let w = xs.get(s);
      return w || (w = this.precomputeWindow(s, d), d !== 1 && xs.set(s, u(w))), this.wNAF(d, w, o);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(s, o) {
      r(o), ka.set(s, o), xs.delete(s);
    }
  };
}
function mc(e, t, n, r) {
  if (!Array.isArray(n) || !Array.isArray(r) || r.length !== n.length)
    throw new Error("arrays of points and scalars must have equal length");
  r.forEach((g, v) => {
    if (!t.isValid(g))
      throw new Error(`wrong scalar at index ${v}`);
  }), n.forEach((g, v) => {
    if (!(g instanceof e))
      throw new Error(`wrong point at index ${v}`);
  });
  const i = fc(BigInt(n.length)), s = i > 12 ? i - 3 : i > 4 ? i - 2 : i ? 2 : 1, o = (1 << s) - 1, u = new Array(o + 1).fill(e.ZERO), d = Math.floor((t.BITS - 1) / s) * s;
  let w = e.ZERO;
  for (let g = d; g >= 0; g -= s) {
    u.fill(e.ZERO);
    for (let I = 0; I < r.length; I++) {
      const S = r[I], D = Number(S >> BigInt(g) & BigInt(o));
      u[D] = u[D].add(n[I]);
    }
    let v = e.ZERO;
    for (let I = u.length - 1, S = e.ZERO; I > 0; I--)
      S = S.add(u[I]), v = v.add(S);
    if (w = w.add(v), g !== 0)
      for (let I = 0; I < s; I++)
        w = w.double();
  }
  return w;
}
function To(e) {
  return ep(e.Fp), wr(e, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  }), Object.freeze({
    ...hc(e.n, e.nBitLength),
    ...e,
    p: e.Fp.ORDER
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Ge = BigInt(0), Te = BigInt(1), Wr = BigInt(2), op = BigInt(8), ap = { zip215: !0 };
function up(e) {
  const t = To(e);
  return wr(e, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  }), Object.freeze({ ...t });
}
function cp(e) {
  const t = up(e), { Fp: n, n: r, prehash: i, hash: s, randomBytes: o, nByteLength: u, h: d } = t, w = Wr << BigInt(u * 8) - Te, g = n.create, v = Ui(t.n, t.nBitLength), I = t.uvRatio || ((p, y) => {
    try {
      return { isValid: !0, value: n.sqrt(p * n.inv(y)) };
    } catch {
      return { isValid: !1, value: Ge };
    }
  }), S = t.adjustScalarBytes || ((p) => p), D = t.domain || ((p, y, A) => {
    if (ln("phflag", A), y.length || A)
      throw new Error("Contexts/pre-hash are not supported");
    return p;
  });
  function N(p, y) {
    Oe("coordinate " + p, y, Ge, w);
  }
  function T(p) {
    if (!(p instanceof k))
      throw new Error("ExtendedPoint expected");
  }
  const O = Or((p, y) => {
    const { ex: A, ey: B, ez: C } = p, b = p.is0();
    y == null && (y = b ? op : n.inv(C));
    const l = g(A * y), E = g(B * y), Q = g(C * y);
    if (b)
      return { x: Ge, y: Te };
    if (Q !== Te)
      throw new Error("invZ was invalid");
    return { x: l, y: E };
  }), _ = Or((p) => {
    const { a: y, d: A } = t;
    if (p.is0())
      throw new Error("bad point: ZERO");
    const { ex: B, ey: C, ez: b, et: l } = p, E = g(B * B), Q = g(C * C), q = g(b * b), Z = g(q * q), pt = g(E * y), nt = g(q * g(pt + Q)), at = g(Z + g(A * g(E * Q)));
    if (nt !== at)
      throw new Error("bad point: equation left != right (1)");
    const Qt = g(B * C), yt = g(b * l);
    if (Qt !== yt)
      throw new Error("bad point: equation left != right (2)");
    return !0;
  });
  class k {
    constructor(y, A, B, C) {
      this.ex = y, this.ey = A, this.ez = B, this.et = C, N("x", y), N("y", A), N("z", B), N("t", C), Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(y) {
      if (y instanceof k)
        throw new Error("extended point not allowed");
      const { x: A, y: B } = y || {};
      return N("x", A), N("y", B), new k(A, B, Te, g(A * B));
    }
    static normalizeZ(y) {
      const A = n.invertBatch(y.map((B) => B.ez));
      return y.map((B, C) => B.toAffine(A[C])).map(k.fromAffine);
    }
    // Multiscalar Multiplication
    static msm(y, A) {
      return mc(k, v, y, A);
    }
    // "Private method", don't use it directly
    _setWindowSize(y) {
      z.setWindowSize(this, y);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      _(this);
    }
    // Compare one point to another.
    equals(y) {
      T(y);
      const { ex: A, ey: B, ez: C } = this, { ex: b, ey: l, ez: E } = y, Q = g(A * E), q = g(b * C), Z = g(B * E), pt = g(l * C);
      return Q === q && Z === pt;
    }
    is0() {
      return this.equals(k.ZERO);
    }
    negate() {
      return new k(g(-this.ex), this.ey, this.ez, g(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: y } = t, { ex: A, ey: B, ez: C } = this, b = g(A * A), l = g(B * B), E = g(Wr * g(C * C)), Q = g(y * b), q = A + B, Z = g(g(q * q) - b - l), pt = Q + l, nt = pt - E, at = Q - l, Qt = g(Z * nt), yt = g(pt * at), ct = g(Z * at), Kt = g(nt * pt);
      return new k(Qt, yt, Kt, ct);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(y) {
      T(y);
      const { a: A, d: B } = t, { ex: C, ey: b, ez: l, et: E } = this, { ex: Q, ey: q, ez: Z, et: pt } = y;
      if (A === BigInt(-1)) {
        const Ut = g((b - C) * (q + Q)), Mt = g((b + C) * (q - Q)), pe = g(Mt - Ut);
        if (pe === Ge)
          return this.double();
        const Ct = g(l * Wr * pt), kt = g(E * Wr * Z), Ie = kt + Ct, Nt = Mt + Ut, m = kt - Ct, c = g(Ie * pe), f = g(Nt * m), x = g(Ie * m), U = g(pe * Nt);
        return new k(c, f, U, x);
      }
      const nt = g(C * Q), at = g(b * q), Qt = g(E * B * pt), yt = g(l * Z), ct = g((C + b) * (Q + q) - nt - at), Kt = yt - Qt, At = yt + Qt, It = g(at - A * nt), Qn = g(ct * Kt), St = g(At * It), Pt = g(ct * It), Kn = g(Kt * At);
      return new k(Qn, St, Kn, Pt);
    }
    subtract(y) {
      return this.add(y.negate());
    }
    wNAF(y) {
      return z.wNAFCached(this, y, k.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(y) {
      const A = y;
      Oe("scalar", A, Te, r);
      const { p: B, f: C } = this.wNAF(A);
      return k.normalizeZ([B, C])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(y) {
      const A = y;
      return Oe("scalar", A, Ge, r), A === Ge ? H : this.equals(H) || A === Te ? this : this.equals(V) ? this.wNAF(A).p : z.unsafeLadder(this, A);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(d).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return z.unsafeLadder(this, r).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(y) {
      return O(this, y);
    }
    clearCofactor() {
      const { h: y } = t;
      return y === Te ? this : this.multiplyUnsafe(y);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(y, A = !1) {
      const { d: B, a: C } = t, b = n.BYTES;
      y = fe("pointHex", y, b), ln("zip215", A);
      const l = y.slice(), E = y[b - 1];
      l[b - 1] = E & -129;
      const Q = ir(l), q = A ? w : n.ORDER;
      Oe("pointHex.y", Q, Ge, q);
      const Z = g(Q * Q), pt = g(Z - Te), nt = g(B * Z - C);
      let { isValid: at, value: Qt } = I(pt, nt);
      if (!at)
        throw new Error("Point.fromHex: invalid y coordinate");
      const yt = (Qt & Te) === Te, ct = (E & 128) !== 0;
      if (!A && Qt === Ge && ct)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      return ct !== yt && (Qt = g(-Qt)), k.fromAffine({ x: Qt, y: Q });
    }
    static fromPrivateKey(y) {
      return J(y).point;
    }
    toRawBytes() {
      const { x: y, y: A } = this.toAffine(), B = Dr(A, n.BYTES);
      return B[B.length - 1] |= y & Te ? 128 : 0, B;
    }
    toHex() {
      return Ln(this.toRawBytes());
    }
  }
  k.BASE = new k(t.Gx, t.Gy, Te, g(t.Gx * t.Gy)), k.ZERO = new k(Ge, Te, Te, Ge);
  const { BASE: V, ZERO: H } = k, z = yc(k, u * 8);
  function j(p) {
    return Dt(p, r);
  }
  function Y(p) {
    return j(ir(p));
  }
  function J(p) {
    const y = u;
    p = fe("private key", p, y);
    const A = fe("hashed private key", s(p), 2 * y), B = S(A.slice(0, y)), C = A.slice(y, 2 * y), b = Y(B), l = V.multiply(b), E = l.toRawBytes();
    return { head: B, prefix: C, scalar: b, point: l, pointBytes: E };
  }
  function gt(p) {
    return J(p).pointBytes;
  }
  function $(p = new Uint8Array(), ...y) {
    const A = _n(...y);
    return Y(s(D(A, fe("context", p), !!i)));
  }
  function ot(p, y, A = {}) {
    p = fe("message", p), i && (p = i(p));
    const { prefix: B, scalar: C, pointBytes: b } = J(y), l = $(A.context, B, p), E = V.multiply(l).toRawBytes(), Q = $(A.context, E, b, p), q = j(l + Q * C);
    Oe("signature.s", q, Ge, r);
    const Z = _n(E, Dr(q, n.BYTES));
    return fe("result", Z, u * 2);
  }
  const M = ap;
  function a(p, y, A, B = M) {
    const { context: C, zip215: b } = B, l = n.BYTES;
    p = fe("signature", p, 2 * l), y = fe("message", y), b !== void 0 && ln("zip215", b), i && (y = i(y));
    const E = ir(p.slice(l, 2 * l));
    let Q, q, Z;
    try {
      Q = k.fromHex(A, b), q = k.fromHex(p.slice(0, l), b), Z = V.multiplyUnsafe(E);
    } catch {
      return !1;
    }
    if (!b && Q.isSmallOrder())
      return !1;
    const pt = $(C, q.toRawBytes(), Q.toRawBytes(), y);
    return q.add(Q.multiplyUnsafe(pt)).subtract(Z).clearCofactor().equals(k.ZERO);
  }
  return V._setWindowSize(8), {
    CURVE: t,
    getPublicKey: gt,
    sign: ot,
    verify: a,
    ExtendedPoint: k,
    utils: {
      getExtendedPublicKey: J,
      // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
      randomPrivateKey: () => o(n.BYTES),
      /**
       * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
       * values. This slows down first getPublicKey() by milliseconds (see Speed section),
       * but allows to speed-up subsequent getPublicKey() calls up to 20x.
       * @param windowSize 2, 4, 8, 16
       */
      precompute(p = 8, y = k.BASE) {
        return y._setWindowSize(p), y.multiply(BigInt(3)), y;
      }
    }
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const Co = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949"), Na = /* @__PURE__ */ BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
BigInt(0);
const fp = BigInt(1), Ra = BigInt(2);
BigInt(3);
const lp = BigInt(5), hp = BigInt(8);
function dp(e) {
  const t = BigInt(10), n = BigInt(20), r = BigInt(40), i = BigInt(80), s = Co, u = e * e % s * e % s, d = zt(u, Ra, s) * u % s, w = zt(d, fp, s) * e % s, g = zt(w, lp, s) * w % s, v = zt(g, t, s) * g % s, I = zt(v, n, s) * v % s, S = zt(I, r, s) * I % s, D = zt(S, i, s) * S % s, N = zt(D, i, s) * S % s, T = zt(N, t, s) * g % s;
  return { pow_p_5_8: zt(T, Ra, s) * e % s, b2: u };
}
function pp(e) {
  return e[0] &= 248, e[31] &= 127, e[31] |= 64, e;
}
function yp(e, t) {
  const n = Co, r = Dt(t * t * t, n), i = Dt(r * r * t, n), s = dp(e * i).pow_p_5_8;
  let o = Dt(e * r * s, n);
  const u = Dt(t * o * o, n), d = o, w = Dt(o * Na, n), g = u === e, v = u === Dt(-e, n), I = u === Dt(-e * Na, n);
  return g && (o = d), (v || I) && (o = w), $d(o, n) && (o = Dt(-o, n)), { isValid: g || v, value: o };
}
const mp = /* @__PURE__ */ (() => Ui(Co, void 0, !0))(), wp = /* @__PURE__ */ (() => ({
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
  Fp: mp,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: hp,
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: Ld,
  randomBytes: pu,
  adjustScalarBytes: pp,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio: yp
}))(), wc = /* @__PURE__ */ (() => cp(wp))();
var Zs = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var n = Ot, r = n.Buffer;
  function i(o, u) {
    for (var d in o)
      u[d] = o[d];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? e.exports = n : (i(n, t), t.Buffer = s);
  function s(o, u, d) {
    return r(o, u, d);
  }
  s.prototype = Object.create(r.prototype), i(r, s), s.from = function(o, u, d) {
    if (typeof o == "number")
      throw new TypeError("Argument must not be a number");
    return r(o, u, d);
  }, s.alloc = function(o, u, d) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    var w = r(o);
    return u !== void 0 ? typeof d == "string" ? w.fill(u, d) : w.fill(u) : w.fill(0), w;
  }, s.allocUnsafe = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return r(o);
  }, s.allocUnsafeSlow = function(o) {
    if (typeof o != "number")
      throw new TypeError("Argument must be a number");
    return n.SlowBuffer(o);
  };
})(Zs, Zs.exports);
var gp = Zs.exports, $r = gp.Buffer;
function bp(e) {
  if (e.length >= 255)
    throw new TypeError("Alphabet too long");
  for (var t = new Uint8Array(256), n = 0; n < t.length; n++)
    t[n] = 255;
  for (var r = 0; r < e.length; r++) {
    var i = e.charAt(r), s = i.charCodeAt(0);
    if (t[s] !== 255)
      throw new TypeError(i + " is ambiguous");
    t[s] = r;
  }
  var o = e.length, u = e.charAt(0), d = Math.log(o) / Math.log(256), w = Math.log(256) / Math.log(o);
  function g(S) {
    if ((Array.isArray(S) || S instanceof Uint8Array) && (S = $r.from(S)), !$r.isBuffer(S))
      throw new TypeError("Expected Buffer");
    if (S.length === 0)
      return "";
    for (var D = 0, N = 0, T = 0, O = S.length; T !== O && S[T] === 0; )
      T++, D++;
    for (var _ = (O - T) * w + 1 >>> 0, k = new Uint8Array(_); T !== O; ) {
      for (var V = S[T], H = 0, z = _ - 1; (V !== 0 || H < N) && z !== -1; z--, H++)
        V += 256 * k[z] >>> 0, k[z] = V % o >>> 0, V = V / o >>> 0;
      if (V !== 0)
        throw new Error("Non-zero carry");
      N = H, T++;
    }
    for (var j = _ - N; j !== _ && k[j] === 0; )
      j++;
    for (var Y = u.repeat(D); j < _; ++j)
      Y += e.charAt(k[j]);
    return Y;
  }
  function v(S) {
    if (typeof S != "string")
      throw new TypeError("Expected String");
    if (S.length === 0)
      return $r.alloc(0);
    for (var D = 0, N = 0, T = 0; S[D] === u; )
      N++, D++;
    for (var O = (S.length - D) * d + 1 >>> 0, _ = new Uint8Array(O); S[D]; ) {
      var k = t[S.charCodeAt(D)];
      if (k === 255)
        return;
      for (var V = 0, H = O - 1; (k !== 0 || V < T) && H !== -1; H--, V++)
        k += o * _[H] >>> 0, _[H] = k % 256 >>> 0, k = k / 256 >>> 0;
      if (k !== 0)
        throw new Error("Non-zero carry");
      T = V, D++;
    }
    for (var z = O - T; z !== O && _[z] === 0; )
      z++;
    var j = $r.allocUnsafe(N + (O - z));
    j.fill(0, 0, N);
    for (var Y = N; z !== O; )
      j[Y++] = _[z++];
    return j;
  }
  function I(S) {
    var D = v(S);
    if (D)
      return D;
    throw new Error("Non-base" + o + " character");
  }
  return {
    encode: g,
    decodeUnsafe: v,
    decode: I
  };
}
var Ap = bp, xp = Ap, Ep = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz", gc = xp(Ep);
const Pa = /* @__PURE__ */ ac(gc);
var we = {};
function an(e, t, n) {
  return t <= e && e <= n;
}
function Fi(e) {
  if (e === void 0)
    return {};
  if (e === Object(e))
    return e;
  throw TypeError("Could not convert argument to dictionary");
}
function vp(e) {
  for (var t = String(e), n = t.length, r = 0, i = []; r < n; ) {
    var s = t.charCodeAt(r);
    if (s < 55296 || s > 57343)
      i.push(s);
    else if (56320 <= s && s <= 57343)
      i.push(65533);
    else if (55296 <= s && s <= 56319)
      if (r === n - 1)
        i.push(65533);
      else {
        var o = e.charCodeAt(r + 1);
        if (56320 <= o && o <= 57343) {
          var u = s & 1023, d = o & 1023;
          i.push(65536 + (u << 10) + d), r += 1;
        } else
          i.push(65533);
      }
    r += 1;
  }
  return i;
}
function Bp(e) {
  for (var t = "", n = 0; n < e.length; ++n) {
    var r = e[n];
    r <= 65535 ? t += String.fromCharCode(r) : (r -= 65536, t += String.fromCharCode(
      (r >> 10) + 55296,
      (r & 1023) + 56320
    ));
  }
  return t;
}
var pi = -1;
function So(e) {
  this.tokens = [].slice.call(e);
}
So.prototype = {
  /**
   * @return {boolean} True if end-of-stream has been hit.
   */
  endOfStream: function() {
    return !this.tokens.length;
  },
  /**
   * When a token is read from a stream, the first token in the
   * stream must be returned and subsequently removed, and
   * end-of-stream must be returned otherwise.
   *
   * @return {number} Get the next token from the stream, or
   * end_of_stream.
   */
  read: function() {
    return this.tokens.length ? this.tokens.shift() : pi;
  },
  /**
   * When one or more tokens are prepended to a stream, those tokens
   * must be inserted, in given order, before the first token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.
   */
  prepend: function(e) {
    if (Array.isArray(e))
      for (var t = (
        /**@type {!Array.<number>}*/
        e
      ); t.length; )
        this.tokens.unshift(t.pop());
    else
      this.tokens.unshift(e);
  },
  /**
   * When one or more tokens are pushed to a stream, those tokens
   * must be inserted, in given order, after the last token in the
   * stream.
   *
   * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.
   */
  push: function(e) {
    if (Array.isArray(e))
      for (var t = (
        /**@type {!Array.<number>}*/
        e
      ); t.length; )
        this.tokens.push(t.shift());
    else
      this.tokens.push(e);
  }
};
var fr = -1;
function Es(e, t) {
  if (e)
    throw TypeError("Decoder error");
  return t || 65533;
}
var yi = "utf-8";
function mi(e, t) {
  if (!(this instanceof mi))
    return new mi(e, t);
  if (e = e !== void 0 ? String(e).toLowerCase() : yi, e !== yi)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  t = Fi(t), this._streaming = !1, this._BOMseen = !1, this._decoder = null, this._fatal = !!t.fatal, this._ignoreBOM = !!t.ignoreBOM, Object.defineProperty(this, "encoding", { value: "utf-8" }), Object.defineProperty(this, "fatal", { value: this._fatal }), Object.defineProperty(this, "ignoreBOM", { value: this._ignoreBOM });
}
mi.prototype = {
  /**
   * @param {ArrayBufferView=} input The buffer of bytes to decode.
   * @param {Object=} options
   * @return {string} The decoded string.
   */
  decode: function(t, n) {
    var r;
    typeof t == "object" && t instanceof ArrayBuffer ? r = new Uint8Array(t) : typeof t == "object" && "buffer" in t && t.buffer instanceof ArrayBuffer ? r = new Uint8Array(
      t.buffer,
      t.byteOffset,
      t.byteLength
    ) : r = new Uint8Array(0), n = Fi(n), this._streaming || (this._decoder = new Ip({ fatal: this._fatal }), this._BOMseen = !1), this._streaming = !!n.stream;
    for (var i = new So(r), s = [], o; !i.endOfStream() && (o = this._decoder.handler(i, i.read()), o !== fr); )
      o !== null && (Array.isArray(o) ? s.push.apply(
        s,
        /**@type {!Array.<number>}*/
        o
      ) : s.push(o));
    if (!this._streaming) {
      do {
        if (o = this._decoder.handler(i, i.read()), o === fr)
          break;
        o !== null && (Array.isArray(o) ? s.push.apply(
          s,
          /**@type {!Array.<number>}*/
          o
        ) : s.push(o));
      } while (!i.endOfStream());
      this._decoder = null;
    }
    return s.length && ["utf-8"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen && (s[0] === 65279 ? (this._BOMseen = !0, s.shift()) : this._BOMseen = !0), Bp(s);
  }
};
function wi(e, t) {
  if (!(this instanceof wi))
    return new wi(e, t);
  if (e = e !== void 0 ? String(e).toLowerCase() : yi, e !== yi)
    throw new Error("Encoding not supported. Only utf-8 is supported");
  t = Fi(t), this._streaming = !1, this._encoder = null, this._options = { fatal: !!t.fatal }, Object.defineProperty(this, "encoding", { value: "utf-8" });
}
wi.prototype = {
  /**
   * @param {string=} opt_string The string to encode.
   * @param {Object=} options
   * @return {Uint8Array} Encoded bytes, as a Uint8Array.
   */
  encode: function(t, n) {
    t = t ? String(t) : "", n = Fi(n), this._streaming || (this._encoder = new Mp(this._options)), this._streaming = !!n.stream;
    for (var r = [], i = new So(vp(t)), s; !i.endOfStream() && (s = this._encoder.handler(i, i.read()), s !== fr); )
      Array.isArray(s) ? r.push.apply(
        r,
        /**@type {!Array.<number>}*/
        s
      ) : r.push(s);
    if (!this._streaming) {
      for (; s = this._encoder.handler(i, i.read()), s !== fr; )
        Array.isArray(s) ? r.push.apply(
          r,
          /**@type {!Array.<number>}*/
          s
        ) : r.push(s);
      this._encoder = null;
    }
    return new Uint8Array(r);
  }
};
function Ip(e) {
  var t = e.fatal, n = 0, r = 0, i = 0, s = 128, o = 191;
  this.handler = function(u, d) {
    if (d === pi && i !== 0)
      return i = 0, Es(t);
    if (d === pi)
      return fr;
    if (i === 0) {
      if (an(d, 0, 127))
        return d;
      if (an(d, 194, 223))
        i = 1, n = d - 192;
      else if (an(d, 224, 239))
        d === 224 && (s = 160), d === 237 && (o = 159), i = 2, n = d - 224;
      else if (an(d, 240, 244))
        d === 240 && (s = 144), d === 244 && (o = 143), i = 3, n = d - 240;
      else
        return Es(t);
      return n = n << 6 * i, null;
    }
    if (!an(d, s, o))
      return n = i = r = 0, s = 128, o = 191, u.prepend(d), Es(t);
    if (s = 128, o = 191, r += 1, n += d - 128 << 6 * (i - r), r !== i)
      return null;
    var w = n;
    return n = i = r = 0, w;
  };
}
function Mp(e) {
  e.fatal, this.handler = function(t, n) {
    if (n === pi)
      return fr;
    if (an(n, 0, 127))
      return n;
    var r, i;
    an(n, 128, 2047) ? (r = 1, i = 192) : an(n, 2048, 65535) ? (r = 2, i = 224) : an(n, 65536, 1114111) && (r = 3, i = 240);
    for (var s = [(n >> 6 * r) + i]; r > 0; ) {
      var o = n >> 6 * (r - 1);
      s.push(128 | o & 63), r -= 1;
    }
    return s;
  };
}
const Tp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  TextDecoder: mi,
  TextEncoder: wi
}, Symbol.toStringTag, { value: "Module" })), Cp = /* @__PURE__ */ xo(Tp);
var Sp = Qe && Qe.__createBinding || (Object.create ? function(e, t, n, r) {
  r === void 0 && (r = n), Object.defineProperty(e, r, { enumerable: !0, get: function() {
    return t[n];
  } });
} : function(e, t, n, r) {
  r === void 0 && (r = n), e[r] = t[n];
}), Up = Qe && Qe.__setModuleDefault || (Object.create ? function(e, t) {
  Object.defineProperty(e, "default", { enumerable: !0, value: t });
} : function(e, t) {
  e.default = t;
}), We = Qe && Qe.__decorate || function(e, t, n, r) {
  var i = arguments.length, s = i < 3 ? t : r === null ? r = Object.getOwnPropertyDescriptor(t, n) : r, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    s = Reflect.decorate(e, t, n, r);
  else
    for (var u = e.length - 1; u >= 0; u--)
      (o = e[u]) && (s = (i < 3 ? o(s) : i > 3 ? o(t, n, s) : o(t, n)) || s);
  return i > 3 && s && Object.defineProperty(t, n, s), s;
}, Fp = Qe && Qe.__importStar || function(e) {
  if (e && e.__esModule)
    return e;
  var t = {};
  if (e != null)
    for (var n in e)
      n !== "default" && Object.hasOwnProperty.call(e, n) && Sp(t, e, n);
  return Up(t, e), t;
}, bc = Qe && Qe.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(we, "__esModule", { value: !0 });
var Ac = we.deserializeUnchecked = Mc = we.deserialize = Ic = we.serialize = we.BinaryReader = we.BinaryWriter = we.BorshError = we.baseDecode = we.baseEncode = void 0;
const gn = bc(uc), xc = bc(gc), kp = Fp(Cp), Np = typeof TextDecoder != "function" ? kp.TextDecoder : TextDecoder, Rp = new Np("utf-8", { fatal: !0 });
function Pp(e) {
  return typeof e == "string" && (e = Buffer.from(e, "utf8")), xc.default.encode(Buffer.from(e));
}
we.baseEncode = Pp;
function Dp(e) {
  return Buffer.from(xc.default.decode(e));
}
we.baseDecode = Dp;
const vs = 1024;
class Be extends Error {
  constructor(t) {
    super(t), this.fieldPath = [], this.originalMessage = t;
  }
  addToFieldPath(t) {
    this.fieldPath.splice(0, 0, t), this.message = this.originalMessage + ": " + this.fieldPath.join(".");
  }
}
we.BorshError = Be;
class Ec {
  constructor() {
    this.buf = Buffer.alloc(vs), this.length = 0;
  }
  maybeResize() {
    this.buf.length < 16 + this.length && (this.buf = Buffer.concat([this.buf, Buffer.alloc(vs)]));
  }
  writeU8(t) {
    this.maybeResize(), this.buf.writeUInt8(t, this.length), this.length += 1;
  }
  writeU16(t) {
    this.maybeResize(), this.buf.writeUInt16LE(t, this.length), this.length += 2;
  }
  writeU32(t) {
    this.maybeResize(), this.buf.writeUInt32LE(t, this.length), this.length += 4;
  }
  writeU64(t) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new gn.default(t).toArray("le", 8)));
  }
  writeU128(t) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new gn.default(t).toArray("le", 16)));
  }
  writeU256(t) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new gn.default(t).toArray("le", 32)));
  }
  writeU512(t) {
    this.maybeResize(), this.writeBuffer(Buffer.from(new gn.default(t).toArray("le", 64)));
  }
  writeBuffer(t) {
    this.buf = Buffer.concat([
      Buffer.from(this.buf.subarray(0, this.length)),
      t,
      Buffer.alloc(vs)
    ]), this.length += t.length;
  }
  writeString(t) {
    this.maybeResize();
    const n = Buffer.from(t, "utf8");
    this.writeU32(n.length), this.writeBuffer(n);
  }
  writeFixedArray(t) {
    this.writeBuffer(Buffer.from(t));
  }
  writeArray(t, n) {
    this.maybeResize(), this.writeU32(t.length);
    for (const r of t)
      this.maybeResize(), n(r);
  }
  toArray() {
    return this.buf.subarray(0, this.length);
  }
}
we.BinaryWriter = Ec;
function $e(e, t, n) {
  const r = n.value;
  n.value = function(...i) {
    try {
      return r.apply(this, i);
    } catch (s) {
      if (s instanceof RangeError) {
        const o = s.code;
        if (["ERR_BUFFER_OUT_OF_BOUNDS", "ERR_OUT_OF_RANGE"].indexOf(o) >= 0)
          throw new Be("Reached the end of buffer when deserializing");
      }
      throw s;
    }
  };
}
class ke {
  constructor(t) {
    this.buf = t, this.offset = 0;
  }
  readU8() {
    const t = this.buf.readUInt8(this.offset);
    return this.offset += 1, t;
  }
  readU16() {
    const t = this.buf.readUInt16LE(this.offset);
    return this.offset += 2, t;
  }
  readU32() {
    const t = this.buf.readUInt32LE(this.offset);
    return this.offset += 4, t;
  }
  readU64() {
    const t = this.readBuffer(8);
    return new gn.default(t, "le");
  }
  readU128() {
    const t = this.readBuffer(16);
    return new gn.default(t, "le");
  }
  readU256() {
    const t = this.readBuffer(32);
    return new gn.default(t, "le");
  }
  readU512() {
    const t = this.readBuffer(64);
    return new gn.default(t, "le");
  }
  readBuffer(t) {
    if (this.offset + t > this.buf.length)
      throw new Be(`Expected buffer length ${t} isn't within bounds`);
    const n = this.buf.slice(this.offset, this.offset + t);
    return this.offset += t, n;
  }
  readString() {
    const t = this.readU32(), n = this.readBuffer(t);
    try {
      return Rp.decode(n);
    } catch (r) {
      throw new Be(`Error decoding UTF-8 string: ${r}`);
    }
  }
  readFixedArray(t) {
    return new Uint8Array(this.readBuffer(t));
  }
  readArray(t) {
    const n = this.readU32(), r = Array();
    for (let i = 0; i < n; ++i)
      r.push(t());
    return r;
  }
}
We([
  $e
], ke.prototype, "readU8", null);
We([
  $e
], ke.prototype, "readU16", null);
We([
  $e
], ke.prototype, "readU32", null);
We([
  $e
], ke.prototype, "readU64", null);
We([
  $e
], ke.prototype, "readU128", null);
We([
  $e
], ke.prototype, "readU256", null);
We([
  $e
], ke.prototype, "readU512", null);
We([
  $e
], ke.prototype, "readString", null);
We([
  $e
], ke.prototype, "readFixedArray", null);
We([
  $e
], ke.prototype, "readArray", null);
we.BinaryReader = ke;
function vc(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
function Tn(e, t, n, r, i) {
  try {
    if (typeof r == "string")
      i[`write${vc(r)}`](n);
    else if (r instanceof Array)
      if (typeof r[0] == "number") {
        if (n.length !== r[0])
          throw new Be(`Expecting byte array of length ${r[0]}, but got ${n.length} bytes`);
        i.writeFixedArray(n);
      } else if (r.length === 2 && typeof r[1] == "number") {
        if (n.length !== r[1])
          throw new Be(`Expecting byte array of length ${r[1]}, but got ${n.length} bytes`);
        for (let s = 0; s < r[1]; s++)
          Tn(e, null, n[s], r[0], i);
      } else
        i.writeArray(n, (s) => {
          Tn(e, t, s, r[0], i);
        });
    else if (r.kind !== void 0)
      switch (r.kind) {
        case "option": {
          n == null ? i.writeU8(0) : (i.writeU8(1), Tn(e, t, n, r.type, i));
          break;
        }
        case "map": {
          i.writeU32(n.size), n.forEach((s, o) => {
            Tn(e, t, o, r.key, i), Tn(e, t, s, r.value, i);
          });
          break;
        }
        default:
          throw new Be(`FieldType ${r} unrecognized`);
      }
    else
      Bc(e, n, i);
  } catch (s) {
    throw s instanceof Be && s.addToFieldPath(t), s;
  }
}
function Bc(e, t, n) {
  if (typeof t.borshSerialize == "function") {
    t.borshSerialize(n);
    return;
  }
  const r = e.get(t.constructor);
  if (!r)
    throw new Be(`Class ${t.constructor.name} is missing in schema`);
  if (r.kind === "struct")
    r.fields.map(([i, s]) => {
      Tn(e, i, t[i], s, n);
    });
  else if (r.kind === "enum") {
    const i = t[r.field];
    for (let s = 0; s < r.values.length; ++s) {
      const [o, u] = r.values[s];
      if (o === i) {
        n.writeU8(s), Tn(e, o, t[o], u, n);
        break;
      }
    }
  } else
    throw new Be(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`);
}
function Op(e, t, n = Ec) {
  const r = new n();
  return Bc(e, t, r), r.toArray();
}
var Ic = we.serialize = Op;
function Cn(e, t, n, r) {
  try {
    if (typeof n == "string")
      return r[`read${vc(n)}`]();
    if (n instanceof Array) {
      if (typeof n[0] == "number")
        return r.readFixedArray(n[0]);
      if (typeof n[1] == "number") {
        const i = [];
        for (let s = 0; s < n[1]; s++)
          i.push(Cn(e, null, n[0], r));
        return i;
      } else
        return r.readArray(() => Cn(e, t, n[0], r));
    }
    if (n.kind === "option")
      return r.readU8() ? Cn(e, t, n.type, r) : void 0;
    if (n.kind === "map") {
      let i = /* @__PURE__ */ new Map();
      const s = r.readU32();
      for (let o = 0; o < s; o++) {
        const u = Cn(e, t, n.key, r), d = Cn(e, t, n.value, r);
        i.set(u, d);
      }
      return i;
    }
    return Uo(e, n, r);
  } catch (i) {
    throw i instanceof Be && i.addToFieldPath(t), i;
  }
}
function Uo(e, t, n) {
  if (typeof t.borshDeserialize == "function")
    return t.borshDeserialize(n);
  const r = e.get(t);
  if (!r)
    throw new Be(`Class ${t.name} is missing in schema`);
  if (r.kind === "struct") {
    const i = {};
    for (const [s, o] of e.get(t).fields)
      i[s] = Cn(e, s, o, n);
    return new t(i);
  }
  if (r.kind === "enum") {
    const i = n.readU8();
    if (i >= r.values.length)
      throw new Be(`Enum index: ${i} is out of range`);
    const [s, o] = r.values[i], u = Cn(e, s, o, n);
    return new t({ [s]: u });
  }
  throw new Be(`Unexpected schema kind: ${r.kind} for ${t.constructor.name}`);
}
function Lp(e, t, n, r = ke) {
  const i = new r(n), s = Uo(e, t, i);
  if (i.offset < n.length)
    throw new Be(`Unexpected ${n.length - i.offset} bytes after deserialized data`);
  return s;
}
var Mc = we.deserialize = Lp;
function _p(e, t, n, r = ke) {
  const i = new r(n);
  return Uo(e, t, i);
}
Ac = we.deserializeUnchecked = _p;
var P = {};
Object.defineProperty(P, "__esModule", { value: !0 });
P.s16 = P.s8 = P.nu64be = P.u48be = P.u40be = P.u32be = P.u24be = P.u16be = me = P.nu64 = P.u48 = P.u40 = tt = P.u32 = P.u24 = Pe = P.u16 = ce = P.u8 = Nn = P.offset = P.greedy = P.Constant = P.UTF8 = P.CString = P.Blob = P.Boolean = P.BitField = P.BitStructure = P.VariantLayout = P.Union = P.UnionLayoutDiscriminator = P.UnionDiscriminator = P.Structure = P.Sequence = P.DoubleBE = P.Double = P.FloatBE = P.Float = P.NearInt64BE = P.NearInt64 = P.NearUInt64BE = P.NearUInt64 = P.IntBE = P.Int = P.UIntBE = P.UInt = P.OffsetLayout = P.GreedyCount = P.ExternalLayout = P.bindConstructorLayout = P.nameWithProperty = P.Layout = P.uint8ArrayToBuffer = P.checkUint8Array = void 0;
P.constant = P.utf8 = P.cstr = lr = P.blob = P.unionLayoutDiscriminator = P.union = Fn = P.seq = P.bits = et = P.struct = P.f64be = P.f64 = P.f32be = P.f32 = P.ns64be = P.s48be = P.s40be = P.s32be = P.s24be = P.s16be = Fe = P.ns64 = P.s48 = P.s40 = P.s32 = P.s24 = void 0;
const Fo = Ot;
function gr(e) {
  if (!(e instanceof Uint8Array))
    throw new TypeError("b must be a Uint8Array");
}
P.checkUint8Array = gr;
function xt(e) {
  return gr(e), Fo.Buffer.from(e.buffer, e.byteOffset, e.length);
}
P.uint8ArrayToBuffer = xt;
class Bt {
  constructor(t, n) {
    if (!Number.isInteger(t))
      throw new TypeError("span must be an integer");
    this.span = t, this.property = n;
  }
  /** Function to create an Object into which decoded properties will
   * be written.
   *
   * Used only for layouts that {@link Layout#decode|decode} to Object
   * instances, which means:
   * * {@link Structure}
   * * {@link Union}
   * * {@link VariantLayout}
   * * {@link BitStructure}
   *
   * If left undefined the JavaScript representation of these layouts
   * will be Object instances.
   *
   * See {@link bindConstructorLayout}.
   */
  makeDestinationObject() {
    return {};
  }
  /**
   * Calculate the span of a specific instance of a layout.
   *
   * @param {Uint8Array} b - the buffer that contains an encoded instance.
   *
   * @param {Number} [offset] - the offset at which the encoded instance
   * starts.  If absent a zero offset is inferred.
   *
   * @return {Number} - the number of bytes covered by the layout
   * instance.  If this method is not overridden in a subclass the
   * definition-time constant {@link Layout#span|span} will be
   * returned.
   *
   * @throws {RangeError} - if the length of the value cannot be
   * determined.
   */
  getSpan(t, n) {
    if (0 > this.span)
      throw new RangeError("indeterminate span");
    return this.span;
  }
  /**
   * Replicate the layout using a new property.
   *
   * This function must be used to get a structurally-equivalent layout
   * with a different name since all {@link Layout} instances are
   * immutable.
   *
   * **NOTE** This is a shallow copy.  All fields except {@link
   * Layout#property|property} are strictly equal to the origin layout.
   *
   * @param {String} property - the value for {@link
   * Layout#property|property} in the replica.
   *
   * @returns {Layout} - the copy with {@link Layout#property|property}
   * set to `property`.
   */
  replicate(t) {
    const n = Object.create(this.constructor.prototype);
    return Object.assign(n, this), n.property = t, n;
  }
  /**
   * Create an object from layout properties and an array of values.
   *
   * **NOTE** This function returns `undefined` if invoked on a layout
   * that does not return its value as an Object.  Objects are
   * returned for things that are a {@link Structure}, which includes
   * {@link VariantLayout|variant layouts} if they are structures, and
   * excludes {@link Union}s.  If you want this feature for a union
   * you must use {@link Union.getVariant|getVariant} to select the
   * desired layout.
   *
   * @param {Array} values - an array of values that correspond to the
   * default order for properties.  As with {@link Layout#decode|decode}
   * layout elements that have no property name are skipped when
   * iterating over the array values.  Only the top-level properties are
   * assigned; arguments are not assigned to properties of contained
   * layouts.  Any unused values are ignored.
   *
   * @return {(Object|undefined)}
   */
  fromArray(t) {
  }
}
P.Layout = Bt;
function ko(e, t) {
  return t.property ? e + "[" + t.property + "]" : e;
}
P.nameWithProperty = ko;
function Gp(e, t) {
  if (typeof e != "function")
    throw new TypeError("Class must be constructor");
  if (Object.prototype.hasOwnProperty.call(e, "layout_"))
    throw new Error("Class is already bound to a layout");
  if (!(t && t instanceof Bt))
    throw new TypeError("layout must be a Layout");
  if (Object.prototype.hasOwnProperty.call(t, "boundConstructor_"))
    throw new Error("layout is already bound to a constructor");
  e.layout_ = t, t.boundConstructor_ = e, t.makeDestinationObject = () => new e(), Object.defineProperty(e.prototype, "encode", {
    value(n, r) {
      return t.encode(this, n, r);
    },
    writable: !0
  }), Object.defineProperty(e, "decode", {
    value(n, r) {
      return t.decode(n, r);
    },
    writable: !0
  });
}
P.bindConstructorLayout = Gp;
class Ce extends Bt {
  /**
   * Return `true` iff the external layout decodes to an unsigned
   * integer layout.
   *
   * In that case it can be used as the source of {@link
   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},
   * or as {@link UnionLayoutDiscriminator#layout|external union
   * discriminators}.
   *
   * @abstract
   */
  isCount() {
    throw new Error("ExternalLayout is abstract");
  }
}
P.ExternalLayout = Ce;
class Tc extends Ce {
  constructor(t = 1, n) {
    if (!Number.isInteger(t) || 0 >= t)
      throw new TypeError("elementSpan must be a (positive) integer");
    super(-1, n), this.elementSpan = t;
  }
  /** @override */
  isCount() {
    return !0;
  }
  /** @override */
  decode(t, n = 0) {
    gr(t);
    const r = t.length - n;
    return Math.floor(r / this.elementSpan);
  }
  /** @override */
  encode(t, n, r) {
    return 0;
  }
}
P.GreedyCount = Tc;
class No extends Ce {
  constructor(t, n = 0, r) {
    if (!(t instanceof Bt))
      throw new TypeError("layout must be a Layout");
    if (!Number.isInteger(n))
      throw new TypeError("offset must be integer or undefined");
    super(t.span, r || t.property), this.layout = t, this.offset = n;
  }
  /** @override */
  isCount() {
    return this.layout instanceof Le || this.layout instanceof Ve;
  }
  /** @override */
  decode(t, n = 0) {
    return this.layout.decode(t, n + this.offset);
  }
  /** @override */
  encode(t, n, r = 0) {
    return this.layout.encode(t, n, r + this.offset);
  }
}
P.OffsetLayout = No;
class Le extends Bt {
  constructor(t, n) {
    if (super(t, n), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(t, n = 0) {
    return xt(t).readUIntLE(n, this.span);
  }
  /** @override */
  encode(t, n, r = 0) {
    return xt(n).writeUIntLE(t, r, this.span), this.span;
  }
}
P.UInt = Le;
class Ve extends Bt {
  constructor(t, n) {
    if (super(t, n), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(t, n = 0) {
    return xt(t).readUIntBE(n, this.span);
  }
  /** @override */
  encode(t, n, r = 0) {
    return xt(n).writeUIntBE(t, r, this.span), this.span;
  }
}
P.UIntBE = Ve;
class Gn extends Bt {
  constructor(t, n) {
    if (super(t, n), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(t, n = 0) {
    return xt(t).readIntLE(n, this.span);
  }
  /** @override */
  encode(t, n, r = 0) {
    return xt(n).writeIntLE(t, r, this.span), this.span;
  }
}
P.Int = Gn;
class br extends Bt {
  constructor(t, n) {
    if (super(t, n), 6 < this.span)
      throw new RangeError("span must not exceed 6 bytes");
  }
  /** @override */
  decode(t, n = 0) {
    return xt(t).readIntBE(n, this.span);
  }
  /** @override */
  encode(t, n, r = 0) {
    return xt(n).writeIntBE(t, r, this.span), this.span;
  }
}
P.IntBE = br;
const Js = Math.pow(2, 32);
function ki(e) {
  const t = Math.floor(e / Js), n = e - t * Js;
  return { hi32: t, lo32: n };
}
function Ni(e, t) {
  return e * Js + t;
}
class Cc extends Bt {
  constructor(t) {
    super(8, t);
  }
  /** @override */
  decode(t, n = 0) {
    const r = xt(t), i = r.readUInt32LE(n), s = r.readUInt32LE(n + 4);
    return Ni(s, i);
  }
  /** @override */
  encode(t, n, r = 0) {
    const i = ki(t), s = xt(n);
    return s.writeUInt32LE(i.lo32, r), s.writeUInt32LE(i.hi32, r + 4), 8;
  }
}
P.NearUInt64 = Cc;
class Sc extends Bt {
  constructor(t) {
    super(8, t);
  }
  /** @override */
  decode(t, n = 0) {
    const r = xt(t), i = r.readUInt32BE(n), s = r.readUInt32BE(n + 4);
    return Ni(i, s);
  }
  /** @override */
  encode(t, n, r = 0) {
    const i = ki(t), s = xt(n);
    return s.writeUInt32BE(i.hi32, r), s.writeUInt32BE(i.lo32, r + 4), 8;
  }
}
P.NearUInt64BE = Sc;
class Uc extends Bt {
  constructor(t) {
    super(8, t);
  }
  /** @override */
  decode(t, n = 0) {
    const r = xt(t), i = r.readUInt32LE(n), s = r.readInt32LE(n + 4);
    return Ni(s, i);
  }
  /** @override */
  encode(t, n, r = 0) {
    const i = ki(t), s = xt(n);
    return s.writeUInt32LE(i.lo32, r), s.writeInt32LE(i.hi32, r + 4), 8;
  }
}
P.NearInt64 = Uc;
class Fc extends Bt {
  constructor(t) {
    super(8, t);
  }
  /** @override */
  decode(t, n = 0) {
    const r = xt(t), i = r.readInt32BE(n), s = r.readUInt32BE(n + 4);
    return Ni(i, s);
  }
  /** @override */
  encode(t, n, r = 0) {
    const i = ki(t), s = xt(n);
    return s.writeInt32BE(i.hi32, r), s.writeUInt32BE(i.lo32, r + 4), 8;
  }
}
P.NearInt64BE = Fc;
class kc extends Bt {
  constructor(t) {
    super(4, t);
  }
  /** @override */
  decode(t, n = 0) {
    return xt(t).readFloatLE(n);
  }
  /** @override */
  encode(t, n, r = 0) {
    return xt(n).writeFloatLE(t, r), 4;
  }
}
P.Float = kc;
class Nc extends Bt {
  constructor(t) {
    super(4, t);
  }
  /** @override */
  decode(t, n = 0) {
    return xt(t).readFloatBE(n);
  }
  /** @override */
  encode(t, n, r = 0) {
    return xt(n).writeFloatBE(t, r), 4;
  }
}
P.FloatBE = Nc;
class Rc extends Bt {
  constructor(t) {
    super(8, t);
  }
  /** @override */
  decode(t, n = 0) {
    return xt(t).readDoubleLE(n);
  }
  /** @override */
  encode(t, n, r = 0) {
    return xt(n).writeDoubleLE(t, r), 8;
  }
}
P.Double = Rc;
class Pc extends Bt {
  constructor(t) {
    super(8, t);
  }
  /** @override */
  decode(t, n = 0) {
    return xt(t).readDoubleBE(n);
  }
  /** @override */
  encode(t, n, r = 0) {
    return xt(n).writeDoubleBE(t, r), 8;
  }
}
P.DoubleBE = Pc;
class Dc extends Bt {
  constructor(t, n, r) {
    if (!(t instanceof Bt))
      throw new TypeError("elementLayout must be a Layout");
    if (!(n instanceof Ce && n.isCount() || Number.isInteger(n) && 0 <= n))
      throw new TypeError("count must be non-negative integer or an unsigned integer ExternalLayout");
    let i = -1;
    !(n instanceof Ce) && 0 < t.span && (i = n * t.span), super(i, r), this.elementLayout = t, this.count = n;
  }
  /** @override */
  getSpan(t, n = 0) {
    if (0 <= this.span)
      return this.span;
    let r = 0, i = this.count;
    if (i instanceof Ce && (i = i.decode(t, n)), 0 < this.elementLayout.span)
      r = i * this.elementLayout.span;
    else {
      let s = 0;
      for (; s < i; )
        r += this.elementLayout.getSpan(t, n + r), ++s;
    }
    return r;
  }
  /** @override */
  decode(t, n = 0) {
    const r = [];
    let i = 0, s = this.count;
    for (s instanceof Ce && (s = s.decode(t, n)); i < s; )
      r.push(this.elementLayout.decode(t, n)), n += this.elementLayout.getSpan(t, n), i += 1;
    return r;
  }
  /** Implement {@link Layout#encode|encode} for {@link Sequence}.
   *
   * **NOTE** If `src` is shorter than {@link Sequence#count|count} then
   * the unused space in the buffer is left unchanged.  If `src` is
   * longer than {@link Sequence#count|count} the unneeded elements are
   * ignored.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(t, n, r = 0) {
    const i = this.elementLayout, s = t.reduce((o, u) => o + i.encode(u, n, r + o), 0);
    return this.count instanceof Ce && this.count.encode(t.length, n, r), s;
  }
}
P.Sequence = Dc;
class Oc extends Bt {
  constructor(t, n, r) {
    if (!(Array.isArray(t) && t.reduce((s, o) => s && o instanceof Bt, !0)))
      throw new TypeError("fields must be array of Layout instances");
    typeof n == "boolean" && r === void 0 && (r = n, n = void 0);
    for (const s of t)
      if (0 > s.span && s.property === void 0)
        throw new Error("fields cannot contain unnamed variable-length layout");
    let i = -1;
    try {
      i = t.reduce((s, o) => s + o.getSpan(), 0);
    } catch {
    }
    super(i, n), this.fields = t, this.decodePrefixes = !!r;
  }
  /** @override */
  getSpan(t, n = 0) {
    if (0 <= this.span)
      return this.span;
    let r = 0;
    try {
      r = this.fields.reduce((i, s) => {
        const o = s.getSpan(t, n);
        return n += o, i + o;
      }, 0);
    } catch {
      throw new RangeError("indeterminate span");
    }
    return r;
  }
  /** @override */
  decode(t, n = 0) {
    gr(t);
    const r = this.makeDestinationObject();
    for (const i of this.fields)
      if (i.property !== void 0 && (r[i.property] = i.decode(t, n)), n += i.getSpan(t, n), this.decodePrefixes && t.length === n)
        break;
    return r;
  }
  /** Implement {@link Layout#encode|encode} for {@link Structure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the buffer is
   * left unmodified. */
  encode(t, n, r = 0) {
    const i = r;
    let s = 0, o = 0;
    for (const u of this.fields) {
      let d = u.span;
      if (o = 0 < d ? d : 0, u.property !== void 0) {
        const w = t[u.property];
        w !== void 0 && (o = u.encode(w, n, r), 0 > d && (d = u.getSpan(n, r)));
      }
      s = r, r += d;
    }
    return s + o - i;
  }
  /** @override */
  fromArray(t) {
    const n = this.makeDestinationObject();
    for (const r of this.fields)
      r.property !== void 0 && 0 < t.length && (n[r.property] = t.shift());
    return n;
  }
  /**
   * Get access to the layout of a given property.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Layout} - the layout associated with `property`, or
   * undefined if there is no such property.
   */
  layoutFor(t) {
    if (typeof t != "string")
      throw new TypeError("property must be string");
    for (const n of this.fields)
      if (n.property === t)
        return n;
  }
  /**
   * Get the offset of a structure member.
   *
   * @param {String} property - the structure member of interest.
   *
   * @return {Number} - the offset in bytes to the start of `property`
   * within the structure, or undefined if `property` is not a field
   * within the structure.  If the property is a member but follows a
   * variable-length structure member a negative number will be
   * returned.
   */
  offsetOf(t) {
    if (typeof t != "string")
      throw new TypeError("property must be string");
    let n = 0;
    for (const r of this.fields) {
      if (r.property === t)
        return n;
      0 > r.span ? n = -1 : 0 <= n && (n += r.span);
    }
  }
}
P.Structure = Oc;
class Ro {
  constructor(t) {
    this.property = t;
  }
  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.
   *
   * The implementation of this method need not reference the buffer if
   * variant information is available through other means. */
  decode(t, n) {
    throw new Error("UnionDiscriminator is abstract");
  }
  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.
   *
   * The implementation of this method need not store the value if
   * variant information is maintained through other means. */
  encode(t, n, r) {
    throw new Error("UnionDiscriminator is abstract");
  }
}
P.UnionDiscriminator = Ro;
class gi extends Ro {
  constructor(t, n) {
    if (!(t instanceof Ce && t.isCount()))
      throw new TypeError("layout must be an unsigned integer ExternalLayout");
    super(n || t.property || "variant"), this.layout = t;
  }
  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  decode(t, n) {
    return this.layout.decode(t, n);
  }
  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */
  encode(t, n, r) {
    return this.layout.encode(t, n, r);
  }
}
P.UnionLayoutDiscriminator = gi;
class Po extends Bt {
  constructor(t, n, r) {
    let i;
    if (t instanceof Le || t instanceof Ve)
      i = new gi(new No(t));
    else if (t instanceof Ce && t.isCount())
      i = new gi(t);
    else if (t instanceof Ro)
      i = t;
    else
      throw new TypeError("discr must be a UnionDiscriminator or an unsigned integer layout");
    if (n === void 0 && (n = null), !(n === null || n instanceof Bt))
      throw new TypeError("defaultLayout must be null or a Layout");
    if (n !== null) {
      if (0 > n.span)
        throw new Error("defaultLayout must have constant span");
      n.property === void 0 && (n = n.replicate("content"));
    }
    let s = -1;
    n && (s = n.span, 0 <= s && (t instanceof Le || t instanceof Ve) && (s += i.layout.span)), super(s, r), this.discriminator = i, this.usesPrefixDiscriminator = t instanceof Le || t instanceof Ve, this.defaultLayout = n, this.registry = {};
    let o = this.defaultGetSourceVariant.bind(this);
    this.getSourceVariant = function(u) {
      return o(u);
    }, this.configGetSourceVariant = function(u) {
      o = u.bind(this);
    };
  }
  /** @override */
  getSpan(t, n = 0) {
    if (0 <= this.span)
      return this.span;
    const r = this.getVariant(t, n);
    if (!r)
      throw new Error("unable to determine span for unrecognized variant");
    return r.getSpan(t, n);
  }
  /**
   * Method to infer a registered Union variant compatible with `src`.
   *
   * The first satisfied rule in the following sequence defines the
   * return value:
   * * If `src` has properties matching the Union discriminator and
   *   the default layout, `undefined` is returned regardless of the
   *   value of the discriminator property (this ensures the default
   *   layout will be used);
   * * If `src` has a property matching the Union discriminator, the
   *   value of the discriminator identifies a registered variant, and
   *   either (a) the variant has no layout, or (b) `src` has the
   *   variant's property, then the variant is returned (because the
   *   source satisfies the constraints of the variant it identifies);
   * * If `src` does not have a property matching the Union
   *   discriminator, but does have a property matching a registered
   *   variant, then the variant is returned (because the source
   *   matches a variant without an explicit conflict);
   * * An error is thrown (because we either can't identify a variant,
   *   or we were explicitly told the variant but can't satisfy it).
   *
   * @param {Object} src - an object presumed to be compatible with
   * the content of the Union.
   *
   * @return {(undefined|VariantLayout)} - as described above.
   *
   * @throws {Error} - if `src` cannot be associated with a default or
   * registered variant.
   */
  defaultGetSourceVariant(t) {
    if (Object.prototype.hasOwnProperty.call(t, this.discriminator.property)) {
      if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(t, this.defaultLayout.property))
        return;
      const n = this.registry[t[this.discriminator.property]];
      if (n && (!n.layout || n.property && Object.prototype.hasOwnProperty.call(t, n.property)))
        return n;
    } else
      for (const n in this.registry) {
        const r = this.registry[n];
        if (r.property && Object.prototype.hasOwnProperty.call(t, r.property))
          return r;
      }
    throw new Error("unable to infer src variant");
  }
  /** Implement {@link Layout#decode|decode} for {@link Union}.
   *
   * If the variant is {@link Union#addVariant|registered} the return
   * value is an instance of that variant, with no explicit
   * discriminator.  Otherwise the {@link Union#defaultLayout|default
   * layout} is used to decode the content. */
  decode(t, n = 0) {
    let r;
    const i = this.discriminator, s = i.decode(t, n), o = this.registry[s];
    if (o === void 0) {
      const u = this.defaultLayout;
      let d = 0;
      this.usesPrefixDiscriminator && (d = i.layout.span), r = this.makeDestinationObject(), r[i.property] = s, r[u.property] = u.decode(t, n + d);
    } else
      r = o.decode(t, n);
    return r;
  }
  /** Implement {@link Layout#encode|encode} for {@link Union}.
   *
   * This API assumes the `src` object is consistent with the union's
   * {@link Union#defaultLayout|default layout}.  To encode variants
   * use the appropriate variant-specific {@link VariantLayout#encode}
   * method. */
  encode(t, n, r = 0) {
    const i = this.getSourceVariant(t);
    if (i === void 0) {
      const s = this.discriminator, o = this.defaultLayout;
      let u = 0;
      return this.usesPrefixDiscriminator && (u = s.layout.span), s.encode(t[s.property], n, r), u + o.encode(t[o.property], n, r + u);
    }
    return i.encode(t, n, r);
  }
  /** Register a new variant structure within a union.  The newly
   * created variant is returned.
   *
   * @param {Number} variant - initializer for {@link
   * VariantLayout#variant|variant}.
   *
   * @param {Layout} layout - initializer for {@link
   * VariantLayout#layout|layout}.
   *
   * @param {String} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {VariantLayout} */
  addVariant(t, n, r) {
    const i = new Lc(this, t, n, r);
    return this.registry[t] = i, i;
  }
  /**
   * Get the layout associated with a registered variant.
   *
   * If `vb` does not produce a registered variant the function returns
   * `undefined`.
   *
   * @param {(Number|Uint8Array)} vb - either the variant number, or a
   * buffer from which the discriminator is to be read.
   *
   * @param {Number} offset - offset into `vb` for the start of the
   * union.  Used only when `vb` is an instance of {Uint8Array}.
   *
   * @return {({VariantLayout}|undefined)}
   */
  getVariant(t, n = 0) {
    let r;
    return t instanceof Uint8Array ? r = this.discriminator.decode(t, n) : r = t, this.registry[r];
  }
}
P.Union = Po;
class Lc extends Bt {
  constructor(t, n, r, i) {
    if (!(t instanceof Po))
      throw new TypeError("union must be a Union");
    if (!Number.isInteger(n) || 0 > n)
      throw new TypeError("variant must be a (non-negative) integer");
    if (typeof r == "string" && i === void 0 && (i = r, r = null), r) {
      if (!(r instanceof Bt))
        throw new TypeError("layout must be a Layout");
      if (t.defaultLayout !== null && 0 <= r.span && r.span > t.defaultLayout.span)
        throw new Error("variant span exceeds span of containing union");
      if (typeof i != "string")
        throw new TypeError("variant must have a String property");
    }
    let s = t.span;
    0 > t.span && (s = r ? r.span : 0, 0 <= s && t.usesPrefixDiscriminator && (s += t.discriminator.layout.span)), super(s, i), this.union = t, this.variant = n, this.layout = r || null;
  }
  /** @override */
  getSpan(t, n = 0) {
    if (0 <= this.span)
      return this.span;
    let r = 0;
    this.union.usesPrefixDiscriminator && (r = this.union.discriminator.layout.span);
    let i = 0;
    return this.layout && (i = this.layout.getSpan(t, n + r)), r + i;
  }
  /** @override */
  decode(t, n = 0) {
    const r = this.makeDestinationObject();
    if (this !== this.union.getVariant(t, n))
      throw new Error("variant mismatch");
    let i = 0;
    return this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout ? r[this.property] = this.layout.decode(t, n + i) : this.property ? r[this.property] = !0 : this.union.usesPrefixDiscriminator && (r[this.union.discriminator.property] = this.variant), r;
  }
  /** @override */
  encode(t, n, r = 0) {
    let i = 0;
    if (this.union.usesPrefixDiscriminator && (i = this.union.discriminator.layout.span), this.layout && !Object.prototype.hasOwnProperty.call(t, this.property))
      throw new TypeError("variant lacks property " + this.property);
    this.union.discriminator.encode(this.variant, n, r);
    let s = i;
    if (this.layout && (this.layout.encode(t[this.property], n, r + i), s += this.layout.getSpan(n, r + i), 0 <= this.union.span && s > this.union.span))
      throw new Error("encoded variant overruns containing union");
    return s;
  }
  /** Delegate {@link Layout#fromArray|fromArray} to {@link
   * VariantLayout#layout|layout}. */
  fromArray(t) {
    if (this.layout)
      return this.layout.fromArray(t);
  }
}
P.VariantLayout = Lc;
function Xn(e) {
  return 0 > e && (e += 4294967296), e;
}
class Do extends Bt {
  constructor(t, n, r) {
    if (!(t instanceof Le || t instanceof Ve))
      throw new TypeError("word must be a UInt or UIntBE layout");
    if (typeof n == "string" && r === void 0 && (r = n, n = !1), 4 < t.span)
      throw new RangeError("word cannot exceed 32 bits");
    super(t.span, r), this.word = t, this.msb = !!n, this.fields = [];
    let i = 0;
    this._packedSetValue = function(s) {
      return i = Xn(s), this;
    }, this._packedGetValue = function() {
      return i;
    };
  }
  /** @override */
  decode(t, n = 0) {
    const r = this.makeDestinationObject(), i = this.word.decode(t, n);
    this._packedSetValue(i);
    for (const s of this.fields)
      s.property !== void 0 && (r[s.property] = s.decode(t));
    return r;
  }
  /** Implement {@link Layout#encode|encode} for {@link BitStructure}.
   *
   * If `src` is missing a property for a member with a defined {@link
   * Layout#property|property} the corresponding region of the packed
   * value is left unmodified.  Unused bits are also left unmodified. */
  encode(t, n, r = 0) {
    const i = this.word.decode(n, r);
    this._packedSetValue(i);
    for (const s of this.fields)
      if (s.property !== void 0) {
        const o = t[s.property];
        o !== void 0 && s.encode(o);
      }
    return this.word.encode(this._packedGetValue(), n, r);
  }
  /** Register a new bitfield with a containing bit structure.  The
   * resulting bitfield is returned.
   *
   * @param {Number} bits - initializer for {@link BitField#bits|bits}.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {BitField} */
  addField(t, n) {
    const r = new Oo(this, t, n);
    return this.fields.push(r), r;
  }
  /** As with {@link BitStructure#addField|addField} for single-bit
   * fields with `boolean` value representation.
   *
   * @param {string} property - initializer for {@link
   * Layout#property|property}.
   *
   * @return {Boolean} */
  // `Boolean` conflicts with the native primitive type
  // eslint-disable-next-line @typescript-eslint/ban-types
  addBoolean(t) {
    const n = new _c(this, t);
    return this.fields.push(n), n;
  }
  /**
   * Get access to the bit field for a given property.
   *
   * @param {String} property - the bit field of interest.
   *
   * @return {BitField} - the field associated with `property`, or
   * undefined if there is no such property.
   */
  fieldFor(t) {
    if (typeof t != "string")
      throw new TypeError("property must be string");
    for (const n of this.fields)
      if (n.property === t)
        return n;
  }
}
P.BitStructure = Do;
class Oo {
  constructor(t, n, r) {
    if (!(t instanceof Do))
      throw new TypeError("container must be a BitStructure");
    if (!Number.isInteger(n) || 0 >= n)
      throw new TypeError("bits must be positive integer");
    const i = 8 * t.span, s = t.fields.reduce((o, u) => o + u.bits, 0);
    if (n + s > i)
      throw new Error("bits too long for span remainder (" + (i - s) + " of " + i + " remain)");
    this.container = t, this.bits = n, this.valueMask = (1 << n) - 1, n === 32 && (this.valueMask = 4294967295), this.start = s, this.container.msb && (this.start = i - s - n), this.wordMask = Xn(this.valueMask << this.start), this.property = r;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field. */
  decode(t, n) {
    const r = this.container._packedGetValue();
    return Xn(r & this.wordMask) >>> this.start;
  }
  /** Store a value into the corresponding subsequence of the containing
   * bit field.
   *
   * **NOTE** This is not a specialization of {@link
   * Layout#encode|Layout.encode} and there is no return value. */
  encode(t) {
    if (typeof t != "number" || !Number.isInteger(t) || t !== Xn(t & this.valueMask))
      throw new TypeError(ko("BitField.encode", this) + " value must be integer not exceeding " + this.valueMask);
    const n = this.container._packedGetValue(), r = Xn(t << this.start);
    this.container._packedSetValue(Xn(n & ~this.wordMask) | r);
  }
}
P.BitField = Oo;
let _c = class extends Oo {
  constructor(t, n) {
    super(t, 1, n);
  }
  /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.
   *
   * @returns {boolean} */
  decode(t, n) {
    return !!super.decode(t, n);
  }
  /** @override */
  encode(t) {
    typeof t == "boolean" && (t = +t), super.encode(t);
  }
};
P.Boolean = _c;
class Gc extends Bt {
  constructor(t, n) {
    if (!(t instanceof Ce && t.isCount() || Number.isInteger(t) && 0 <= t))
      throw new TypeError("length must be positive integer or an unsigned integer ExternalLayout");
    let r = -1;
    t instanceof Ce || (r = t), super(r, n), this.length = t;
  }
  /** @override */
  getSpan(t, n) {
    let r = this.span;
    return 0 > r && (r = this.length.decode(t, n)), r;
  }
  /** @override */
  decode(t, n = 0) {
    let r = this.span;
    return 0 > r && (r = this.length.decode(t, n)), xt(t).slice(n, n + r);
  }
  /** Implement {@link Layout#encode|encode} for {@link Blob}.
   *
   * **NOTE** If {@link Layout#count|count} is an instance of {@link
   * ExternalLayout} then the length of `src` will be encoded as the
   * count after `src` is encoded. */
  encode(t, n, r) {
    let i = this.length;
    if (this.length instanceof Ce && (i = t.length), !(t instanceof Uint8Array && i === t.length))
      throw new TypeError(ko("Blob.encode", this) + " requires (length " + i + ") Uint8Array as src");
    if (r + i > n.length)
      throw new RangeError("encoding overruns Uint8Array");
    const s = xt(t);
    return xt(n).write(s.toString("hex"), r, i, "hex"), this.length instanceof Ce && this.length.encode(i, n, r), i;
  }
}
P.Blob = Gc;
class zc extends Bt {
  constructor(t) {
    super(-1, t);
  }
  /** @override */
  getSpan(t, n = 0) {
    gr(t);
    let r = n;
    for (; r < t.length && t[r] !== 0; )
      r += 1;
    return 1 + r - n;
  }
  /** @override */
  decode(t, n = 0) {
    const r = this.getSpan(t, n);
    return xt(t).slice(n, n + r - 1).toString("utf-8");
  }
  /** @override */
  encode(t, n, r = 0) {
    typeof t != "string" && (t = String(t));
    const i = Fo.Buffer.from(t, "utf8"), s = i.length;
    if (r + s > n.length)
      throw new RangeError("encoding overruns Buffer");
    const o = xt(n);
    return i.copy(o, r), o[r + s] = 0, s + 1;
  }
}
P.CString = zc;
class Hc extends Bt {
  constructor(t, n) {
    if (typeof t == "string" && n === void 0 && (n = t, t = void 0), t === void 0)
      t = -1;
    else if (!Number.isInteger(t))
      throw new TypeError("maxSpan must be an integer");
    super(-1, n), this.maxSpan = t;
  }
  /** @override */
  getSpan(t, n = 0) {
    return gr(t), t.length - n;
  }
  /** @override */
  decode(t, n = 0) {
    const r = this.getSpan(t, n);
    if (0 <= this.maxSpan && this.maxSpan < r)
      throw new RangeError("text length exceeds maxSpan");
    return xt(t).slice(n, n + r).toString("utf-8");
  }
  /** @override */
  encode(t, n, r = 0) {
    typeof t != "string" && (t = String(t));
    const i = Fo.Buffer.from(t, "utf8"), s = i.length;
    if (0 <= this.maxSpan && this.maxSpan < s)
      throw new RangeError("text length exceeds maxSpan");
    if (r + s > n.length)
      throw new RangeError("encoding overruns Buffer");
    return i.copy(xt(n), r), s;
  }
}
P.UTF8 = Hc;
class Vc extends Bt {
  constructor(t, n) {
    super(0, n), this.value = t;
  }
  /** @override */
  decode(t, n) {
    return this.value;
  }
  /** @override */
  encode(t, n, r) {
    return 0;
  }
}
P.Constant = Vc;
P.greedy = (e, t) => new Tc(e, t);
var Nn = P.offset = (e, t, n) => new No(e, t, n), ce = P.u8 = (e) => new Le(1, e), Pe = P.u16 = (e) => new Le(2, e);
P.u24 = (e) => new Le(3, e);
var tt = P.u32 = (e) => new Le(4, e);
P.u40 = (e) => new Le(5, e);
P.u48 = (e) => new Le(6, e);
var me = P.nu64 = (e) => new Cc(e);
P.u16be = (e) => new Ve(2, e);
P.u24be = (e) => new Ve(3, e);
P.u32be = (e) => new Ve(4, e);
P.u40be = (e) => new Ve(5, e);
P.u48be = (e) => new Ve(6, e);
P.nu64be = (e) => new Sc(e);
P.s8 = (e) => new Gn(1, e);
P.s16 = (e) => new Gn(2, e);
P.s24 = (e) => new Gn(3, e);
P.s32 = (e) => new Gn(4, e);
P.s40 = (e) => new Gn(5, e);
P.s48 = (e) => new Gn(6, e);
var Fe = P.ns64 = (e) => new Uc(e);
P.s16be = (e) => new br(2, e);
P.s24be = (e) => new br(3, e);
P.s32be = (e) => new br(4, e);
P.s40be = (e) => new br(5, e);
P.s48be = (e) => new br(6, e);
P.ns64be = (e) => new Fc(e);
P.f32 = (e) => new kc(e);
P.f32be = (e) => new Nc(e);
P.f64 = (e) => new Rc(e);
P.f64be = (e) => new Pc(e);
var et = P.struct = (e, t, n) => new Oc(e, t, n);
P.bits = (e, t, n) => new Do(e, t, n);
var Fn = P.seq = (e, t, n) => new Dc(e, t, n);
P.union = (e, t, n) => new Po(e, t, n);
P.unionLayoutDiscriminator = (e, t) => new gi(e, t);
var lr = P.blob = (e, t) => new Gc(e, t);
P.cstr = (e) => new zc(e);
P.utf8 = (e, t) => new Hc(e, t);
P.constant = (e, t) => new Vc(e, t);
var Vr = {};
Object.defineProperty(Vr, "__esModule", { value: !0 });
function zp(e) {
  {
    const t = Buffer.from(e);
    t.reverse();
    const n = t.toString("hex");
    return n.length === 0 ? BigInt(0) : BigInt(`0x${n}`);
  }
}
var Hp = Vr.toBigIntLE = zp;
function Vp(e) {
  {
    const t = e.toString("hex");
    return t.length === 0 ? BigInt(0) : BigInt(`0x${t}`);
  }
}
Vr.toBigIntBE = Vp;
function Qp(e, t) {
  {
    const n = e.toString(16), r = Buffer.from(n.padStart(t * 2, "0").slice(0, t * 2), "hex");
    return r.reverse(), r;
  }
}
var Kp = Vr.toBufferLE = Qp;
function qp(e, t) {
  {
    const n = e.toString(16);
    return Buffer.from(n.padStart(t * 2, "0").slice(0, t * 2), "hex");
  }
}
Vr.toBufferBE = qp;
class jp extends TypeError {
  constructor(t, n) {
    let r;
    const {
      message: i,
      ...s
    } = t, {
      path: o
    } = t, u = o.length === 0 ? i : "At path: " + o.join(".") + " -- " + i;
    super(u), Object.assign(this, s), this.name = this.constructor.name, this.failures = () => {
      var d;
      return (d = r) != null ? d : r = [t, ...n()];
    };
  }
}
function Yp(e) {
  return An(e) && typeof e[Symbol.iterator] == "function";
}
function An(e) {
  return typeof e == "object" && e != null;
}
function Ke(e) {
  return typeof e == "string" ? JSON.stringify(e) : "" + e;
}
function Zp(e) {
  const {
    done: t,
    value: n
  } = e.next();
  return t ? void 0 : n;
}
function Jp(e, t, n, r) {
  if (e === !0)
    return;
  e === !1 ? e = {} : typeof e == "string" && (e = {
    message: e
  });
  const {
    path: i,
    branch: s
  } = t, {
    type: o
  } = n, {
    refinement: u,
    message: d = "Expected a value of type `" + o + "`" + (u ? " with refinement `" + u + "`" : "") + ", but received: `" + Ke(r) + "`"
  } = e;
  return {
    value: r,
    type: o,
    refinement: u,
    key: i[i.length - 1],
    path: i,
    branch: s,
    ...e,
    message: d
  };
}
function* Da(e, t, n, r) {
  Yp(e) || (e = [e]);
  for (const i of e) {
    const s = Jp(i, t, n, r);
    s && (yield s);
  }
}
function* Lo(e, t, n = {}) {
  const {
    path: r = [],
    branch: i = [e],
    coerce: s = !1,
    mask: o = !1
  } = n, u = {
    path: r,
    branch: i
  };
  if (s && (e = t.coercer(e, u), o && t.type !== "type" && An(t.schema) && An(e) && !Array.isArray(e)))
    for (const w in e)
      t.schema[w] === void 0 && delete e[w];
  let d = !0;
  for (const w of t.validator(e, u))
    d = !1, yield [w, void 0];
  for (let [w, g, v] of t.entries(e, u)) {
    const I = Lo(g, v, {
      path: w === void 0 ? r : [...r, w],
      branch: w === void 0 ? i : [...i, g],
      coerce: s,
      mask: o
    });
    for (const S of I)
      S[0] ? (d = !1, yield [S[0], void 0]) : s && (g = S[1], w === void 0 ? e = g : e instanceof Map ? e.set(w, g) : e instanceof Set ? e.add(g) : An(e) && (e[w] = g));
  }
  if (d)
    for (const w of t.refiner(e, u))
      d = !1, yield [w, void 0];
  d && (yield [void 0, e]);
}
let tn = class {
  constructor(t) {
    const {
      type: n,
      schema: r,
      validator: i,
      refiner: s,
      coercer: o = (d) => d,
      entries: u = function* () {
      }
    } = t;
    this.type = n, this.schema = r, this.entries = u, this.coercer = o, i ? this.validator = (d, w) => {
      const g = i(d, w);
      return Da(g, w, this, d);
    } : this.validator = () => [], s ? this.refiner = (d, w) => {
      const g = s(d, w);
      return Da(g, w, this, d);
    } : this.refiner = () => [];
  }
  /**
   * Assert that a value passes the struct's validation, throwing if it doesn't.
   */
  assert(t) {
    return Xp(t, this);
  }
  /**
   * Create a value with the struct's coercion logic, then validate it.
   */
  create(t) {
    return Lr(t, this);
  }
  /**
   * Check if a value passes the struct's validation.
   */
  is(t) {
    return Qc(t, this);
  }
  /**
   * Mask a value, coercing and validating it, but returning only the subset of
   * properties defined by the struct's schema.
   */
  mask(t) {
    return Wp(t, this);
  }
  /**
   * Validate a value with the struct's validation logic, returning a tuple
   * representing the result.
   *
   * You may optionally pass `true` for the `withCoercion` argument to coerce
   * the value before attempting to validate it. If you do, the result will
   * contain the coerced result when successful.
   */
  validate(t, n = {}) {
    return Qr(t, this, n);
  }
};
function Xp(e, t) {
  const n = Qr(e, t);
  if (n[0])
    throw n[0];
}
function Lr(e, t) {
  const n = Qr(e, t, {
    coerce: !0
  });
  if (n[0])
    throw n[0];
  return n[1];
}
function Wp(e, t) {
  const n = Qr(e, t, {
    coerce: !0,
    mask: !0
  });
  if (n[0])
    throw n[0];
  return n[1];
}
function Qc(e, t) {
  return !Qr(e, t)[0];
}
function Qr(e, t, n = {}) {
  const r = Lo(e, t, n), i = Zp(r);
  return i[0] ? [new jp(i[0], function* () {
    for (const o of r)
      o[0] && (yield o[0]);
  }), void 0] : [void 0, i[1]];
}
function zn(e, t) {
  return new tn({
    type: e,
    schema: null,
    validator: t
  });
}
function $p() {
  return zn("any", () => !0);
}
function W(e) {
  return new tn({
    type: "array",
    schema: e,
    *entries(t) {
      if (e && Array.isArray(t))
        for (const [n, r] of t.entries())
          yield [n, r, e];
    },
    coercer(t) {
      return Array.isArray(t) ? t.slice() : t;
    },
    validator(t) {
      return Array.isArray(t) || "Expected an array value, but received: " + Ke(t);
    }
  });
}
function Xe() {
  return zn("boolean", (e) => typeof e == "boolean");
}
function _o(e) {
  return zn("instance", (t) => t instanceof e || "Expected a `" + e.name + "` instance, but received: " + Ke(t));
}
function _t(e) {
  const t = Ke(e), n = typeof e;
  return new tn({
    type: "literal",
    schema: n === "string" || n === "number" || n === "boolean" ? e : null,
    validator(r) {
      return r === e || "Expected the literal `" + t + "`, but received: " + Ke(r);
    }
  });
}
function ty() {
  return zn("never", () => !1);
}
function X(e) {
  return new tn({
    ...e,
    validator: (t, n) => t === null || e.validator(t, n),
    refiner: (t, n) => t === null || e.refiner(t, n)
  });
}
function R() {
  return zn("number", (e) => typeof e == "number" && !isNaN(e) || "Expected a number, but received: " + Ke(e));
}
function rt(e) {
  return new tn({
    ...e,
    validator: (t, n) => t === void 0 || e.validator(t, n),
    refiner: (t, n) => t === void 0 || e.refiner(t, n)
  });
}
function Kc(e, t) {
  return new tn({
    type: "record",
    schema: null,
    *entries(n) {
      if (An(n))
        for (const r in n) {
          const i = n[r];
          yield [r, r, e], yield [r, i, t];
        }
    },
    validator(n) {
      return An(n) || "Expected an object, but received: " + Ke(n);
    }
  });
}
function K() {
  return zn("string", (e) => typeof e == "string" || "Expected a string, but received: " + Ke(e));
}
function Go(e) {
  const t = ty();
  return new tn({
    type: "tuple",
    schema: null,
    *entries(n) {
      if (Array.isArray(n)) {
        const r = Math.max(e.length, n.length);
        for (let i = 0; i < r; i++)
          yield [i, n[i], e[i] || t];
      }
    },
    validator(n) {
      return Array.isArray(n) || "Expected an array, but received: " + Ke(n);
    }
  });
}
function G(e) {
  const t = Object.keys(e);
  return new tn({
    type: "type",
    schema: e,
    *entries(n) {
      if (An(n))
        for (const r of t)
          yield [r, n[r], e[r]];
    },
    validator(n) {
      return An(n) || "Expected an object, but received: " + Ke(n);
    }
  });
}
function Ue(e) {
  const t = e.map((n) => n.type).join(" | ");
  return new tn({
    type: "union",
    schema: null,
    validator(n, r) {
      const i = [];
      for (const s of e) {
        const [...o] = Lo(n, s, r), [u] = o;
        if (u[0])
          for (const [d] of o)
            d && i.push(d);
        else
          return [];
      }
      return ["Expected the value to satisfy a union of `" + t + "`, but received: " + Ke(n), ...i];
    }
  });
}
function Kr() {
  return zn("unknown", () => !0);
}
function qr(e, t, n) {
  return new tn({
    ...e,
    coercer: (r, i) => Qc(r, t) ? e.coercer(n(r, i), i) : e.coercer(r, i)
  });
}
var ti, ey = new Uint8Array(16);
function qc() {
  if (!ti && (ti = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto < "u" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto), !ti))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return ti(ey);
}
const ny = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
function Ri(e) {
  return typeof e == "string" && ny.test(e);
}
var ye = [];
for (var Bs = 0; Bs < 256; ++Bs)
  ye.push((Bs + 256).toString(16).substr(1));
function Pi(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, n = (ye[e[t + 0]] + ye[e[t + 1]] + ye[e[t + 2]] + ye[e[t + 3]] + "-" + ye[e[t + 4]] + ye[e[t + 5]] + "-" + ye[e[t + 6]] + ye[e[t + 7]] + "-" + ye[e[t + 8]] + ye[e[t + 9]] + "-" + ye[e[t + 10]] + ye[e[t + 11]] + ye[e[t + 12]] + ye[e[t + 13]] + ye[e[t + 14]] + ye[e[t + 15]]).toLowerCase();
  if (!Ri(n))
    throw TypeError("Stringified UUID is invalid");
  return n;
}
var Oa, Is, Ms = 0, Ts = 0;
function ry(e, t, n) {
  var r = t && n || 0, i = t || new Array(16);
  e = e || {};
  var s = e.node || Oa, o = e.clockseq !== void 0 ? e.clockseq : Is;
  if (s == null || o == null) {
    var u = e.random || (e.rng || qc)();
    s == null && (s = Oa = [u[0] | 1, u[1], u[2], u[3], u[4], u[5]]), o == null && (o = Is = (u[6] << 8 | u[7]) & 16383);
  }
  var d = e.msecs !== void 0 ? e.msecs : Date.now(), w = e.nsecs !== void 0 ? e.nsecs : Ts + 1, g = d - Ms + (w - Ts) / 1e4;
  if (g < 0 && e.clockseq === void 0 && (o = o + 1 & 16383), (g < 0 || d > Ms) && e.nsecs === void 0 && (w = 0), w >= 1e4)
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  Ms = d, Ts = w, Is = o, d += 122192928e5;
  var v = ((d & 268435455) * 1e4 + w) % 4294967296;
  i[r++] = v >>> 24 & 255, i[r++] = v >>> 16 & 255, i[r++] = v >>> 8 & 255, i[r++] = v & 255;
  var I = d / 4294967296 * 1e4 & 268435455;
  i[r++] = I >>> 8 & 255, i[r++] = I & 255, i[r++] = I >>> 24 & 15 | 16, i[r++] = I >>> 16 & 255, i[r++] = o >>> 8 | 128, i[r++] = o & 255;
  for (var S = 0; S < 6; ++S)
    i[r + S] = s[S];
  return t || Pi(i);
}
function jc(e) {
  if (!Ri(e))
    throw TypeError("Invalid UUID");
  var t, n = new Uint8Array(16);
  return n[0] = (t = parseInt(e.slice(0, 8), 16)) >>> 24, n[1] = t >>> 16 & 255, n[2] = t >>> 8 & 255, n[3] = t & 255, n[4] = (t = parseInt(e.slice(9, 13), 16)) >>> 8, n[5] = t & 255, n[6] = (t = parseInt(e.slice(14, 18), 16)) >>> 8, n[7] = t & 255, n[8] = (t = parseInt(e.slice(19, 23), 16)) >>> 8, n[9] = t & 255, n[10] = (t = parseInt(e.slice(24, 36), 16)) / 1099511627776 & 255, n[11] = t / 4294967296 & 255, n[12] = t >>> 24 & 255, n[13] = t >>> 16 & 255, n[14] = t >>> 8 & 255, n[15] = t & 255, n;
}
function iy(e) {
  e = unescape(encodeURIComponent(e));
  for (var t = [], n = 0; n < e.length; ++n)
    t.push(e.charCodeAt(n));
  return t;
}
var sy = "6ba7b810-9dad-11d1-80b4-00c04fd430c8", oy = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
function Yc(e, t, n) {
  function r(i, s, o, u) {
    if (typeof i == "string" && (i = iy(i)), typeof s == "string" && (s = jc(s)), s.length !== 16)
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    var d = new Uint8Array(16 + i.length);
    if (d.set(s), d.set(i, s.length), d = n(d), d[6] = d[6] & 15 | t, d[8] = d[8] & 63 | 128, o) {
      u = u || 0;
      for (var w = 0; w < 16; ++w)
        o[u + w] = d[w];
      return o;
    }
    return Pi(d);
  }
  try {
    r.name = e;
  } catch {
  }
  return r.DNS = sy, r.URL = oy, r;
}
function ay(e) {
  if (typeof e == "string") {
    var t = unescape(encodeURIComponent(e));
    e = new Uint8Array(t.length);
    for (var n = 0; n < t.length; ++n)
      e[n] = t.charCodeAt(n);
  }
  return uy(cy(fy(e), e.length * 8));
}
function uy(e) {
  for (var t = [], n = e.length * 32, r = "0123456789abcdef", i = 0; i < n; i += 8) {
    var s = e[i >> 5] >>> i % 32 & 255, o = parseInt(r.charAt(s >>> 4 & 15) + r.charAt(s & 15), 16);
    t.push(o);
  }
  return t;
}
function Zc(e) {
  return (e + 64 >>> 9 << 4) + 14 + 1;
}
function cy(e, t) {
  e[t >> 5] |= 128 << t % 32, e[Zc(t) - 1] = t;
  for (var n = 1732584193, r = -271733879, i = -1732584194, s = 271733878, o = 0; o < e.length; o += 16) {
    var u = n, d = r, w = i, g = s;
    n = ge(n, r, i, s, e[o], 7, -680876936), s = ge(s, n, r, i, e[o + 1], 12, -389564586), i = ge(i, s, n, r, e[o + 2], 17, 606105819), r = ge(r, i, s, n, e[o + 3], 22, -1044525330), n = ge(n, r, i, s, e[o + 4], 7, -176418897), s = ge(s, n, r, i, e[o + 5], 12, 1200080426), i = ge(i, s, n, r, e[o + 6], 17, -1473231341), r = ge(r, i, s, n, e[o + 7], 22, -45705983), n = ge(n, r, i, s, e[o + 8], 7, 1770035416), s = ge(s, n, r, i, e[o + 9], 12, -1958414417), i = ge(i, s, n, r, e[o + 10], 17, -42063), r = ge(r, i, s, n, e[o + 11], 22, -1990404162), n = ge(n, r, i, s, e[o + 12], 7, 1804603682), s = ge(s, n, r, i, e[o + 13], 12, -40341101), i = ge(i, s, n, r, e[o + 14], 17, -1502002290), r = ge(r, i, s, n, e[o + 15], 22, 1236535329), n = be(n, r, i, s, e[o + 1], 5, -165796510), s = be(s, n, r, i, e[o + 6], 9, -1069501632), i = be(i, s, n, r, e[o + 11], 14, 643717713), r = be(r, i, s, n, e[o], 20, -373897302), n = be(n, r, i, s, e[o + 5], 5, -701558691), s = be(s, n, r, i, e[o + 10], 9, 38016083), i = be(i, s, n, r, e[o + 15], 14, -660478335), r = be(r, i, s, n, e[o + 4], 20, -405537848), n = be(n, r, i, s, e[o + 9], 5, 568446438), s = be(s, n, r, i, e[o + 14], 9, -1019803690), i = be(i, s, n, r, e[o + 3], 14, -187363961), r = be(r, i, s, n, e[o + 8], 20, 1163531501), n = be(n, r, i, s, e[o + 13], 5, -1444681467), s = be(s, n, r, i, e[o + 2], 9, -51403784), i = be(i, s, n, r, e[o + 7], 14, 1735328473), r = be(r, i, s, n, e[o + 12], 20, -1926607734), n = Ae(n, r, i, s, e[o + 5], 4, -378558), s = Ae(s, n, r, i, e[o + 8], 11, -2022574463), i = Ae(i, s, n, r, e[o + 11], 16, 1839030562), r = Ae(r, i, s, n, e[o + 14], 23, -35309556), n = Ae(n, r, i, s, e[o + 1], 4, -1530992060), s = Ae(s, n, r, i, e[o + 4], 11, 1272893353), i = Ae(i, s, n, r, e[o + 7], 16, -155497632), r = Ae(r, i, s, n, e[o + 10], 23, -1094730640), n = Ae(n, r, i, s, e[o + 13], 4, 681279174), s = Ae(s, n, r, i, e[o], 11, -358537222), i = Ae(i, s, n, r, e[o + 3], 16, -722521979), r = Ae(r, i, s, n, e[o + 6], 23, 76029189), n = Ae(n, r, i, s, e[o + 9], 4, -640364487), s = Ae(s, n, r, i, e[o + 12], 11, -421815835), i = Ae(i, s, n, r, e[o + 15], 16, 530742520), r = Ae(r, i, s, n, e[o + 2], 23, -995338651), n = xe(n, r, i, s, e[o], 6, -198630844), s = xe(s, n, r, i, e[o + 7], 10, 1126891415), i = xe(i, s, n, r, e[o + 14], 15, -1416354905), r = xe(r, i, s, n, e[o + 5], 21, -57434055), n = xe(n, r, i, s, e[o + 12], 6, 1700485571), s = xe(s, n, r, i, e[o + 3], 10, -1894986606), i = xe(i, s, n, r, e[o + 10], 15, -1051523), r = xe(r, i, s, n, e[o + 1], 21, -2054922799), n = xe(n, r, i, s, e[o + 8], 6, 1873313359), s = xe(s, n, r, i, e[o + 15], 10, -30611744), i = xe(i, s, n, r, e[o + 6], 15, -1560198380), r = xe(r, i, s, n, e[o + 13], 21, 1309151649), n = xe(n, r, i, s, e[o + 4], 6, -145523070), s = xe(s, n, r, i, e[o + 11], 10, -1120210379), i = xe(i, s, n, r, e[o + 2], 15, 718787259), r = xe(r, i, s, n, e[o + 9], 21, -343485551), n = bn(n, u), r = bn(r, d), i = bn(i, w), s = bn(s, g);
  }
  return [n, r, i, s];
}
function fy(e) {
  if (e.length === 0)
    return [];
  for (var t = e.length * 8, n = new Uint32Array(Zc(t)), r = 0; r < t; r += 8)
    n[r >> 5] |= (e[r / 8] & 255) << r % 32;
  return n;
}
function bn(e, t) {
  var n = (e & 65535) + (t & 65535), r = (e >> 16) + (t >> 16) + (n >> 16);
  return r << 16 | n & 65535;
}
function ly(e, t) {
  return e << t | e >>> 32 - t;
}
function Di(e, t, n, r, i, s) {
  return bn(ly(bn(bn(t, e), bn(r, s)), i), n);
}
function ge(e, t, n, r, i, s, o) {
  return Di(t & n | ~t & r, e, t, i, s, o);
}
function be(e, t, n, r, i, s, o) {
  return Di(t & r | n & ~r, e, t, i, s, o);
}
function Ae(e, t, n, r, i, s, o) {
  return Di(t ^ n ^ r, e, t, i, s, o);
}
function xe(e, t, n, r, i, s, o) {
  return Di(n ^ (t | ~r), e, t, i, s, o);
}
var hy = Yc("v3", 48, ay);
const dy = hy;
function py(e, t, n) {
  e = e || {};
  var r = e.random || (e.rng || qc)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, t) {
    n = n || 0;
    for (var i = 0; i < 16; ++i)
      t[n + i] = r[i];
    return t;
  }
  return Pi(r);
}
function yy(e, t, n, r) {
  switch (e) {
    case 0:
      return t & n ^ ~t & r;
    case 1:
      return t ^ n ^ r;
    case 2:
      return t & n ^ t & r ^ n & r;
    case 3:
      return t ^ n ^ r;
  }
}
function Cs(e, t) {
  return e << t | e >>> 32 - t;
}
function my(e) {
  var t = [1518500249, 1859775393, 2400959708, 3395469782], n = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
  if (typeof e == "string") {
    var r = unescape(encodeURIComponent(e));
    e = [];
    for (var i = 0; i < r.length; ++i)
      e.push(r.charCodeAt(i));
  } else
    Array.isArray(e) || (e = Array.prototype.slice.call(e));
  e.push(128);
  for (var s = e.length / 4 + 2, o = Math.ceil(s / 16), u = new Array(o), d = 0; d < o; ++d) {
    for (var w = new Uint32Array(16), g = 0; g < 16; ++g)
      w[g] = e[d * 64 + g * 4] << 24 | e[d * 64 + g * 4 + 1] << 16 | e[d * 64 + g * 4 + 2] << 8 | e[d * 64 + g * 4 + 3];
    u[d] = w;
  }
  u[o - 1][14] = (e.length - 1) * 8 / Math.pow(2, 32), u[o - 1][14] = Math.floor(u[o - 1][14]), u[o - 1][15] = (e.length - 1) * 8 & 4294967295;
  for (var v = 0; v < o; ++v) {
    for (var I = new Uint32Array(80), S = 0; S < 16; ++S)
      I[S] = u[v][S];
    for (var D = 16; D < 80; ++D)
      I[D] = Cs(I[D - 3] ^ I[D - 8] ^ I[D - 14] ^ I[D - 16], 1);
    for (var N = n[0], T = n[1], O = n[2], _ = n[3], k = n[4], V = 0; V < 80; ++V) {
      var H = Math.floor(V / 20), z = Cs(N, 5) + yy(H, T, O, _) + k + t[H] + I[V] >>> 0;
      k = _, _ = O, O = Cs(T, 30) >>> 0, T = N, N = z;
    }
    n[0] = n[0] + N >>> 0, n[1] = n[1] + T >>> 0, n[2] = n[2] + O >>> 0, n[3] = n[3] + _ >>> 0, n[4] = n[4] + k >>> 0;
  }
  return [n[0] >> 24 & 255, n[0] >> 16 & 255, n[0] >> 8 & 255, n[0] & 255, n[1] >> 24 & 255, n[1] >> 16 & 255, n[1] >> 8 & 255, n[1] & 255, n[2] >> 24 & 255, n[2] >> 16 & 255, n[2] >> 8 & 255, n[2] & 255, n[3] >> 24 & 255, n[3] >> 16 & 255, n[3] >> 8 & 255, n[3] & 255, n[4] >> 24 & 255, n[4] >> 16 & 255, n[4] >> 8 & 255, n[4] & 255];
}
var wy = Yc("v5", 80, my);
const gy = wy, by = "00000000-0000-0000-0000-000000000000";
function Ay(e) {
  if (!Ri(e))
    throw TypeError("Invalid UUID");
  return parseInt(e.substr(14, 1), 16);
}
const xy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  NIL: by,
  parse: jc,
  stringify: Pi,
  v1: ry,
  v3: dy,
  v4: py,
  v5: gy,
  validate: Ri,
  version: Ay
}, Symbol.toStringTag, { value: "Module" })), Jc = /* @__PURE__ */ xo(xy), Ey = Jc.v4, vy = function(e, t, n, r) {
  if (typeof e != "string")
    throw new TypeError(e + " must be a string");
  r = r || {};
  const i = typeof r.version == "number" ? r.version : 2;
  if (i !== 1 && i !== 2)
    throw new TypeError(i + " must be 1 or 2");
  const s = {
    method: e
  };
  if (i === 2 && (s.jsonrpc = "2.0"), t) {
    if (typeof t != "object" && !Array.isArray(t))
      throw new TypeError(t + " must be an object, array or omitted");
    s.params = t;
  }
  if (typeof n > "u") {
    const o = typeof r.generator == "function" ? r.generator : function() {
      return Ey();
    };
    s.id = o(s, r);
  } else
    i === 2 && n === null ? r.notificationIdNull && (s.id = null) : s.id = n;
  return s;
};
var By = vy;
const Iy = Jc.v4, My = By, bi = function(e, t) {
  if (!(this instanceof bi))
    return new bi(e, t);
  t || (t = {}), this.options = {
    reviver: typeof t.reviver < "u" ? t.reviver : null,
    replacer: typeof t.replacer < "u" ? t.replacer : null,
    generator: typeof t.generator < "u" ? t.generator : function() {
      return Iy();
    },
    version: typeof t.version < "u" ? t.version : 2,
    notificationIdNull: typeof t.notificationIdNull == "boolean" ? t.notificationIdNull : !1
  }, this.callServer = e;
};
bi.prototype.request = function(e, t, n, r) {
  const i = this;
  let s = null;
  const o = Array.isArray(e) && typeof t == "function";
  if (this.options.version === 1 && o)
    throw new TypeError("JSON-RPC 1.0 does not support batching");
  if (o || !o && e && typeof e == "object" && typeof t == "function")
    r = t, s = e;
  else {
    typeof n == "function" && (r = n, n = void 0);
    const w = typeof r == "function";
    try {
      s = My(e, t, n, {
        generator: this.options.generator,
        version: this.options.version,
        notificationIdNull: this.options.notificationIdNull
      });
    } catch (g) {
      if (w)
        return r(g);
      throw g;
    }
    if (!w)
      return s;
  }
  let d;
  try {
    d = JSON.stringify(s, this.options.replacer);
  } catch (w) {
    return r(w);
  }
  return this.callServer(d, function(w, g) {
    i._parseResponse(w, g, r);
  }), s;
};
bi.prototype._parseResponse = function(e, t, n) {
  if (e) {
    n(e);
    return;
  }
  if (!t)
    return n();
  let r;
  try {
    r = JSON.parse(t, this.options.reviver);
  } catch (i) {
    return n(i);
  }
  if (n.length === 3)
    if (Array.isArray(r)) {
      const i = function(o) {
        return typeof o.error < "u";
      }, s = function(o) {
        return !i(o);
      };
      return n(null, r.filter(i), r.filter(s));
    } else
      return n(null, r.error, r.result);
  n(null, r);
};
var Xc = {}, Wc = { exports: {} };
(function(e) {
  var t = Object.prototype.hasOwnProperty, n = "~";
  function r() {
  }
  Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (n = !1));
  function i(d, w, g) {
    this.fn = d, this.context = w, this.once = g || !1;
  }
  function s(d, w, g, v, I) {
    if (typeof g != "function")
      throw new TypeError("The listener must be a function");
    var S = new i(g, v || d, I), D = n ? n + w : w;
    return d._events[D] ? d._events[D].fn ? d._events[D] = [d._events[D], S] : d._events[D].push(S) : (d._events[D] = S, d._eventsCount++), d;
  }
  function o(d, w) {
    --d._eventsCount === 0 ? d._events = new r() : delete d._events[w];
  }
  function u() {
    this._events = new r(), this._eventsCount = 0;
  }
  u.prototype.eventNames = function() {
    var w = [], g, v;
    if (this._eventsCount === 0)
      return w;
    for (v in g = this._events)
      t.call(g, v) && w.push(n ? v.slice(1) : v);
    return Object.getOwnPropertySymbols ? w.concat(Object.getOwnPropertySymbols(g)) : w;
  }, u.prototype.listeners = function(w) {
    var g = n ? n + w : w, v = this._events[g];
    if (!v)
      return [];
    if (v.fn)
      return [v.fn];
    for (var I = 0, S = v.length, D = new Array(S); I < S; I++)
      D[I] = v[I].fn;
    return D;
  }, u.prototype.listenerCount = function(w) {
    var g = n ? n + w : w, v = this._events[g];
    return v ? v.fn ? 1 : v.length : 0;
  }, u.prototype.emit = function(w, g, v, I, S, D) {
    var N = n ? n + w : w;
    if (!this._events[N])
      return !1;
    var T = this._events[N], O = arguments.length, _, k;
    if (T.fn) {
      switch (T.once && this.removeListener(w, T.fn, void 0, !0), O) {
        case 1:
          return T.fn.call(T.context), !0;
        case 2:
          return T.fn.call(T.context, g), !0;
        case 3:
          return T.fn.call(T.context, g, v), !0;
        case 4:
          return T.fn.call(T.context, g, v, I), !0;
        case 5:
          return T.fn.call(T.context, g, v, I, S), !0;
        case 6:
          return T.fn.call(T.context, g, v, I, S, D), !0;
      }
      for (k = 1, _ = new Array(O - 1); k < O; k++)
        _[k - 1] = arguments[k];
      T.fn.apply(T.context, _);
    } else {
      var V = T.length, H;
      for (k = 0; k < V; k++)
        switch (T[k].once && this.removeListener(w, T[k].fn, void 0, !0), O) {
          case 1:
            T[k].fn.call(T[k].context);
            break;
          case 2:
            T[k].fn.call(T[k].context, g);
            break;
          case 3:
            T[k].fn.call(T[k].context, g, v);
            break;
          case 4:
            T[k].fn.call(T[k].context, g, v, I);
            break;
          default:
            if (!_)
              for (H = 1, _ = new Array(O - 1); H < O; H++)
                _[H - 1] = arguments[H];
            T[k].fn.apply(T[k].context, _);
        }
    }
    return !0;
  }, u.prototype.on = function(w, g, v) {
    return s(this, w, g, v, !1);
  }, u.prototype.once = function(w, g, v) {
    return s(this, w, g, v, !0);
  }, u.prototype.removeListener = function(w, g, v, I) {
    var S = n ? n + w : w;
    if (!this._events[S])
      return this;
    if (!g)
      return o(this, S), this;
    var D = this._events[S];
    if (D.fn)
      D.fn === g && (!I || D.once) && (!v || D.context === v) && o(this, S);
    else {
      for (var N = 0, T = [], O = D.length; N < O; N++)
        (D[N].fn !== g || I && !D[N].once || v && D[N].context !== v) && T.push(D[N]);
      T.length ? this._events[S] = T.length === 1 ? T[0] : T : o(this, S);
    }
    return this;
  }, u.prototype.removeAllListeners = function(w) {
    var g;
    return w ? (g = n ? n + w : w, this._events[g] && o(this, g)) : (this._events = new r(), this._eventsCount = 0), this;
  }, u.prototype.off = u.prototype.removeListener, u.prototype.addListener = u.prototype.on, u.prefixed = n, u.EventEmitter = u, e.exports = u;
})(Wc);
var $c = Wc.exports, hr = {};
Object.defineProperty(hr, "__esModule", { value: !0 });
hr.createError = hr.DefaultDataPack = void 0;
const Ty = /* @__PURE__ */ new Map([
  [-32e3, "Event not provided"],
  [-32600, "Invalid Request"],
  [-32601, "Method not found"],
  [-32602, "Invalid params"],
  [-32603, "Internal error"],
  [-32604, "Params not found"],
  [-32605, "Method forbidden"],
  [-32606, "Event forbidden"],
  [-32700, "Parse error"]
]);
class Cy {
  encode(t) {
    return JSON.stringify(t);
  }
  decode(t) {
    return JSON.parse(t);
  }
}
hr.DefaultDataPack = Cy;
function Sy(e, t) {
  const n = {
    code: e,
    message: Ty.get(e) || "Internal Server Error"
  };
  return t && (n.data = t), n;
}
hr.createError = Sy;
Object.defineProperty(Xc, "__esModule", { value: !0 });
const Uy = $c, Fy = hr;
class ky extends Uy.EventEmitter {
  /**
   * Instantiate a Client class.
   * @constructor
   * @param {webSocketFactory} webSocketFactory - factory method for WebSocket
   * @param {String} address - url to a websocket server
   * @param {Object} options - ws options object with reconnect parameters
   * @param {Function} generate_request_id - custom generation request Id
   * @param {DataPack} dataPack - data pack contains encoder and decoder
   * @return {CommonClient}
   */
  constructor(n, r = "ws://localhost:8080", { autoconnect: i = !0, reconnect: s = !0, reconnect_interval: o = 1e3, max_reconnects: u = 5, ...d } = {}, w, g) {
    super();
    Tt(this, "address");
    Tt(this, "rpc_id");
    Tt(this, "queue");
    Tt(this, "options");
    Tt(this, "autoconnect");
    Tt(this, "ready");
    Tt(this, "reconnect");
    Tt(this, "reconnect_timer_id");
    Tt(this, "reconnect_interval");
    Tt(this, "max_reconnects");
    Tt(this, "rest_options");
    Tt(this, "current_reconnects");
    Tt(this, "generate_request_id");
    Tt(this, "socket");
    Tt(this, "webSocketFactory");
    Tt(this, "dataPack");
    this.webSocketFactory = n, this.queue = {}, this.rpc_id = 0, this.address = r, this.autoconnect = i, this.ready = !1, this.reconnect = s, this.reconnect_timer_id = void 0, this.reconnect_interval = o, this.max_reconnects = u, this.rest_options = d, this.current_reconnects = 0, this.generate_request_id = w || (() => ++this.rpc_id), g ? this.dataPack = g : this.dataPack = new Fy.DefaultDataPack(), this.autoconnect && this._connect(this.address, {
      autoconnect: this.autoconnect,
      reconnect: this.reconnect,
      reconnect_interval: this.reconnect_interval,
      max_reconnects: this.max_reconnects,
      ...this.rest_options
    });
  }
  /**
   * Connects to a defined server if not connected already.
   * @method
   * @return {Undefined}
   */
  connect() {
    this.socket || this._connect(this.address, {
      autoconnect: this.autoconnect,
      reconnect: this.reconnect,
      reconnect_interval: this.reconnect_interval,
      max_reconnects: this.max_reconnects,
      ...this.rest_options
    });
  }
  /**
   * Calls a registered RPC method on server.
   * @method
   * @param {String} method - RPC method name
   * @param {Object|Array} params - optional method parameters
   * @param {Number} timeout - RPC reply timeout value
   * @param {Object} ws_opts - options passed to ws
   * @return {Promise}
   */
  call(n, r, i, s) {
    return !s && typeof i == "object" && (s = i, i = null), new Promise((o, u) => {
      if (!this.ready)
        return u(new Error("socket not ready"));
      const d = this.generate_request_id(n, r), w = {
        jsonrpc: "2.0",
        method: n,
        params: r || void 0,
        id: d
      };
      this.socket.send(this.dataPack.encode(w), s, (g) => {
        if (g)
          return u(g);
        this.queue[d] = { promise: [o, u] }, i && (this.queue[d].timeout = setTimeout(() => {
          delete this.queue[d], u(new Error("reply timeout"));
        }, i));
      });
    });
  }
  /**
   * Logins with the other side of the connection.
   * @method
   * @param {Object} params - Login credentials object
   * @return {Promise}
   */
  async login(n) {
    const r = await this.call("rpc.login", n);
    if (!r)
      throw new Error("authentication failed");
    return r;
  }
  /**
   * Fetches a list of client's methods registered on server.
   * @method
   * @return {Array}
   */
  async listMethods() {
    return await this.call("__listMethods");
  }
  /**
   * Sends a JSON-RPC 2.0 notification to server.
   * @method
   * @param {String} method - RPC method name
   * @param {Object} params - optional method parameters
   * @return {Promise}
   */
  notify(n, r) {
    return new Promise((i, s) => {
      if (!this.ready)
        return s(new Error("socket not ready"));
      const o = {
        jsonrpc: "2.0",
        method: n,
        params: r
      };
      this.socket.send(this.dataPack.encode(o), (u) => {
        if (u)
          return s(u);
        i();
      });
    });
  }
  /**
   * Subscribes for a defined event.
   * @method
   * @param {String|Array} event - event name
   * @return {Undefined}
   * @throws {Error}
   */
  async subscribe(n) {
    typeof n == "string" && (n = [n]);
    const r = await this.call("rpc.on", n);
    if (typeof n == "string" && r[n] !== "ok")
      throw new Error("Failed subscribing to an event '" + n + "' with: " + r[n]);
    return r;
  }
  /**
   * Unsubscribes from a defined event.
   * @method
   * @param {String|Array} event - event name
   * @return {Undefined}
   * @throws {Error}
   */
  async unsubscribe(n) {
    typeof n == "string" && (n = [n]);
    const r = await this.call("rpc.off", n);
    if (typeof n == "string" && r[n] !== "ok")
      throw new Error("Failed unsubscribing from an event with: " + r);
    return r;
  }
  /**
   * Closes a WebSocket connection gracefully.
   * @method
   * @param {Number} code - socket close code
   * @param {String} data - optional data to be sent before closing
   * @return {Undefined}
   */
  close(n, r) {
    this.socket.close(n || 1e3, r);
  }
  /**
   * Enable / disable automatic reconnection.
   * @method
   * @param {Boolean} reconnect - enable / disable reconnection
   * @return {Undefined}
   */
  setAutoReconnect(n) {
    this.reconnect = n;
  }
  /**
   * Set the interval between reconnection attempts.
   * @method
   * @param {Number} interval - reconnection interval in milliseconds
   * @return {Undefined}
   */
  setReconnectInterval(n) {
    this.reconnect_interval = n;
  }
  /**
   * Set the maximum number of reconnection attempts.
   * @method
   * @param {Number} max_reconnects - maximum reconnection attempts
   * @return {Undefined}
   */
  setMaxReconnects(n) {
    this.max_reconnects = n;
  }
  /**
   * Connection/Message handler.
   * @method
   * @private
   * @param {String} address - WebSocket API address
   * @param {Object} options - ws options object
   * @return {Undefined}
   */
  _connect(n, r) {
    clearTimeout(this.reconnect_timer_id), this.socket = this.webSocketFactory(n, r), this.socket.addEventListener("open", () => {
      this.ready = !0, this.emit("open"), this.current_reconnects = 0;
    }), this.socket.addEventListener("message", ({ data: i }) => {
      i instanceof ArrayBuffer && (i = Buffer.from(i).toString());
      try {
        i = this.dataPack.decode(i);
      } catch {
        return;
      }
      if (i.notification && this.listeners(i.notification).length) {
        if (!Object.keys(i.params).length)
          return this.emit(i.notification);
        const s = [i.notification];
        if (i.params.constructor === Object)
          s.push(i.params);
        else
          for (let o = 0; o < i.params.length; o++)
            s.push(i.params[o]);
        return Promise.resolve().then(() => {
          this.emit.apply(this, s);
        });
      }
      if (!this.queue[i.id])
        return i.method ? Promise.resolve().then(() => {
          this.emit(i.method, i == null ? void 0 : i.params);
        }) : void 0;
      "error" in i == "result" in i && this.queue[i.id].promise[1](new Error('Server response malformed. Response must include either "result" or "error", but not both.')), this.queue[i.id].timeout && clearTimeout(this.queue[i.id].timeout), i.error ? this.queue[i.id].promise[1](i.error) : this.queue[i.id].promise[0](i.result), delete this.queue[i.id];
    }), this.socket.addEventListener("error", (i) => this.emit("error", i)), this.socket.addEventListener("close", ({ code: i, reason: s }) => {
      this.ready && setTimeout(() => this.emit("close", i, s), 0), this.ready = !1, this.socket = void 0, i !== 1e3 && (this.current_reconnects++, this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0) && (this.reconnect_timer_id = setTimeout(() => this._connect(n, r), this.reconnect_interval)));
    });
  }
}
Xc.default = ky;
var tf = {};
Object.defineProperty(tf, "__esModule", { value: !0 });
const Ny = $c;
class Ry extends Ny.EventEmitter {
  /** Instantiate a WebSocket class
   * @constructor
   * @param {String} address - url to a websocket server
   * @param {(Object)} options - websocket options
   * @param {(String|Array)} protocols - a list of protocols
   * @return {WebSocketBrowserImpl} - returns a WebSocket instance
   */
  constructor(n, r, i) {
    super();
    Tt(this, "socket");
    this.socket = new window.WebSocket(n, i), this.socket.onopen = () => this.emit("open"), this.socket.onmessage = (s) => this.emit("message", s.data), this.socket.onerror = (s) => this.emit("error", s), this.socket.onclose = (s) => {
      this.emit("close", s.code, s.reason);
    };
  }
  /**
   * Sends data through a websocket connection
   * @method
   * @param {(String|Object)} data - data to be sent via websocket
   * @param {Object} optionsOrCallback - ws options
   * @param {Function} callback - a callback called once the data is sent
   * @return {Undefined}
   */
  send(n, r, i) {
    const s = i || r;
    try {
      this.socket.send(n), s();
    } catch (o) {
      s(o);
    }
  }
  /**
   * Closes an underlying socket
   * @method
   * @param {Number} code - status code explaining why the connection is being closed
   * @param {String} reason - a description why the connection is closing
   * @return {Undefined}
   * @throws {Error}
   */
  close(n, r) {
    this.socket.close(n, r);
  }
  addEventListener(n, r, i) {
    this.socket.addEventListener(n, r, i);
  }
}
function Py(e, t) {
  return new Ry(e, t);
}
tf.default = Py;
class ef extends ao {
  constructor(t, n) {
    super(), this.finished = !1, this.destroyed = !1, ml(t);
    const r = vi(n);
    if (this.iHash = t.create(), typeof this.iHash.update != "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen, this.outputLen = this.iHash.outputLen;
    const i = this.blockLen, s = new Uint8Array(i);
    s.set(r.length > i ? t.create().update(r).digest() : r);
    for (let o = 0; o < s.length; o++)
      s[o] ^= 54;
    this.iHash.update(s), this.oHash = t.create();
    for (let o = 0; o < s.length; o++)
      s[o] ^= 106;
    this.oHash.update(s), s.fill(0);
  }
  update(t) {
    return sr(this), this.iHash.update(t), this;
  }
  digestInto(t) {
    sr(this), _r(t, this.outputLen), this.finished = !0, this.iHash.digestInto(t), this.oHash.update(t), this.oHash.digestInto(t), this.destroy();
  }
  digest() {
    const t = new Uint8Array(this.oHash.outputLen);
    return this.digestInto(t), t;
  }
  _cloneInto(t) {
    t || (t = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash: n, iHash: r, finished: i, destroyed: s, blockLen: o, outputLen: u } = this;
    return t = t, t.finished = i, t.destroyed = s, t.blockLen = o, t.outputLen = u, t.oHash = n._cloneInto(t.oHash), t.iHash = r._cloneInto(t.iHash), t;
  }
  destroy() {
    this.destroyed = !0, this.oHash.destroy(), this.iHash.destroy();
  }
}
const nf = (e, t, n) => new ef(e, t).update(n).digest();
nf.create = (e, t) => new ef(e, t);
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function La(e) {
  e.lowS !== void 0 && ln("lowS", e.lowS), e.prehash !== void 0 && ln("prehash", e.prehash);
}
function Dy(e) {
  const t = To(e);
  wr(t, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo: n, Fp: r, a: i } = t;
  if (n) {
    if (!r.eql(i, r.ZERO))
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    if (typeof n != "object" || typeof n.beta != "bigint" || typeof n.splitScalar != "function")
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
  }
  return Object.freeze({ ...t });
}
const { bytesToNumberBE: Oy, hexToBytes: Ly } = Yd, sn = {
  // asn.1 DER encoding utils
  Err: class extends Error {
    constructor(t = "") {
      super(t);
    }
  },
  // Basic building block is TLV (Tag-Length-Value)
  _tlv: {
    encode: (e, t) => {
      const { Err: n } = sn;
      if (e < 0 || e > 256)
        throw new n("tlv.encode: wrong tag");
      if (t.length & 1)
        throw new n("tlv.encode: unpadded data");
      const r = t.length / 2, i = tr(r);
      if (i.length / 2 & 128)
        throw new n("tlv.encode: long form length too big");
      const s = r > 127 ? tr(i.length / 2 | 128) : "";
      return `${tr(e)}${s}${i}${t}`;
    },
    // v - value, l - left bytes (unparsed)
    decode(e, t) {
      const { Err: n } = sn;
      let r = 0;
      if (e < 0 || e > 256)
        throw new n("tlv.encode: wrong tag");
      if (t.length < 2 || t[r++] !== e)
        throw new n("tlv.decode: wrong tlv");
      const i = t[r++], s = !!(i & 128);
      let o = 0;
      if (!s)
        o = i;
      else {
        const d = i & 127;
        if (!d)
          throw new n("tlv.decode(long): indefinite length not supported");
        if (d > 4)
          throw new n("tlv.decode(long): byte length is too big");
        const w = t.subarray(r, r + d);
        if (w.length !== d)
          throw new n("tlv.decode: length bytes not complete");
        if (w[0] === 0)
          throw new n("tlv.decode(long): zero leftmost byte");
        for (const g of w)
          o = o << 8 | g;
        if (r += d, o < 128)
          throw new n("tlv.decode(long): not minimal encoding");
      }
      const u = t.subarray(r, r + o);
      if (u.length !== o)
        throw new n("tlv.decode: wrong value length");
      return { v: u, l: t.subarray(r + o) };
    }
  },
  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,
  // since we always use positive integers here. It must always be empty:
  // - add zero byte if exists
  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)
  _int: {
    encode(e) {
      const { Err: t } = sn;
      if (e < un)
        throw new t("integer: negative integers are not allowed");
      let n = tr(e);
      if (Number.parseInt(n[0], 16) & 8 && (n = "00" + n), n.length & 1)
        throw new t("unexpected assertion");
      return n;
    },
    decode(e) {
      const { Err: t } = sn;
      if (e[0] & 128)
        throw new t("Invalid signature integer: negative");
      if (e[0] === 0 && !(e[1] & 128))
        throw new t("Invalid signature integer: unnecessary leading zero");
      return Oy(e);
    }
  },
  toSig(e) {
    const { Err: t, _int: n, _tlv: r } = sn, i = typeof e == "string" ? Ly(e) : e;
    Hr(i);
    const { v: s, l: o } = r.decode(48, i);
    if (o.length)
      throw new t("Invalid signature: left bytes after parsing");
    const { v: u, l: d } = r.decode(2, s), { v: w, l: g } = r.decode(2, d);
    if (g.length)
      throw new t("Invalid signature: left bytes after parsing");
    return { r: n.decode(u), s: n.decode(w) };
  },
  hexFromSig(e) {
    const { _tlv: t, _int: n } = sn, r = `${t.encode(2, n.encode(e.r))}${t.encode(2, n.encode(e.s))}`;
    return t.encode(48, r);
  }
}, un = BigInt(0), he = BigInt(1);
BigInt(2);
const _a = BigInt(3);
BigInt(4);
function _y(e) {
  const t = Dy(e), { Fp: n } = t, r = Ui(t.n, t.nBitLength), i = t.toBytes || ((N, T, O) => {
    const _ = T.toAffine();
    return _n(Uint8Array.from([4]), n.toBytes(_.x), n.toBytes(_.y));
  }), s = t.fromBytes || ((N) => {
    const T = N.subarray(1), O = n.fromBytes(T.subarray(0, n.BYTES)), _ = n.fromBytes(T.subarray(n.BYTES, 2 * n.BYTES));
    return { x: O, y: _ };
  });
  function o(N) {
    const { a: T, b: O } = t, _ = n.sqr(N), k = n.mul(_, N);
    return n.add(n.add(k, n.mul(N, T)), O);
  }
  if (!n.eql(n.sqr(t.Gy), o(t.Gx)))
    throw new Error("bad generator point: equation left != right");
  function u(N) {
    return Si(N, he, t.n);
  }
  function d(N) {
    const { allowedPrivateKeyLengths: T, nByteLength: O, wrapPrivateKey: _, n: k } = t;
    if (T && typeof N != "bigint") {
      if (On(N) && (N = Ln(N)), typeof N != "string" || !T.includes(N.length))
        throw new Error("Invalid key");
      N = N.padStart(O * 2, "0");
    }
    let V;
    try {
      V = typeof N == "bigint" ? N : kn(fe("private key", N, O));
    } catch {
      throw new Error(`private key must be ${O} bytes, hex or bigint, not ${typeof N}`);
    }
    return _ && (V = Dt(V, k)), Oe("private key", V, he, k), V;
  }
  function w(N) {
    if (!(N instanceof I))
      throw new Error("ProjectivePoint expected");
  }
  const g = Or((N, T) => {
    const { px: O, py: _, pz: k } = N;
    if (n.eql(k, n.ONE))
      return { x: O, y: _ };
    const V = N.is0();
    T == null && (T = V ? n.ONE : n.inv(k));
    const H = n.mul(O, T), z = n.mul(_, T), j = n.mul(k, T);
    if (V)
      return { x: n.ZERO, y: n.ZERO };
    if (!n.eql(j, n.ONE))
      throw new Error("invZ was invalid");
    return { x: H, y: z };
  }), v = Or((N) => {
    if (N.is0()) {
      if (t.allowInfinityPoint && !n.is0(N.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: T, y: O } = N.toAffine();
    if (!n.isValid(T) || !n.isValid(O))
      throw new Error("bad point: x or y not FE");
    const _ = n.sqr(O), k = o(T);
    if (!n.eql(_, k))
      throw new Error("bad point: equation left != right");
    if (!N.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return !0;
  });
  class I {
    constructor(T, O, _) {
      if (this.px = T, this.py = O, this.pz = _, T == null || !n.isValid(T))
        throw new Error("x required");
      if (O == null || !n.isValid(O))
        throw new Error("y required");
      if (_ == null || !n.isValid(_))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(T) {
      const { x: O, y: _ } = T || {};
      if (!T || !n.isValid(O) || !n.isValid(_))
        throw new Error("invalid affine point");
      if (T instanceof I)
        throw new Error("projective point not allowed");
      const k = (V) => n.eql(V, n.ZERO);
      return k(O) && k(_) ? I.ZERO : new I(O, _, n.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(T) {
      const O = n.invertBatch(T.map((_) => _.pz));
      return T.map((_, k) => _.toAffine(O[k])).map(I.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(T) {
      const O = I.fromAffine(s(fe("pointHex", T)));
      return O.assertValidity(), O;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(T) {
      return I.BASE.multiply(d(T));
    }
    // Multiscalar Multiplication
    static msm(T, O) {
      return mc(I, r, T, O);
    }
    // "Private method", don't use it directly
    _setWindowSize(T) {
      D.setWindowSize(this, T);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      v(this);
    }
    hasEvenY() {
      const { y: T } = this.toAffine();
      if (n.isOdd)
        return !n.isOdd(T);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(T) {
      w(T);
      const { px: O, py: _, pz: k } = this, { px: V, py: H, pz: z } = T, j = n.eql(n.mul(O, z), n.mul(V, k)), Y = n.eql(n.mul(_, z), n.mul(H, k));
      return j && Y;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new I(this.px, n.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: T, b: O } = t, _ = n.mul(O, _a), { px: k, py: V, pz: H } = this;
      let z = n.ZERO, j = n.ZERO, Y = n.ZERO, J = n.mul(k, k), gt = n.mul(V, V), $ = n.mul(H, H), ot = n.mul(k, V);
      return ot = n.add(ot, ot), Y = n.mul(k, H), Y = n.add(Y, Y), z = n.mul(T, Y), j = n.mul(_, $), j = n.add(z, j), z = n.sub(gt, j), j = n.add(gt, j), j = n.mul(z, j), z = n.mul(ot, z), Y = n.mul(_, Y), $ = n.mul(T, $), ot = n.sub(J, $), ot = n.mul(T, ot), ot = n.add(ot, Y), Y = n.add(J, J), J = n.add(Y, J), J = n.add(J, $), J = n.mul(J, ot), j = n.add(j, J), $ = n.mul(V, H), $ = n.add($, $), J = n.mul($, ot), z = n.sub(z, J), Y = n.mul($, gt), Y = n.add(Y, Y), Y = n.add(Y, Y), new I(z, j, Y);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(T) {
      w(T);
      const { px: O, py: _, pz: k } = this, { px: V, py: H, pz: z } = T;
      let j = n.ZERO, Y = n.ZERO, J = n.ZERO;
      const gt = t.a, $ = n.mul(t.b, _a);
      let ot = n.mul(O, V), M = n.mul(_, H), a = n.mul(k, z), h = n.add(O, _), p = n.add(V, H);
      h = n.mul(h, p), p = n.add(ot, M), h = n.sub(h, p), p = n.add(O, k);
      let y = n.add(V, z);
      return p = n.mul(p, y), y = n.add(ot, a), p = n.sub(p, y), y = n.add(_, k), j = n.add(H, z), y = n.mul(y, j), j = n.add(M, a), y = n.sub(y, j), J = n.mul(gt, p), j = n.mul($, a), J = n.add(j, J), j = n.sub(M, J), J = n.add(M, J), Y = n.mul(j, J), M = n.add(ot, ot), M = n.add(M, ot), a = n.mul(gt, a), p = n.mul($, p), M = n.add(M, a), a = n.sub(ot, a), a = n.mul(gt, a), p = n.add(p, a), ot = n.mul(M, p), Y = n.add(Y, ot), ot = n.mul(y, p), j = n.mul(h, j), j = n.sub(j, ot), ot = n.mul(h, M), J = n.mul(y, J), J = n.add(J, ot), new I(j, Y, J);
    }
    subtract(T) {
      return this.add(T.negate());
    }
    is0() {
      return this.equals(I.ZERO);
    }
    wNAF(T) {
      return D.wNAFCached(this, T, I.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(T) {
      Oe("scalar", T, un, t.n);
      const O = I.ZERO;
      if (T === un)
        return O;
      if (T === he)
        return this;
      const { endo: _ } = t;
      if (!_)
        return D.unsafeLadder(this, T);
      let { k1neg: k, k1: V, k2neg: H, k2: z } = _.splitScalar(T), j = O, Y = O, J = this;
      for (; V > un || z > un; )
        V & he && (j = j.add(J)), z & he && (Y = Y.add(J)), J = J.double(), V >>= he, z >>= he;
      return k && (j = j.negate()), H && (Y = Y.negate()), Y = new I(n.mul(Y.px, _.beta), Y.py, Y.pz), j.add(Y);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(T) {
      const { endo: O, n: _ } = t;
      Oe("scalar", T, he, _);
      let k, V;
      if (O) {
        const { k1neg: H, k1: z, k2neg: j, k2: Y } = O.splitScalar(T);
        let { p: J, f: gt } = this.wNAF(z), { p: $, f: ot } = this.wNAF(Y);
        J = D.constTimeNegate(H, J), $ = D.constTimeNegate(j, $), $ = new I(n.mul($.px, O.beta), $.py, $.pz), k = J.add($), V = gt.add(ot);
      } else {
        const { p: H, f: z } = this.wNAF(T);
        k = H, V = z;
      }
      return I.normalizeZ([k, V])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(T, O, _) {
      const k = I.BASE, V = (z, j) => j === un || j === he || !z.equals(k) ? z.multiplyUnsafe(j) : z.multiply(j), H = V(this, O).add(V(T, _));
      return H.is0() ? void 0 : H;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(T) {
      return g(this, T);
    }
    isTorsionFree() {
      const { h: T, isTorsionFree: O } = t;
      if (T === he)
        return !0;
      if (O)
        return O(I, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: T, clearCofactor: O } = t;
      return T === he ? this : O ? O(I, this) : this.multiplyUnsafe(t.h);
    }
    toRawBytes(T = !0) {
      return ln("isCompressed", T), this.assertValidity(), i(I, this, T);
    }
    toHex(T = !0) {
      return ln("isCompressed", T), Ln(this.toRawBytes(T));
    }
  }
  I.BASE = new I(t.Gx, t.Gy, n.ONE), I.ZERO = new I(n.ZERO, n.ONE, n.ZERO);
  const S = t.nBitLength, D = yc(I, t.endo ? Math.ceil(S / 2) : S);
  return {
    CURVE: t,
    ProjectivePoint: I,
    normPrivateKeyToScalar: d,
    weierstrassEquation: o,
    isWithinCurveOrder: u
  };
}
function Gy(e) {
  const t = To(e);
  return wr(t, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  }), Object.freeze({ lowS: !0, ...t });
}
function zy(e) {
  const t = Gy(e), { Fp: n, n: r } = t, i = n.BYTES + 1, s = 2 * n.BYTES + 1;
  function o(a) {
    return Dt(a, r);
  }
  function u(a) {
    return Ys(a, r);
  }
  const { ProjectivePoint: d, normPrivateKeyToScalar: w, weierstrassEquation: g, isWithinCurveOrder: v } = _y({
    ...t,
    toBytes(a, h, p) {
      const y = h.toAffine(), A = n.toBytes(y.x), B = _n;
      return ln("isCompressed", p), p ? B(Uint8Array.from([h.hasEvenY() ? 2 : 3]), A) : B(Uint8Array.from([4]), A, n.toBytes(y.y));
    },
    fromBytes(a) {
      const h = a.length, p = a[0], y = a.subarray(1);
      if (h === i && (p === 2 || p === 3)) {
        const A = kn(y);
        if (!Si(A, he, n.ORDER))
          throw new Error("Point is not on curve");
        const B = g(A);
        let C;
        try {
          C = n.sqrt(B);
        } catch (E) {
          const Q = E instanceof Error ? ": " + E.message : "";
          throw new Error("Point is not on curve" + Q);
        }
        const b = (C & he) === he;
        return (p & 1) === 1 !== b && (C = n.neg(C)), { x: A, y: C };
      } else if (h === s && p === 4) {
        const A = n.fromBytes(y.subarray(0, n.BYTES)), B = n.fromBytes(y.subarray(n.BYTES, 2 * n.BYTES));
        return { x: A, y: B };
      } else
        throw new Error(`Point of length ${h} was invalid. Expected ${i} compressed bytes or ${s} uncompressed bytes`);
    }
  }), I = (a) => Ln(cr(a, t.nByteLength));
  function S(a) {
    const h = r >> he;
    return a > h;
  }
  function D(a) {
    return S(a) ? o(-a) : a;
  }
  const N = (a, h, p) => kn(a.slice(h, p));
  class T {
    constructor(h, p, y) {
      this.r = h, this.s = p, this.recovery = y, this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(h) {
      const p = t.nByteLength;
      return h = fe("compactSignature", h, p * 2), new T(N(h, 0, p), N(h, p, 2 * p));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(h) {
      const { r: p, s: y } = sn.toSig(fe("DER", h));
      return new T(p, y);
    }
    assertValidity() {
      Oe("r", this.r, he, r), Oe("s", this.s, he, r);
    }
    addRecoveryBit(h) {
      return new T(this.r, this.s, h);
    }
    recoverPublicKey(h) {
      const { r: p, s: y, recovery: A } = this, B = z(fe("msgHash", h));
      if (A == null || ![0, 1, 2, 3].includes(A))
        throw new Error("recovery id invalid");
      const C = A === 2 || A === 3 ? p + t.n : p;
      if (C >= n.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const b = A & 1 ? "03" : "02", l = d.fromHex(b + I(C)), E = u(C), Q = o(-B * E), q = o(y * E), Z = d.BASE.multiplyAndAddUnsafe(l, Q, q);
      if (!Z)
        throw new Error("point at infinify");
      return Z.assertValidity(), Z;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return S(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new T(this.r, o(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return ur(this.toDERHex());
    }
    toDERHex() {
      return sn.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return ur(this.toCompactHex());
    }
    toCompactHex() {
      return I(this.r) + I(this.s);
    }
  }
  const O = {
    isValidPrivateKey(a) {
      try {
        return w(a), !0;
      } catch {
        return !1;
      }
    },
    normPrivateKeyToScalar: w,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const a = pc(t.n);
      return ip(t.randomBytes(a), t.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(a = 8, h = d.BASE) {
      return h._setWindowSize(a), h.multiply(BigInt(3)), h;
    }
  };
  function _(a, h = !0) {
    return d.fromPrivateKey(a).toRawBytes(h);
  }
  function k(a) {
    const h = On(a), p = typeof a == "string", y = (h || p) && a.length;
    return h ? y === i || y === s : p ? y === 2 * i || y === 2 * s : a instanceof d;
  }
  function V(a, h, p = !0) {
    if (k(a))
      throw new Error("first arg must be private key");
    if (!k(h))
      throw new Error("second arg must be public key");
    return d.fromHex(h).multiply(w(a)).toRawBytes(p);
  }
  const H = t.bits2int || function(a) {
    const h = kn(a), p = a.length * 8 - t.nBitLength;
    return p > 0 ? h >> BigInt(p) : h;
  }, z = t.bits2int_modN || function(a) {
    return o(H(a));
  }, j = Mo(t.nBitLength);
  function Y(a) {
    return Oe(`num < 2^${t.nBitLength}`, a, un, j), cr(a, t.nByteLength);
  }
  function J(a, h, p = gt) {
    if (["recovered", "canonical"].some((nt) => nt in p))
      throw new Error("sign() legacy options not supported");
    const { hash: y, randomBytes: A } = t;
    let { lowS: B, prehash: C, extraEntropy: b } = p;
    B == null && (B = !0), a = fe("msgHash", a), La(p), C && (a = fe("prehashed msgHash", y(a)));
    const l = z(a), E = w(h), Q = [Y(E), Y(l)];
    if (b != null && b !== !1) {
      const nt = b === !0 ? A(n.BYTES) : b;
      Q.push(fe("extraEntropy", nt));
    }
    const q = _n(...Q), Z = l;
    function pt(nt) {
      const at = H(nt);
      if (!v(at))
        return;
      const Qt = u(at), yt = d.BASE.multiply(at).toAffine(), ct = o(yt.x);
      if (ct === un)
        return;
      const Kt = o(Qt * o(Z + ct * E));
      if (Kt === un)
        return;
      let At = (yt.x === ct ? 0 : 2) | Number(yt.y & he), It = Kt;
      return B && S(Kt) && (It = D(Kt), At ^= 1), new T(ct, It, At);
    }
    return { seed: q, k2sig: pt };
  }
  const gt = { lowS: t.lowS, prehash: !1 }, $ = { lowS: t.lowS, prehash: !1 };
  function ot(a, h, p = gt) {
    const { seed: y, k2sig: A } = J(a, h, p), B = t;
    return lc(B.hash.outputLen, B.nByteLength, B.hmac)(y, A);
  }
  d.BASE._setWindowSize(8);
  function M(a, h, p, y = $) {
    var yt;
    const A = a;
    if (h = fe("msgHash", h), p = fe("publicKey", p), "strict" in y)
      throw new Error("options.strict was renamed to lowS");
    La(y);
    const { lowS: B, prehash: C } = y;
    let b, l;
    try {
      if (typeof A == "string" || On(A))
        try {
          b = T.fromDER(A);
        } catch (ct) {
          if (!(ct instanceof sn.Err))
            throw ct;
          b = T.fromCompact(A);
        }
      else if (typeof A == "object" && typeof A.r == "bigint" && typeof A.s == "bigint") {
        const { r: ct, s: Kt } = A;
        b = new T(ct, Kt);
      } else
        throw new Error("PARSE");
      l = d.fromHex(p);
    } catch (ct) {
      if (ct.message === "PARSE")
        throw new Error("signature must be Signature instance, Uint8Array or hex string");
      return !1;
    }
    if (B && b.hasHighS())
      return !1;
    C && (h = t.hash(h));
    const { r: E, s: Q } = b, q = z(h), Z = u(Q), pt = o(q * Z), nt = o(E * Z), at = (yt = d.BASE.multiplyAndAddUnsafe(l, pt, nt)) == null ? void 0 : yt.toAffine();
    return at ? o(at.x) === E : !1;
  }
  return {
    CURVE: t,
    getPublicKey: _,
    getSharedSecret: V,
    sign: ot,
    verify: M,
    ProjectivePoint: d,
    Signature: T,
    utils: O
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
function Hy(e) {
  return {
    hash: e,
    hmac: (t, ...n) => nf(e, t, Al(...n)),
    randomBytes: pu
  };
}
function Vy(e, t) {
  const n = (r) => zy({ ...e, ...Hy(r) });
  return Object.freeze({ ...n(t), create: n });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
const rf = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"), Ga = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"), Qy = BigInt(1), Xs = BigInt(2), za = (e, t) => (e + t / Xs) / t;
function Ky(e) {
  const t = rf, n = BigInt(3), r = BigInt(6), i = BigInt(11), s = BigInt(22), o = BigInt(23), u = BigInt(44), d = BigInt(88), w = e * e * e % t, g = w * w * e % t, v = zt(g, n, t) * g % t, I = zt(v, n, t) * g % t, S = zt(I, Xs, t) * w % t, D = zt(S, i, t) * S % t, N = zt(D, s, t) * D % t, T = zt(N, u, t) * N % t, O = zt(T, d, t) * T % t, _ = zt(O, u, t) * N % t, k = zt(_, n, t) * g % t, V = zt(k, o, t) * D % t, H = zt(V, r, t) * w % t, z = zt(H, Xs, t);
  if (!Ws.eql(Ws.sqr(z), e))
    throw new Error("Cannot find square root");
  return z;
}
const Ws = Ui(rf, void 0, void 0, { sqrt: Ky }), Oi = Vy({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Ws,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: Ga,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: !0,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (e) => {
      const t = Ga, n = BigInt("0x3086d221a7d46bcde86c90e49284eb15"), r = -Qy * BigInt("0xe4437ed6010e88286f547fa90abfe4c3"), i = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"), s = n, o = BigInt("0x100000000000000000000000000000000"), u = za(s * e, t), d = za(-r * e, t);
      let w = Dt(e - u * n - d * i, t), g = Dt(-u * r - d * s, t);
      const v = w > o, I = g > o;
      if (v && (w = t - w), I && (g = t - g), w > o || g > o)
        throw new Error("splitScalar: Endomorphism failed, k=" + e);
      return { k1neg: v, k1: w, k2neg: I, k2: g };
    }
  }
}, oi);
BigInt(0);
Oi.ProjectivePoint;
const qy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  secp256k1: Oi
}, Symbol.toStringTag, { value: "Module" }));
wc.utils.randomPrivateKey;
function Ha(e) {
  try {
    return wc.ExtendedPoint.fromHex(e), !0;
  } catch {
    return !1;
  }
}
const jy = (e) => Ot.Buffer.isBuffer(e) ? e : e instanceof Uint8Array ? Ot.Buffer.from(e.buffer, e.byteOffset, e.byteLength) : Ot.Buffer.from(e);
class Yy {
  constructor(t) {
    Object.assign(this, t);
  }
  encode() {
    return Ot.Buffer.from(Ic(ri, this));
  }
  static decode(t) {
    return Mc(ri, this, t);
  }
  static decodeUnchecked(t) {
    return Ac(ri, this, t);
  }
}
const ri = /* @__PURE__ */ new Map();
var sf;
const Zy = 32, Ss = 32;
function Jy(e) {
  return e._bn !== void 0;
}
let Va = 1;
class bt extends Yy {
  /**
   * Create a new PublicKey object
   * @param value ed25519 public key as buffer or base-58 encoded string
   */
  constructor(t) {
    if (super({}), this._bn = void 0, Jy(t))
      this._bn = t._bn;
    else {
      if (typeof t == "string") {
        const n = Pa.decode(t);
        if (n.length != Ss)
          throw new Error("Invalid public key input");
        this._bn = new Ks(n);
      } else
        this._bn = new Ks(t);
      if (this._bn.byteLength() > Ss)
        throw new Error("Invalid public key input");
    }
  }
  /**
   * Returns a unique PublicKey for tests and benchmarks using a counter
   */
  static unique() {
    const t = new bt(Va);
    return Va += 1, new bt(t.toBuffer());
  }
  /**
   * Default public key value. The base58-encoded string representation is all ones (as seen below)
   * The underlying BN number is 32 bytes that are all zeros
   */
  /**
   * Checks if two publicKeys are equal
   */
  equals(t) {
    return this._bn.eq(t._bn);
  }
  /**
   * Return the base-58 representation of the public key
   */
  toBase58() {
    return Pa.encode(this.toBytes());
  }
  toJSON() {
    return this.toBase58();
  }
  /**
   * Return the byte array representation of the public key in big endian
   */
  toBytes() {
    const t = this.toBuffer();
    return new Uint8Array(t.buffer, t.byteOffset, t.byteLength);
  }
  /**
   * Return the Buffer representation of the public key in big endian
   */
  toBuffer() {
    const t = this._bn.toArrayLike(Ot.Buffer);
    if (t.length === Ss)
      return t;
    const n = Ot.Buffer.alloc(32);
    return t.copy(n, 32 - t.length), n;
  }
  get [Symbol.toStringTag]() {
    return `PublicKey(${this.toString()})`;
  }
  /**
   * Return the base-58 representation of the public key
   */
  toString() {
    return this.toBase58();
  }
  /**
   * Derive a public key from another key, a seed, and a program ID.
   * The program ID will also serve as the owner of the public key, giving
   * it permission to write data to the account.
   */
  /* eslint-disable require-await */
  static async createWithSeed(t, n, r) {
    const i = Ot.Buffer.concat([t.toBuffer(), Ot.Buffer.from(n), r.toBuffer()]), s = oi(i);
    return new bt(s);
  }
  /**
   * Derive a program address from seeds and a program ID.
   */
  /* eslint-disable require-await */
  static createProgramAddressSync(t, n) {
    let r = Ot.Buffer.alloc(0);
    t.forEach(function(s) {
      if (s.length > Zy)
        throw new TypeError("Max seed length exceeded");
      r = Ot.Buffer.concat([r, jy(s)]);
    }), r = Ot.Buffer.concat([r, n.toBuffer(), Ot.Buffer.from("ProgramDerivedAddress")]);
    const i = oi(r);
    if (Ha(i))
      throw new Error("Invalid seeds, address must fall off the curve");
    return new bt(i);
  }
  /**
   * Async version of createProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link createProgramAddressSync} instead
   */
  /* eslint-disable require-await */
  static async createProgramAddress(t, n) {
    return this.createProgramAddressSync(t, n);
  }
  /**
   * Find a valid program address
   *
   * Valid program addresses must fall off the ed25519 curve.  This function
   * iterates a nonce until it finds one that when combined with the seeds
   * results in a valid program address.
   */
  static findProgramAddressSync(t, n) {
    let r = 255, i;
    for (; r != 0; ) {
      try {
        const s = t.concat(Ot.Buffer.from([r]));
        i = this.createProgramAddressSync(s, n);
      } catch (s) {
        if (s instanceof TypeError)
          throw s;
        r--;
        continue;
      }
      return [i, r];
    }
    throw new Error("Unable to find a viable program address nonce");
  }
  /**
   * Async version of findProgramAddressSync
   * For backwards compatibility
   *
   * @deprecated Use {@link findProgramAddressSync} instead
   */
  static async findProgramAddress(t, n) {
    return this.findProgramAddressSync(t, n);
  }
  /**
   * Check that a pubkey is on the ed25519 curve.
   */
  static isOnCurve(t) {
    const n = new bt(t);
    return Ha(n.toBytes());
  }
}
sf = bt;
bt.default = new sf("11111111111111111111111111111111");
ri.set(bt, {
  kind: "struct",
  fields: [["_bn", "u256"]]
});
new bt("BPFLoader1111111111111111111111111111111111");
const Xy = 64, Et = (e = "publicKey") => lr(32, e), er = (e = "string") => {
  const t = et([tt("length"), tt("lengthPadding"), lr(Nn(tt(), -8), "chars")], e), n = t.decode.bind(t), r = t.encode.bind(t), i = t;
  return i.decode = (s, o) => n(s, o).chars.toString(), i.encode = (s, o, u) => {
    const d = {
      chars: Ot.Buffer.from(s, "utf8")
    };
    return r(d, o, u);
  }, i.alloc = (s) => tt().span + tt().span + Ot.Buffer.from(s, "utf8").length, i;
}, Wy = (e = "authorized") => et([Et("staker"), Et("withdrawer")], e), $y = (e = "lockup") => et([Fe("unixTimestamp"), Fe("epoch"), Et("custodian")], e), t1 = (e = "voteInit") => et([Et("nodePubkey"), Et("authorizedVoter"), Et("authorizedWithdrawer"), ce("commission")], e), e1 = (e = "voteAuthorizeWithSeedArgs") => et([tt("voteAuthorizationType"), Et("currentAuthorityDerivedKeyOwnerPubkey"), er("currentAuthorityDerivedKeySeed"), Et("newAuthorized")], e);
Ot.Buffer.alloc(Xy).fill(0);
new bt("SysvarC1ock11111111111111111111111111111111");
new bt("SysvarEpochSchedu1e111111111111111111111111");
new bt("Sysvar1nstructions1111111111111111111111111");
new bt("SysvarRecentB1ockHashes11111111111111111111");
new bt("SysvarRent111111111111111111111111111111111");
new bt("SysvarRewards111111111111111111111111111111");
new bt("SysvarS1otHashes111111111111111111111111111");
new bt("SysvarS1otHistory11111111111111111111111111");
new bt("SysvarStakeHistory1111111111111111111111111");
const n1 = me("lamportsPerSignature"), r1 = et([tt("version"), tt("state"), Et("authorizedPubkey"), Et("nonce"), et([n1], "feeCalculator")]);
r1.span;
const i1 = (e) => {
  const t = e.decode.bind(e), n = e.encode.bind(e);
  return {
    decode: t,
    encode: n
  };
}, s1 = (e) => (t) => {
  const n = lr(e, t), {
    encode: r,
    decode: i
  } = i1(n), s = n;
  return s.decode = (o, u) => {
    const d = i(o, u);
    return Hp(Ot.Buffer.from(d));
  }, s.encode = (o, u, d) => {
    const w = Kp(o, e);
    return r(w, u, d);
  }, s;
}, dr = s1(8);
Object.freeze({
  Create: {
    index: 0,
    layout: et([tt("instruction"), Fe("lamports"), Fe("space"), Et("programId")])
  },
  Assign: {
    index: 1,
    layout: et([tt("instruction"), Et("programId")])
  },
  Transfer: {
    index: 2,
    layout: et([tt("instruction"), dr("lamports")])
  },
  CreateWithSeed: {
    index: 3,
    layout: et([tt("instruction"), Et("base"), er("seed"), Fe("lamports"), Fe("space"), Et("programId")])
  },
  AdvanceNonceAccount: {
    index: 4,
    layout: et([tt("instruction")])
  },
  WithdrawNonceAccount: {
    index: 5,
    layout: et([tt("instruction"), Fe("lamports")])
  },
  InitializeNonceAccount: {
    index: 6,
    layout: et([tt("instruction"), Et("authorized")])
  },
  AuthorizeNonceAccount: {
    index: 7,
    layout: et([tt("instruction"), Et("authorized")])
  },
  Allocate: {
    index: 8,
    layout: et([tt("instruction"), Fe("space")])
  },
  AllocateWithSeed: {
    index: 9,
    layout: et([tt("instruction"), Et("base"), er("seed"), Fe("space"), Et("programId")])
  },
  AssignWithSeed: {
    index: 10,
    layout: et([tt("instruction"), Et("base"), er("seed"), Et("programId")])
  },
  TransferWithSeed: {
    index: 11,
    layout: et([tt("instruction"), dr("lamports"), er("seed"), Et("programId")])
  },
  UpgradeNonceAccount: {
    index: 12,
    layout: et([tt("instruction")])
  }
});
new bt("11111111111111111111111111111111");
new bt("BPFLoader2111111111111111111111111111111111");
et([
  tt("typeIndex"),
  dr("deactivationSlot"),
  me("lastExtendedSlot"),
  ce("lastExtendedStartIndex"),
  ce(),
  // option
  Fn(Et(), Nn(ce(), -1), "authority")
]);
const le = qr(_o(bt), K(), (e) => new bt(e)), of = Go([K(), _t("base64")]), zo = qr(_o(Ot.Buffer), of, (e) => Ot.Buffer.from(e[0], "base64"));
function af(e) {
  return Ue([G({
    jsonrpc: _t("2.0"),
    id: K(),
    result: e
  }), G({
    jsonrpc: _t("2.0"),
    id: K(),
    error: G({
      code: Kr(),
      message: K(),
      data: rt($p())
    })
  })]);
}
const o1 = af(Kr());
function Ft(e) {
  return qr(af(e), o1, (t) => "error" in t ? t : {
    ...t,
    result: Lr(t.result, e)
  });
}
function _e(e) {
  return Ft(G({
    context: G({
      slot: R()
    }),
    value: e
  }));
}
function Li(e) {
  return G({
    context: G({
      slot: R()
    }),
    value: e
  });
}
const a1 = G({
  foundation: R(),
  foundationTerm: R(),
  initial: R(),
  taper: R(),
  terminal: R()
});
Ft(W(X(G({
  epoch: R(),
  effectiveSlot: R(),
  amount: R(),
  postBalance: R(),
  commission: rt(X(R()))
}))));
const u1 = W(G({
  slot: R(),
  prioritizationFee: R()
})), c1 = G({
  total: R(),
  validator: R(),
  foundation: R(),
  epoch: R()
}), f1 = G({
  epoch: R(),
  slotIndex: R(),
  slotsInEpoch: R(),
  absoluteSlot: R(),
  blockHeight: rt(R()),
  transactionCount: rt(R())
}), l1 = G({
  slotsPerEpoch: R(),
  leaderScheduleSlotOffset: R(),
  warmup: Xe(),
  firstNormalEpoch: R(),
  firstNormalSlot: R()
}), h1 = Kc(K(), W(R())), Hn = X(Ue([G({}), K()])), d1 = G({
  err: Hn
}), p1 = _t("receivedSignature");
G({
  "solana-core": K(),
  "feature-set": rt(R())
});
_e(G({
  err: X(Ue([G({}), K()])),
  logs: X(W(K())),
  accounts: rt(X(W(X(G({
    executable: Xe(),
    owner: K(),
    lamports: R(),
    data: W(K()),
    rentEpoch: rt(R())
  }))))),
  unitsConsumed: rt(R()),
  returnData: rt(X(G({
    programId: K(),
    data: Go([K(), _t("base64")])
  })))
}));
_e(G({
  byIdentity: Kc(K(), W(R())),
  range: G({
    firstSlot: R(),
    lastSlot: R()
  })
}));
Ft(a1);
Ft(c1);
Ft(u1);
Ft(f1);
Ft(l1);
Ft(h1);
Ft(R());
_e(G({
  total: R(),
  circulating: R(),
  nonCirculating: R(),
  nonCirculatingAccounts: W(le)
}));
const y1 = G({
  amount: K(),
  uiAmount: X(R()),
  decimals: R(),
  uiAmountString: rt(K())
});
_e(W(G({
  address: le,
  amount: K(),
  uiAmount: X(R()),
  decimals: R(),
  uiAmountString: rt(K())
})));
_e(W(G({
  pubkey: le,
  account: G({
    executable: Xe(),
    owner: le,
    lamports: R(),
    data: zo,
    rentEpoch: R()
  })
})));
const $s = G({
  program: K(),
  parsed: Kr(),
  space: R()
});
_e(W(G({
  pubkey: le,
  account: G({
    executable: Xe(),
    owner: le,
    lamports: R(),
    data: $s,
    rentEpoch: R()
  })
})));
_e(W(G({
  lamports: R(),
  address: le
})));
const Ho = G({
  executable: Xe(),
  owner: le,
  lamports: R(),
  data: zo,
  rentEpoch: R()
});
G({
  pubkey: le,
  account: Ho
});
const m1 = qr(Ue([_o(Ot.Buffer), $s]), Ue([of, $s]), (e) => Array.isArray(e) ? Lr(e, zo) : e), w1 = G({
  executable: Xe(),
  owner: le,
  lamports: R(),
  data: m1,
  rentEpoch: R()
});
G({
  pubkey: le,
  account: w1
});
G({
  state: Ue([_t("active"), _t("inactive"), _t("activating"), _t("deactivating")]),
  active: R(),
  inactive: R()
});
Ft(W(G({
  signature: K(),
  slot: R(),
  err: Hn,
  memo: X(K()),
  blockTime: rt(X(R()))
})));
Ft(W(G({
  signature: K(),
  slot: R(),
  err: Hn,
  memo: X(K()),
  blockTime: rt(X(R()))
})));
G({
  subscription: R(),
  result: Li(Ho)
});
const g1 = G({
  pubkey: le,
  account: Ho
});
G({
  subscription: R(),
  result: Li(g1)
});
const b1 = G({
  parent: R(),
  slot: R(),
  root: R()
});
G({
  subscription: R(),
  result: b1
});
const A1 = Ue([G({
  type: Ue([_t("firstShredReceived"), _t("completed"), _t("optimisticConfirmation"), _t("root")]),
  slot: R(),
  timestamp: R()
}), G({
  type: _t("createdBank"),
  parent: R(),
  slot: R(),
  timestamp: R()
}), G({
  type: _t("frozen"),
  slot: R(),
  timestamp: R(),
  stats: G({
    numTransactionEntries: R(),
    numSuccessfulTransactions: R(),
    numFailedTransactions: R(),
    maxTransactionsPerEntry: R()
  })
}), G({
  type: _t("dead"),
  slot: R(),
  timestamp: R(),
  err: K()
})]);
G({
  subscription: R(),
  result: A1
});
G({
  subscription: R(),
  result: Li(Ue([d1, p1]))
});
G({
  subscription: R(),
  result: R()
});
G({
  pubkey: K(),
  gossip: X(K()),
  tpu: X(K()),
  rpc: X(K()),
  version: X(K())
});
const Qa = G({
  votePubkey: K(),
  nodePubkey: K(),
  activatedStake: R(),
  epochVoteAccount: Xe(),
  epochCredits: W(Go([R(), R(), R()])),
  commission: R(),
  lastVote: R(),
  rootSlot: X(R())
});
Ft(G({
  current: W(Qa),
  delinquent: W(Qa)
}));
const x1 = Ue([_t("processed"), _t("confirmed"), _t("finalized")]), E1 = G({
  slot: R(),
  confirmations: X(R()),
  err: Hn,
  confirmationStatus: rt(x1)
});
_e(W(X(E1)));
Ft(R());
const uf = G({
  accountKey: le,
  writableIndexes: W(R()),
  readonlyIndexes: W(R())
}), Vo = G({
  signatures: W(K()),
  message: G({
    accountKeys: W(K()),
    header: G({
      numRequiredSignatures: R(),
      numReadonlySignedAccounts: R(),
      numReadonlyUnsignedAccounts: R()
    }),
    instructions: W(G({
      accounts: W(R()),
      data: K(),
      programIdIndex: R()
    })),
    recentBlockhash: K(),
    addressTableLookups: rt(W(uf))
  })
}), cf = G({
  pubkey: le,
  signer: Xe(),
  writable: Xe(),
  source: rt(Ue([_t("transaction"), _t("lookupTable")]))
}), ff = G({
  accountKeys: W(cf),
  signatures: W(K())
}), lf = G({
  parsed: Kr(),
  program: K(),
  programId: le
}), hf = G({
  accounts: W(le),
  data: K(),
  programId: le
}), v1 = Ue([hf, lf]), B1 = Ue([G({
  parsed: Kr(),
  program: K(),
  programId: K()
}), G({
  accounts: W(K()),
  data: K(),
  programId: K()
})]), df = qr(v1, B1, (e) => "accounts" in e ? Lr(e, hf) : Lr(e, lf)), pf = G({
  signatures: W(K()),
  message: G({
    accountKeys: W(cf),
    instructions: W(df),
    recentBlockhash: K(),
    addressTableLookups: rt(X(W(uf)))
  })
}), Ai = G({
  accountIndex: R(),
  mint: K(),
  owner: rt(K()),
  uiTokenAmount: y1
}), yf = G({
  writable: W(le),
  readonly: W(le)
}), _i = G({
  err: Hn,
  fee: R(),
  innerInstructions: rt(X(W(G({
    index: R(),
    instructions: W(G({
      accounts: W(R()),
      data: K(),
      programIdIndex: R()
    }))
  })))),
  preBalances: W(R()),
  postBalances: W(R()),
  logMessages: rt(X(W(K()))),
  preTokenBalances: rt(X(W(Ai))),
  postTokenBalances: rt(X(W(Ai))),
  loadedAddresses: rt(yf),
  computeUnitsConsumed: rt(R())
}), Qo = G({
  err: Hn,
  fee: R(),
  innerInstructions: rt(X(W(G({
    index: R(),
    instructions: W(df)
  })))),
  preBalances: W(R()),
  postBalances: W(R()),
  logMessages: rt(X(W(K()))),
  preTokenBalances: rt(X(W(Ai))),
  postTokenBalances: rt(X(W(Ai))),
  loadedAddresses: rt(yf),
  computeUnitsConsumed: rt(R())
}), Ar = Ue([_t(0), _t("legacy")]), Vn = G({
  pubkey: K(),
  lamports: R(),
  postBalance: X(R()),
  rewardType: X(K()),
  commission: rt(X(R()))
});
Ft(X(G({
  blockhash: K(),
  previousBlockhash: K(),
  parentSlot: R(),
  transactions: W(G({
    transaction: Vo,
    meta: X(_i),
    version: rt(Ar)
  })),
  rewards: rt(W(Vn)),
  blockTime: X(R()),
  blockHeight: X(R())
})));
Ft(X(G({
  blockhash: K(),
  previousBlockhash: K(),
  parentSlot: R(),
  rewards: rt(W(Vn)),
  blockTime: X(R()),
  blockHeight: X(R())
})));
Ft(X(G({
  blockhash: K(),
  previousBlockhash: K(),
  parentSlot: R(),
  transactions: W(G({
    transaction: ff,
    meta: X(_i),
    version: rt(Ar)
  })),
  rewards: rt(W(Vn)),
  blockTime: X(R()),
  blockHeight: X(R())
})));
Ft(X(G({
  blockhash: K(),
  previousBlockhash: K(),
  parentSlot: R(),
  transactions: W(G({
    transaction: pf,
    meta: X(Qo),
    version: rt(Ar)
  })),
  rewards: rt(W(Vn)),
  blockTime: X(R()),
  blockHeight: X(R())
})));
Ft(X(G({
  blockhash: K(),
  previousBlockhash: K(),
  parentSlot: R(),
  transactions: W(G({
    transaction: ff,
    meta: X(Qo),
    version: rt(Ar)
  })),
  rewards: rt(W(Vn)),
  blockTime: X(R()),
  blockHeight: X(R())
})));
Ft(X(G({
  blockhash: K(),
  previousBlockhash: K(),
  parentSlot: R(),
  rewards: rt(W(Vn)),
  blockTime: X(R()),
  blockHeight: X(R())
})));
Ft(X(G({
  blockhash: K(),
  previousBlockhash: K(),
  parentSlot: R(),
  transactions: W(G({
    transaction: Vo,
    meta: X(_i)
  })),
  rewards: rt(W(Vn)),
  blockTime: X(R())
})));
Ft(X(G({
  blockhash: K(),
  previousBlockhash: K(),
  parentSlot: R(),
  signatures: W(K()),
  blockTime: X(R())
})));
Ft(X(G({
  slot: R(),
  meta: X(_i),
  blockTime: rt(X(R())),
  transaction: Vo,
  version: rt(Ar)
})));
Ft(X(G({
  slot: R(),
  transaction: pf,
  meta: X(Qo),
  blockTime: rt(X(R())),
  version: rt(Ar)
})));
_e(G({
  blockhash: K(),
  feeCalculator: G({
    lamportsPerSignature: R()
  })
}));
_e(G({
  blockhash: K(),
  lastValidBlockHeight: R()
}));
_e(Xe());
const I1 = G({
  slot: R(),
  numTransactions: R(),
  numSlots: R(),
  samplePeriodSecs: R()
});
Ft(W(I1));
_e(X(G({
  feeCalculator: G({
    lamportsPerSignature: R()
  })
})));
Ft(K());
Ft(K());
const M1 = G({
  err: Hn,
  logs: W(K()),
  signature: K()
});
G({
  result: Li(M1),
  subscription: R()
});
Object.freeze({
  CreateLookupTable: {
    index: 0,
    layout: et([tt("instruction"), dr("recentSlot"), ce("bumpSeed")])
  },
  FreezeLookupTable: {
    index: 1,
    layout: et([tt("instruction")])
  },
  ExtendLookupTable: {
    index: 2,
    layout: et([tt("instruction"), dr(), Fn(Et(), Nn(tt(), -8), "addresses")])
  },
  DeactivateLookupTable: {
    index: 3,
    layout: et([tt("instruction")])
  },
  CloseLookupTable: {
    index: 4,
    layout: et([tt("instruction")])
  }
});
new bt("AddressLookupTab1e1111111111111111111111111");
Object.freeze({
  RequestUnits: {
    index: 0,
    layout: et([ce("instruction"), tt("units"), tt("additionalFee")])
  },
  RequestHeapFrame: {
    index: 1,
    layout: et([ce("instruction"), tt("bytes")])
  },
  SetComputeUnitLimit: {
    index: 2,
    layout: et([ce("instruction"), tt("units")])
  },
  SetComputeUnitPrice: {
    index: 3,
    layout: et([ce("instruction"), dr("microLamports")])
  }
});
new bt("ComputeBudget111111111111111111111111111111");
et([ce("numSignatures"), ce("padding"), Pe("signatureOffset"), Pe("signatureInstructionIndex"), Pe("publicKeyOffset"), Pe("publicKeyInstructionIndex"), Pe("messageDataOffset"), Pe("messageDataSize"), Pe("messageInstructionIndex")]);
new bt("Ed25519SigVerify111111111111111111111111111");
Oi.utils.isValidPrivateKey;
Oi.getPublicKey;
et([ce("numSignatures"), Pe("signatureOffset"), ce("signatureInstructionIndex"), Pe("ethAddressOffset"), ce("ethAddressInstructionIndex"), Pe("messageDataOffset"), Pe("messageDataSize"), ce("messageInstructionIndex"), lr(20, "ethAddress"), lr(64, "signature"), ce("recoveryId")]);
new bt("KeccakSecp256k11111111111111111111111111111");
var mf;
new bt("StakeConfig11111111111111111111111111111111");
class wf {
  /**
   * Create a new Lockup object
   */
  constructor(t, n, r) {
    this.unixTimestamp = void 0, this.epoch = void 0, this.custodian = void 0, this.unixTimestamp = t, this.epoch = n, this.custodian = r;
  }
  /**
   * Default, inactive Lockup value
   */
}
mf = wf;
wf.default = new mf(0, 0, bt.default);
Object.freeze({
  Initialize: {
    index: 0,
    layout: et([tt("instruction"), Wy(), $y()])
  },
  Authorize: {
    index: 1,
    layout: et([tt("instruction"), Et("newAuthorized"), tt("stakeAuthorizationType")])
  },
  Delegate: {
    index: 2,
    layout: et([tt("instruction")])
  },
  Split: {
    index: 3,
    layout: et([tt("instruction"), Fe("lamports")])
  },
  Withdraw: {
    index: 4,
    layout: et([tt("instruction"), Fe("lamports")])
  },
  Deactivate: {
    index: 5,
    layout: et([tt("instruction")])
  },
  Merge: {
    index: 7,
    layout: et([tt("instruction")])
  },
  AuthorizeWithSeed: {
    index: 8,
    layout: et([tt("instruction"), Et("newAuthorized"), tt("stakeAuthorizationType"), er("authoritySeed"), Et("authorityOwner")])
  }
});
new bt("Stake11111111111111111111111111111111111111");
Object.freeze({
  InitializeAccount: {
    index: 0,
    layout: et([tt("instruction"), t1()])
  },
  Authorize: {
    index: 1,
    layout: et([tt("instruction"), Et("newAuthorized"), tt("voteAuthorizationType")])
  },
  Withdraw: {
    index: 3,
    layout: et([tt("instruction"), Fe("lamports")])
  },
  UpdateValidatorIdentity: {
    index: 4,
    layout: et([tt("instruction")])
  },
  AuthorizeWithSeed: {
    index: 10,
    layout: et([tt("instruction"), e1()])
  }
});
new bt("Vote111111111111111111111111111111111111111");
new bt("Va1idator1nfo111111111111111111111111111111");
G({
  name: K(),
  website: rt(K()),
  details: rt(K()),
  keybaseUsername: rt(K())
});
new bt("Vote111111111111111111111111111111111111111");
et([
  Et("nodePubkey"),
  Et("authorizedWithdrawer"),
  ce("commission"),
  me(),
  // votes.length
  Fn(et([me("slot"), tt("confirmationCount")]), Nn(tt(), -8), "votes"),
  ce("rootSlotValid"),
  me("rootSlot"),
  me(),
  // authorizedVoters.length
  Fn(et([me("epoch"), Et("authorizedVoter")]), Nn(tt(), -8), "authorizedVoters"),
  et([Fn(et([Et("authorizedPubkey"), me("epochOfLastAuthorizedSwitch"), me("targetEpoch")]), 32, "buf"), me("idx"), ce("isEmpty")], "priorVoters"),
  me(),
  // epochCredits.length
  Fn(et([me("epoch"), me("credits"), me("prevCredits")]), Nn(tt(), -8), "epochCredits"),
  et([me("slot"), me("timestamp")], "lastTimestamp")
]);
const T1 = "strings/5.7.0", C1 = new vt(T1);
var xi;
(function(e) {
  e.current = "", e.NFC = "NFC", e.NFD = "NFD", e.NFKC = "NFKC", e.NFKD = "NFKD";
})(xi || (xi = {}));
var Ka;
(function(e) {
  e.UNEXPECTED_CONTINUE = "unexpected continuation byte", e.BAD_PREFIX = "bad codepoint prefix", e.OVERRUN = "string overrun", e.MISSING_CONTINUE = "missing continuation byte", e.OUT_OF_RANGE = "out of UTF-8 range", e.UTF16_SURROGATE = "UTF-16 surrogate", e.OVERLONG = "overlong representation";
})(Ka || (Ka = {}));
function S1(e, t = xi.current) {
  t != xi.current && (C1.checkNormalize(), e = e.normalize(t));
  let n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e.charCodeAt(r);
    if (i < 128)
      n.push(i);
    else if (i < 2048)
      n.push(i >> 6 | 192), n.push(i & 63 | 128);
    else if ((i & 64512) == 55296) {
      r++;
      const s = e.charCodeAt(r);
      if (r >= e.length || (s & 64512) !== 56320)
        throw new Error("invalid utf-8 string");
      const o = 65536 + ((i & 1023) << 10) + (s & 1023);
      n.push(o >> 18 | 240), n.push(o >> 12 & 63 | 128), n.push(o >> 6 & 63 | 128), n.push(o & 63 | 128);
    } else
      n.push(i >> 12 | 224), n.push(i >> 6 & 63 | 128), n.push(i & 63 | 128);
  }
  return je(n);
}
const U1 = "solidity/5.7.0", F1 = new RegExp("^bytes([0-9]+)$"), k1 = new RegExp("^(u?int)([0-9]*)$"), N1 = new RegExp("^(.*)\\[([0-9]*)\\]$"), R1 = "0000000000000000000000000000000000000000000000000000000000000000", Wn = new vt(U1);
function gf(e, t, n) {
  switch (e) {
    case "address":
      return n ? ps(t, 32) : je(t);
    case "string":
      return S1(t);
    case "bytes":
      return je(t);
    case "bool":
      return t = t ? "0x01" : "0x00", n ? ps(t, 32) : je(t);
  }
  let r = e.match(k1);
  if (r) {
    let i = parseInt(r[2] || "256");
    return (r[2] && String(i) !== r[2] || i % 8 !== 0 || i === 0 || i > 256) && Wn.throwArgumentError("invalid number type", "type", e), n && (i = 256), t = mt.from(t).toTwos(i), ps(t, i / 8);
  }
  if (r = e.match(F1), r) {
    const i = parseInt(r[1]);
    return (String(i) !== r[1] || i === 0 || i > 32) && Wn.throwArgumentError("invalid bytes type", "type", e), je(t).byteLength !== i && Wn.throwArgumentError(`invalid value for ${e}`, "value", t), n ? je((t + R1).substring(0, 66)) : t;
  }
  if (r = e.match(N1), r && Array.isArray(t)) {
    const i = r[1];
    parseInt(r[2] || String(t.length)) != t.length && Wn.throwArgumentError(`invalid array length for ${e}`, "value", t);
    const o = [];
    return t.forEach(function(u) {
      o.push(gf(i, u, !0));
    }), oc(o);
  }
  return Wn.throwArgumentError("invalid type", "type", e);
}
function wn(e, t) {
  e.length != t.length && Wn.throwArgumentError("wrong number of values; expected ${ types.length }", "values", t);
  const n = [];
  return e.forEach(function(r, i) {
    n.push(gf(r, t[i]));
  }), Un(oc(n));
}
var P1 = process.env.NODE_ENV === "production", Us = "Invariant failed";
function Ir(e, t) {
  if (!e) {
    if (P1)
      throw new Error(Us);
    var n = typeof t == "function" ? t() : t, r = n ? "".concat(Us, ": ").concat(n) : Us;
    throw new Error(r);
  }
}
function D1(e) {
  return Ed(e, 32);
}
function Bn(e) {
  return e.replace(/^0x/, "");
}
var Mr = mt.from("0xffffffffffffffffffffffffffffffff"), O1 = class to {
  // dissuade public instantiation
  constructor() {
    Tt(this, "workerOptions", []);
  }
  /**
   * Create a new options instance.
   */
  static newOptions() {
    return new to();
  }
  /**
   * Create an options instance from a hex string.
   * @param {string} optionsHex The hex string to decode.
   */
  static fromOptions(t) {
    const n = new to(), r = je(t), i = mt.from(r.slice(0, 2)).toNumber();
    if (i === 3) {
      let s = 2;
      for (; s < r.byteLength; ) {
        const o = mt.from(r.slice(s, s + 1)).toNumber();
        s += 1;
        const u = mt.from(r.slice(s, s + 2)).toNumber();
        if (s += 2, o === 1) {
          const d = mt.from(r.slice(s, s + 1)).toNumber();
          s += 1;
          const w = r.slice(s, s + u - 1);
          s += u - 1, n.addOption(o, { type: d, params: Un(w) });
        } else if (o === 2) {
          const d = mt.from(r.slice(s, s + 1)).toNumber();
          s += 1;
          const w = mt.from(r.slice(s, s + 1)).toNumber();
          s += 1;
          const g = r.slice(s, s + u - 2);
          s += u - 2, n.addOption(o, {
            type: w,
            index: d,
            params: Un(g)
          });
        }
      }
    } else if (i === 2) {
      const s = mt.from(r.slice(2, 34)).toBigInt(), o = mt.from(r.slice(34, 66)).toBigInt(), u = Un(r.slice(66, r.byteLength));
      n.addExecutorLzReceiveOption(s).addExecutorNativeDropOption(o, u);
    } else if (i === 1) {
      const s = mt.from(r.slice(2, 34)).toBigInt();
      n.addExecutorLzReceiveOption(s);
    }
    return n;
  }
  /**
   * Add ExecutorOptionType.LZ_RECEIVE option.
   * @param {GasLimit} gasLimit
   * @param {NativeDrop} nativeDrop
   */
  addExecutorLzReceiveOption(t, n = 0) {
    const r = mt.from(t);
    Ir(r.lte(Mr), "gasLimit shouldn't be greater than MAX_UINT_128");
    const i = mt.from(n);
    return Ir(i.lte(Mr), "value shouldn't be greater than MAX_UINT_128"), this.addOption(1, {
      type: 1,
      params: i.eq(0) ? wn(["uint128"], [r]) : wn(["uint128", "uint128"], [r, i])
    }), this;
  }
  /**
   * Add ExecutorOptionType.NATIVE_DROP option.
   * @param {NativeDrop} nativeDrop
   * @param {string} receiver
   */
  addExecutorNativeDropOption(t, n) {
    const r = mt.from(t);
    return Ir(r.lte(Mr), "nativeDrop shouldn't be greater than MAX_UINT_128"), this.addOption(1, {
      type: 2,
      params: wn(["uint128", "bytes32"], [r, D1(n)])
    }), this;
  }
  /**
   * Add ExecutorOptionType.COMPOSE option.
   * @param {number} index
   * @param {GasLimit} gasLimit
   * @param {NativeDrop} nativeDrop
   */
  addExecutorComposeOption(t, n, r = 0) {
    const i = mt.from(n);
    Ir(i.lte(Mr), "gasLimit shouldn't be greater than MAX_UINT_128");
    const s = mt.from(r);
    Ir(s.lte(Mr), "nativeDrop shouldn't be greater than MAX_UINT_128");
    const o = s.gt(0) ? {
      type: 3,
      params: wn(["uint16", "uint128", "uint128"], [t, i, s])
    } : {
      type: 3,
      params: wn(["uint16", "uint128"], [t, i])
    };
    return this.addOption(1, o), this;
  }
  /**
   * Add ExecutorOptionType.ORDERED option.
   */
  addExecutorOrderedExecutionOption() {
    return this.addOption(1, {
      type: 4,
      params: "0x"
    }), this;
  }
  /**
   * Add VerifierOptionType.PRECRIME option.
   * @param {number} verifierIdx
   */
  addVerifierPrecrimeOption(t) {
    return this.addOption(2, {
      type: 1,
      index: t,
      params: "0x"
    }), this;
  }
  /**
   * Serialize Options to hex string.
   */
  toHex() {
    let t = wn(["uint16"], [
      3
      /* TYPE_3 */
    ]);
    return this.workerOptions.forEach((n) => {
      for (const r of n.options)
        if (n.workerId === 1)
          t += Bn(
            wn(
              ["uint8", "uint16", "uint8", "bytes"],
              [n.workerId, Bn(r.params).length / 2 + 1, r.type, r.params]
            )
          );
        else if (n.workerId === 2) {
          const i = r;
          t += Bn(
            wn(
              ["uint8", "uint16", "uint8", "uint8", "bytes"],
              [
                n.workerId,
                Bn(r.params).length / 2 + 2,
                i.index,
                i.type,
                i.params
              ]
            )
          );
        }
    }), t;
  }
  /**
   * Serialize Options to Uint8Array.
   */
  toBytes() {
    return je(this.toHex());
  }
  addOption(t, n) {
    const r = this.workerOptions.find((i) => i.workerId === t);
    r ? r.options.push(n) : this.workerOptions.push({ workerId: t, options: [n] });
  }
  /**
   * Decode ExecutorOptionType.LZ_RECEIVE option.  Returns undefined if the option is not present.
   */
  decodeExecutorLzReceiveOption() {
    const t = this.findOptions(
      1,
      1
      /* LZ_RECEIVE */
    );
    if (!t || t.length === 0)
      return;
    let n = mt.from(0).toBigInt(), r = mt.from(0).toBigInt();
    for (const i of t) {
      const s = Buffer.from(Bn(i.params), "hex"), o = mt.from(s.subarray(0, 16)).toBigInt(), u = mt.from(s.length === 16 ? 0 : s.subarray(16, 32)).toBigInt();
      n = n + o, r = r + u;
    }
    return { gas: n, value: r };
  }
  /**
   * Decode ExecutorOptionType.NATIVE_DROP options.  Returns undefined if the options is not present.
   */
  decodeExecutorNativeDropOption() {
    const t = this.findOptions(
      1,
      2
      /* NATIVE_DROP */
    );
    if (!t || t.length === 0)
      return [];
    const n = t.reduce((r, i) => {
      const s = Buffer.from(Bn(i.params), "hex"), o = mt.from(s.subarray(0, 16)).toBigInt(), u = Un(s.subarray(16, 48));
      return r[u] ? r[u].amount = r[u].amount + o : r[u] = { amount: o, receiver: u }, r;
    }, {});
    return Object.values(n);
  }
  /**
   * Decode ExecutorOptionType.COMPOSE options.  Returns undefined if the options is not present.
   */
  decodeExecutorComposeOption() {
    const t = this.findOptions(
      1,
      3
      /* COMPOSE */
    );
    if (!t || t.length === 0)
      return [];
    const n = t.reduce(
      (r, i) => {
        const s = Buffer.from(Bn(i.params), "hex"), o = mt.from(s.subarray(0, 2)).toNumber(), u = mt.from(s.subarray(2, 18)).toBigInt(), d = (s.length === 34 ? mt.from(s.subarray(18, 34)) : mt.from(0)).toBigInt();
        return r[o] ? (r[o].gas = r[o].gas + u, r[o].value = r[o].value + d) : r[o] = { index: o, gas: u, value: d }, r;
      },
      {}
    );
    return Object.values(n);
  }
  /**
   * Decode ExecutorOptionType.ORDERED options.  Returns undefined if the options is not present.
   */
  decodeExecutorOrderedExecutionOption() {
    return this.findOptions(
      1,
      4
      /* ORDERED */
    ) !== void 0;
  }
  findOptions(t, n) {
    const r = this.workerOptions.find((i) => i.workerId === t);
    if (r)
      return n === 4 ? r.options.find((i) => i.type === n) : r.options.filter((i) => i.type === n);
  }
  /**
   * Find VerifierOption by verifierIdx and optionType.  Returns undefined if the option is not present.
   * @param {number} verifierIdx
   * @param {number} optionType
   */
  findVerifierOption(t, n) {
    const r = this.workerOptions.find(
      (i) => i.workerId === 2
      /* VERIFIER */
    );
    if (r) {
      const i = r.options.find((s) => s.type === n && s.index === t);
      if (i)
        return i;
    }
  }
};
async function L1(e) {
  const {
    originChainId: t,
    destinationChainId: n,
    to: r,
    value: i,
    data: s,
    account: o,
    publicClient: u
  } = e, d = vf([
    "function quote(uint32 eid, address sender, bytes calldata payload, bytes calldata options) external view returns (uint256 nativeFee, uint256 lzTokenFee)",
    "function execute(uint32 eid, bytes calldata payload, bytes calldata options) external payable"
  ]), w = x0[t], g = B0[n], v = De({
    abi: Ht.IMPLEMENTATION.ABI,
    functionName: "execute",
    args: [r, i, s, 0]
  }), S = O1.newOptions().addExecutorLzReceiveOption(2e5, 0).toHex(), N = (await u.readContract({
    address: w,
    abi: d,
    functionName: "quote",
    args: [g, o, v, S]
  })).at(0) || 0n, T = De({
    abi: d,
    functionName: "execute",
    args: [g, v, S]
  });
  return {
    to: w,
    value: N + 10n,
    data: T
  };
}
const _1 = {
  CALL: 0,
  DELEGATECALL: 1,
  CREATE: 2,
  CREATE2: 3
}, G1 = {
  ERC721: "ERC721",
  ERC1155: "ERC1155"
}, z1 = {
  V2: 2,
  V3: 3
}, qa = "0.5.4";
class J1 {
  constructor(t) {
    Tt(this, "chainId");
    Tt(this, "chain");
    Tt(this, "isInitialized", !1);
    Tt(this, "publicClient");
    Tt(this, "supportsV3", !0);
    // Default to V3 implementation
    Tt(this, "signer");
    Tt(this, "walletClient");
    Tt(this, "implementationAddress");
    Tt(this, "registryAddress");
    var I;
    const {
      chainId: n,
      chain: r,
      signer: i,
      walletClient: s,
      publicClient: o,
      implementationAddress: u,
      registryAddress: d,
      publicClientRPCUrl: w,
      version: g
    } = t;
    if (!n && !r)
      throw new Error("chain or chainId required.");
    if (i && s)
      throw new Error(
        "Only one of `signer` or `walletClient` should be provided."
      );
    if (o && w)
      throw new Error(
        "Only one of `publicClient` or `publicClientRPCUrl` should be provided."
      );
    if (!Ht.ACCOUNT_PROXY)
      throw new Error("ERC_6551_DEFAULT.ACCOUNT_PROXY is undefined");
    if (this.chainId = n ?? (r == null ? void 0 : r.id), this.chain = r ?? m0(this.chainId), i ? this.signer = i : s && (this.walletClient = s), this.publicClient = o ?? Bf({
      chain: this.chain,
      transport: s && !w ? If(s.transport) : Mf(w ?? void 0)
    }), this.registryAddress = d ?? Ht.REGISTRY.ADDRESS, this.implementationAddress = u ?? ((I = Ht.ACCOUNT_PROXY) == null ? void 0 : I.ADDRESS), (g && g === z1.V2 || u && Tf(
      u,
      Ee.IMPLEMENTATION.ADDRESS
    )) && (this.supportsV3 = !1, d || (this.registryAddress = Ee.REGISTRY.ADDRESS)), this.isInitialized = !0, typeof window < "u") {
      const S = I0(u);
      window.tokenboundSDK = `Tokenbound SDK ${qa} - ${S}`;
    }
  }
  /**
   * Returns the SDK's package version.
   * @returns The version of the SDK.
   */
  getSDKVersion() {
    return qa;
  }
  /**
   * Returns the tokenbound account address for a given token contract and token ID.
   * @param {`0x${string}`} params.tokenContract The address of the token contract.
   * @param {string} params.tokenId The token ID.
   * @returns The tokenbound account address.
   */
  getAccount(t) {
    const { tokenContract: n, tokenId: r, salt: i = 0, chainId: s = this.chainId } = t;
    return (this.supportsV3 ? hs : ls)(
      n,
      r,
      s,
      this.implementationAddress,
      this.registryAddress,
      i
    );
  }
  /**
   * Returns the prepared transaction to create a tokenbound account for a given token contract and token ID.
   * @param {`0x${string}`} params.tokenContract The address of the token contract.
   * @param {string} params.tokenId The token ID.
   * @returns The prepared transaction to create a tokenbound account. Can be sent via `sendTransaction` on an Ethers signer or viem WalletClient.
   */
  async prepareCreateAccount(t) {
    var I, S, D;
    if (!Ht.ACCOUNT_PROXY)
      throw new Error("ERC_6551_DEFAULT.ACCOUNT_PROXY is undefined");
    const {
      tokenContract: n,
      tokenId: r,
      salt: i = 0,
      chainId: s = this.chainId,
      appendedCalls: o = []
    } = t, d = (this.supportsV3 ? hs : ls)(
      n,
      r,
      s,
      this.implementationAddress,
      this.registryAddress,
      i
    ), w = ![
      (I = Ht.ACCOUNT_PROXY) == null ? void 0 : I.ADDRESS,
      Ht.IMPLEMENTATION.ADDRESS
    ].includes(Vt(this.implementationAddress)), v = await (this.supportsV3 ? gd : pd)(
      n,
      r,
      s,
      this.implementationAddress,
      this.registryAddress,
      i
    );
    if (o.length > 0 && (!this.supportsV3 || w))
      throw new Error(
        "Multicall via appendedCalls is not supported using the legacy V2 implementation or custom implementations"
      );
    return w ? v : {
      to: g0,
      value: BigInt(0),
      data: De({
        abi: Rf,
        functionName: "aggregate3",
        args: [
          [
            {
              target: this.registryAddress,
              allowFailure: !1,
              callData: v.data
            },
            {
              target: d,
              allowFailure: !1,
              callData: De({
                abi: (S = Ht.ACCOUNT_PROXY) == null ? void 0 : S.ABI,
                functionName: "initialize",
                args: [(D = Ht.IMPLEMENTATION) == null ? void 0 : D.ADDRESS]
              })
            },
            // Append Multicall3 calls, so the newly-created Tokenbound account
            // can be used to execute calls immediately after creation
            ...o
          ]
        ]
      })
    };
  }
  /**
   * Returns the transaction hash of the transaction that created the tokenbound account for a given token contract and token ID.
   * @param {`0x${string}`} params.tokenContract The address of the token contract.
   * @param {string} params.tokenId The token ID.
   * @returns a Promise that resolves to the account address of the created tokenbound account.
   */
  async createAccount(t) {
    var v, I;
    const {
      tokenContract: n,
      tokenId: r,
      salt: i = 0,
      chainId: s = this.chainId,
      appendedCalls: o = []
    } = t;
    let u;
    const w = (this.supportsV3 ? hs : ls)(
      n,
      r,
      s,
      this.implementationAddress,
      this.registryAddress,
      i
    ), g = await this.prepareCreateAccount({
      tokenContract: n,
      tokenId: r,
      chainId: s,
      salt: i,
      appendedCalls: o
    });
    if (this.signer ? u = await this.signer.sendTransaction(g).then(
      (S) => S.hash
    ) : this.walletClient && (u = this.supportsV3 ? await this.walletClient.sendTransaction({
      ...g,
      chain: this.chain,
      // biome-ignore lint/style/noNonNullAssertion: Should exist
      account: (I = (v = this.walletClient) == null ? void 0 : v.account) == null ? void 0 : I.address
    }) : await yd(
      n,
      r,
      this.walletClient,
      this.implementationAddress,
      this.registryAddress,
      i,
      s
    )), u)
      return {
        account: w,
        txHash: u
      };
    throw new Error("No wallet client or signer available.");
  }
  /**
   * Returns prepared transaction to execute a call on a tokenbound account
   * @param {string} params.account The tokenbound account address
   * @param {string} params.to The recipient address
   * @param {bigint} params.value The value to send, in wei
   * @param {string} params.data The data to send
   * @returns a Promise with prepared transaction to execute a call on a tokenbound account. Can be sent via `sendTransaction` on a viem WalletClient or Ethers signer.
   * @deprecated this method is deprecated, but still available for use with legacy V2 deployments. Use prepareExecution() instead.
   */
  async prepareExecuteCall(t) {
    if (this.supportsV3)
      throw new Error(
        "prepareExecuteCall() is not supported on V3 implementation deployments, use prepareExecution() instead."
      );
    const { account: n, to: r, value: i, data: s } = t;
    return md(n, r, i, s);
  }
  /**
   * Executes a transaction call on a tokenbound account
   * @param {string} params.account The tokenbound account address
   * @param {string} params.to The recipient contract address
   * @param {bigint} params.value The value to send, in wei
   * @param {string} params.data The data to send
   * @returns a Promise that resolves to the transaction hash of the executed call
   * @deprecated this method is deprecated, but still available for use with legacy V2 deployments. Use execute() instead.
   */
  async executeCall(t) {
    const n = await this.prepareExecuteCall(t);
    if (this.supportsV3)
      throw new Error(
        "executeCall() is not supported on V3 implementation deployments, use execute() instead."
      );
    if (this.signer)
      return await this.signer.sendTransaction(n).then(
        (r) => r.hash
      );
    if (this.walletClient)
      return await this.walletClient.sendTransaction({
        // chain and account need to be added explicitly
        // because they're optional when instantiating a WalletClient
        chain: this.chain,
        // biome-ignore lint/style/noNonNullAssertion: Should exist
        account: this.walletClient.account,
        ...n
      });
    throw new Error("No wallet client or signer available.");
  }
  /**
   * Returns prepared transaction to execute on a tokenbound account
   * @param {string} params.account The tokenbound account address
   * @param {string} params.to The contract address to execute the call on
   * @param {bigint} params.value The value to send, in wei
   * @param {string} params.data The encoded operation calldata to send
   * @returns a Promise with prepared transaction to execute on a tokenbound account. Can be sent via `sendTransaction` on a viem WalletClient or Ethers signer.
   */
  async prepareExecution(t) {
    const { account: n, to: r, value: i, data: s, chainId: o = this.chainId } = t, u = _1.CALL;
    if (!this.supportsV3)
      return await this.prepareExecuteCall(t);
    let d = [r, i, s, u], w = 0n;
    if (this.chainId !== o) {
      const {
        to: v,
        value: I,
        data: S
      } = await L1({
        publicClient: this.publicClient,
        account: n,
        to: r,
        value: i,
        data: s,
        originChainId: this.chainId,
        destinationChainId: o
      });
      d = [v, I, S, u], w = I;
    }
    const g = De({
      abi: Ht.IMPLEMENTATION.ABI,
      functionName: "execute",
      args: d
    });
    return {
      to: n,
      value: w,
      data: g
    };
  }
  /**
   * Executes a transaction call on a tokenbound account
   * @param {string} params.account The tokenbound account address
   * @param {string} params.to The contract address to execute the call on
   * @param {bigint} params.value The value to send, in wei
   * @param {string} params.data The encoded operation calldata to send
   * @returns a Promise that resolves to the transaction hash of the executed call
   */
  async execute(t) {
    if (!this.supportsV3)
      return await this.executeCall(t);
    const n = await this.prepareExecution(t);
    if (this.signer)
      return await this.signer.sendTransaction(n).then(
        (r) => r.hash
      );
    if (this.walletClient)
      return await this.walletClient.sendTransaction({
        // chain and account need to be added explicitly
        // because they're optional when instantiating a WalletClient
        chain: this.chain,
        // biome-ignore lint/style/noNonNullAssertion: Should exist
        account: this.walletClient.account,
        ...n
      });
    throw new Error("No wallet client or signer available.");
  }
  /**
   * Check if a tokenbound account is a valid signer for a transaction
   * @param {string} params.account The tokenbound account address
   * @returns a Promise that resolves to true if the account is a valid signer, otherwise false
   */
  async isValidSigner({ account: t }) {
    var d;
    const { signer: n, walletClient: r } = this, i = Cf(0, { size: 32 }), s = "0x523e3260", o = ((d = r == null ? void 0 : r.account) == null ? void 0 : d.address) ?? (n == null ? void 0 : n.address);
    if (!n && !r)
      throw new Error("No signer or wallet client available.");
    if (!this.supportsV3)
      throw new Error(
        "isValidSigner is not supported using the V2 implementation"
      );
    return await this.publicClient.readContract({
      address: t,
      abi: Ht.IMPLEMENTATION.ABI,
      functionName: "isValidSigner",
      args: [o, i]
    }) === s;
  }
  /**
   * Check if a tokenbound account has been deployed
   * @param {string} params.accountAddress The tokenbound account address
   * @returns a Promise that resolves to true if the account is deployed, otherwise false
   */
  async checkAccountDeployment({
    accountAddress: t
  }) {
    return await this.publicClient.getBytecode({ address: t }).then((n) => n ? n.length > 2 : !1);
  }
  /**
   * Deconstructs the bytecode of a tokenbound account into its constituent parts.
   * @param {`0x${string}`} params.accountAddress The address of the tokenbound account.
   * @returns a Promise that resolves to a SegmentedERC6551Bytecode object, or null if the account is not deployed
   */
  async deconstructBytecode({
    accountAddress: t
  }) {
    const n = await this.publicClient.getBytecode({
      address: t
    }), r = n == null ? void 0 : n.slice(2);
    if (!r || !n || !(n.length > 2))
      return null;
    const [
      i,
      s,
      o,
      u,
      d,
      w,
      g
    ] = dd(r, 10, 20, 15, 32, 32, 32, 32), v = ss(`0x${d}`, { size: 32 }), I = Vt(
      `0x${s}`
    ), S = ss(`0x${u}`, { size: 32 }), D = Vt(
      `0x${w.slice(
        w.length - 40,
        w.length
      )}`
    ), N = ss(`0x${g}`, { size: 32 }).toString();
    return {
      erc1167Header: i,
      implementationAddress: I,
      erc1167Footer: o,
      salt: S,
      tokenId: N,
      tokenContract: D,
      chainId: v
    };
  }
  /**
   * Get NFT information from a tokenbound account
   * @param {`0x${string}`} params.accountAddress The address of the tokenbound account.
   * @returns a Promise that resolves to an object containing the token contract address, token ID, and chain ID
   */
  async getNFT({
    accountAddress: t
  }) {
    const n = await this.deconstructBytecode({
      accountAddress: t
    });
    if (!n)
      throw new Error(
        "The tokenbound account has not been deployed at this address"
      );
    const { chainId: r, tokenContract: i, tokenId: s } = n;
    return {
      tokenContract: i,
      tokenId: s,
      chainId: r
    };
  }
  /**
   * Executes a transaction call on a tokenbound account
   * @param {string} params.account The tokenbound account address
   * @param {string} params.tokenType The type of token, either 'ERC721' or 'ERC1155'
   * @param {string} params.tokenContract The address of the token contract
   * @param {string} params.tokenId The token ID
   * @param {string} params.recipientAddress The address to which the token should be transferred
   * @param {string} params.amount The amount of tokens to transfer, (eg. 1 NFT = 1). Defaults to 1. 1155 only.
   * @returns a Promise that resolves to the transaction hash of the executed call
   */
  async transferNFT(t) {
    const {
      account: n,
      tokenType: r,
      tokenContract: i,
      tokenId: s,
      amount: o = 1,
      recipientAddress: u,
      chainId: d
    } = t, w = r === G1.ERC1155;
    if (!w && o !== 1)
      throw new Error("ERC721 transfers can only transfer one token at a time.");
    try {
      const g = await fs(
        this.publicClient,
        u
      ), v = [n, g, s], I = w ? [...v, o, "0x"] : v, S = De({
        abi: w ? Ff : kf,
        functionName: "safeTransferFrom",
        args: I
      }), D = {
        account: n,
        to: i,
        value: BigInt(0),
        data: S
      };
      return this.supportsV3 ? await this.execute({
        ...D,
        chainId: d
      }) : await this.executeCall(D);
    } catch (g) {
      throw console.log(g), g;
    }
  }
  /**
   * Executes an ETH transfer call on a tokenbound account
   * @param {string} params.account The tokenbound account address
   * @param {number} params.amount The amount of ETH to transfer, in decimal format (eg. 0.1 ETH = 0.1)
   * @param {string} params.recipientAddress The address to which the ETH should be transferred
   * @returns a Promise that resolves to the transaction hash of the executed call
   */
  async transferETH(t) {
    const {
      account: n,
      amount: r,
      recipientAddress: i,
      chainId: s
    } = t, o = $o(`${r}`, 18);
    try {
      const u = await fs(
        this.publicClient,
        i
      ), d = {
        account: n,
        to: u,
        value: o,
        data: "0x"
      };
      return this.supportsV3 ? await this.execute({
        ...d,
        chainId: s
      }) : await this.executeCall(d);
    } catch (u) {
      throw console.log(u), u;
    }
  }
  /**
   * Executes an ERC-20 transfer call on a tokenbound account
   * @param {string} params.account The tokenbound account address
   * @param {number} params.amount The amount of ERC-20 to transfer, in decimal format (eg. 0.1 USDC = 0.1)
   * @param {string} params.recipientAddress The address to which the ETH should be transferred
   * @param {string} params.erc20tokenAddress The address of the ERC-20 token contract
   * @param {string} params.erc20tokenDecimals The decimal specification of the ERC-20 token
   * @returns a Promise that resolves to the transaction hash of the executed call
   */
  async transferERC20(t) {
    const {
      account: n,
      amount: r,
      recipientAddress: i,
      erc20tokenAddress: s,
      erc20tokenDecimals: o,
      chainId: u
    } = t;
    if (o < 0 || o > 18)
      throw new Error("Decimal value out of range. Should be between 0 and 18.");
    const d = $o(`${r}`, o);
    try {
      const w = await fs(
        this.publicClient,
        i
      ), g = De({
        abi: Nf,
        functionName: "transfer",
        args: [w, d]
      }), v = {
        account: n,
        to: s,
        value: 0n,
        data: g
      };
      return this.supportsV3 ? await this.execute({
        ...v,
        chainId: u
      }) : await this.executeCall(v);
    } catch (w) {
      throw console.log(w), w;
    }
  }
  /**
   * Calculates an Ethereum-specific signature
   * @param {string} params.message The message to be signed
   * @returns a Promise that resolves to a signed Hex string
   */
  async signMessage(t) {
    const { message: n } = t;
    try {
      if (this.signer) {
        if (!M0 && !T0)
          throw new Error("Message is not a valid Ethers signable message.");
        const r = S0(
          n
        );
        return await this.signer.signMessage(r);
      }
      if (this.walletClient) {
        if (!C0(n))
          throw new Error("Message is not a valid viem signable message.");
        return await this.walletClient.signMessage({
          // biome-ignore lint/style/noNonNullAssertion: Should exist
          account: this.walletClient.account,
          message: n
        });
      }
      throw new Error("No wallet client or signer available.");
    } catch (r) {
      throw console.log(r), r;
    }
  }
}
const X1 = Ht.IMPLEMENTATION.ABI;
var ja;
const W1 = (ja = Ht.ACCOUNT_PROXY) == null ? void 0 : ja.ABI, $1 = Ht.REGISTRY.ABI;
export {
  _1 as CALL_OPERATIONS,
  z1 as TBVersion,
  J1 as TokenboundClient,
  ls as computeAccount,
  yd as createAccount,
  Uf as erc6551AccountAbiV2,
  X1 as erc6551AccountAbiV3,
  W1 as erc6551AccountProxyAbiV3,
  Sf as erc6551RegistryAbiV2,
  $1 as erc6551RegistryAbiV3,
  K1 as executeCall,
  Q1 as getAccount,
  wd as getCreationCode,
  pd as prepareCreateAccount,
  md as prepareExecuteCall
};
